introduction to probability
for
data science
stanley h. chan
purdue university
copyright ©2021 stanley h. chan
this book is published by michigan publishing under an agreement with the author. it is
made available free of charge in electronic form to any student or instructor interested in
the subject matter.
published in the united states of america by
michigan publishing
manufactured in the united states of america
isbn 978-1-60785-746-4 (hardcover)
isbn 978-1-60785-747-1 (electronic)
iito vivian, joanna, and cynthia chan
and ye shall know the truth, and the truth shall make you free.
john 8:32
iiiivpreface
this book is an introductory textbook in undergraduate probability. it has a mission: to spell
out the motivation ,intuition , and implication of the probabilistic tools we use in science
and engineering. from over half a decade of teaching the course, i have distilled what i
believe to be the core of probabilistic methods. i put the book in the context of data science
to emphasize the inseparability between data (computing) and probability (theory) in our
time.
probability is one of the most interesting subjects in electrical engineering and com-
puter science. it bridges our favorite engineering principles to the practical reality, a world
that is full of uncertainty. however, because probability is such a mature subject, the under-
graduate textbooks alone might fill several rows of shelves in a library. when the literature
is so rich, the challenge becomes how one can pierce through to the insight while diving into
the details. for example, many of you have used a normal random variable before, but have
you ever wondered where the “bell shape” comes from? every probability class will teach
you about flipping a coin, but how can “flipping a coin” ever be useful in machine learning
today? data scientists use the poisson random variables to model the internet traffic, but
where does the gorgeous poisson equation come from? this book is designed to fill these
gaps with knowledge that is essential to all data science students.
this leads to the three goals of the book. (i) motivation: in the ocean of mathematical
definitions, theorems, and equations, why should we spend our time on this particular topic
but not another? (ii) intuition: when going through the derivations, is there a geometric
interpretation or physics beyond those equations? (iii) implication: after we have learned a
topic, what new problems can we solve?
the book’s intended audience is undergraduate juniors/seniors and first-year gradu-
ate students majoring in electrical engineering and computer science. the prerequisites are
standard undergraduate linear algebra and calculus, except for the section about charac-
teristic functions, where fourier transforms are needed. an undergraduate course in signals
and systems would suffice, even taken concurrently while studying this book.
the length of the book is suitable for a two-semester course. instructors are encouraged
to use the set of chapters that best fits their classes. for example, a basic probability course
can use chapters 1-5 as its backbone. chapter 6 on sample statistics is suitable for students
who wish to gain theoretical insights into probabilistic convergence. chapter 7 on regression
and chapter 8 on estimation best suit students who want to pursue machine learning and
signal processing. chapter 9 discusses confidence intervals and hypothesis testing, which are
critical to modern data analysis. chapter 10 introduces random processes. my approach for
random processes is more tailored to information processing and communication systems,
which are usually more relevant to electrical engineering students.
additional teaching resources can be found on the book’s website, where you can
vfind lecture videos and homework videos. throughout the book you will see many “practice
exercises”, which are easy problems with worked-out solutions. they can be skipped without
loss to the flow of the book.
acknowledgements: if i could thank only one person, it must be professor fawwaz
ulaby of the university of michigan. professor ulaby has been the source of support in
all aspects, from the book’s layout to technical content, proofreading, and marketing. the
book would not have been published without the help of professor ulaby. i am deeply
moved by professor ulaby’s vision that education should be made accessible to all students.
with textbook prices rocketing up, the eecs free textbook initiative launched by professor
ulaby is the most direct response to the publishers, teachers, parents, and students. thank
you, fawwaz, for your unbounded support — technically, mentally, and financially. thank
you also for recommending richard carnes. the meticulous details richard offered have
significantly improved the fluency of the book. thank you, richard.
i thank my colleagues at purdue who had shared many thoughts with me when i
taught the course (in alphabetical order): professors mark bell, mary comer, saul gelfand,
amy reibman, and chih-chun wang. my teaching assistant i-fan lin was instrumental in
the early development of this book. to the graduate students of my lab (yiheng chi, nick
chimitt, kent gauen, abhiram gnanasambandam, guanzhe hong, chengxi li, zhiyuan
mao, xiangyu qu, and yash sanghvi): thank you! it would have been impossible to finish
the book without your participation. a few students i taught volunteered to help edit
the book: benjamin gottfried, harrison hsueh, dawoon jung, antonio kincaid, deepak
ravikumar, krister ulvog, peace umoru, zhijing yao. i would like to thank my ph.d.
advisor professor truong nguyen for encouraging me to write the book.
finally, i would like to thank my wife vivian and my daughters, joanna and cynthia,
for their love, patience, and support.
stanley h. chan, west lafayette, indiana
may, 2021
companion website:
https://probability4datascience.com/
vicontents
1 mathematical background 1
1.1 infinite series . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2
1.1.1 geometric series . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
1.1.2 binomial series . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
1.2 approximation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
1.2.1 taylor approximation . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
1.2.2 exponential series . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
1.2.3 logarithmic approximation . . . . . . . . . . . . . . . . . . . . . . . . 13
1.3 integration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15
1.3.1 odd and even functions . . . . . . . . . . . . . . . . . . . . . . . . . . 15
1.3.2 fundamental theorem of calculus . . . . . . . . . . . . . . . . . . . . 17
1.4 linear algebra . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
1.4.1 why do we need linear algebra in data science? . . . . . . . . . . . . . 20
1.4.2 everything you need to know about linear algebra . . . . . . . . . . . 21
1.4.3 inner products and norms . . . . . . . . . . . . . . . . . . . . . . . . . 24
1.4.4 matrix calculus . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
1.5 basic combinatorics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
1.5.1 birthday paradox . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
1.5.2 permutation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33
1.5.3 combination . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34
1.6 summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37
1.7 reference . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38
1.8 problems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38
2 probability 43
2.1 set theory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44
2.1.1 why study set theory? . . . . . . . . . . . . . . . . . . . . . . . . . . . 44
2.1.2 basic concepts of a set . . . . . . . . . . . . . . . . . . . . . . . . . . . 45
2.1.3 subsets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47
2.1.4 empty set and universal set . . . . . . . . . . . . . . . . . . . . . . . . 48
2.1.5 union . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48
2.1.6 intersection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50
2.1.7 complement and difference . . . . . . . . . . . . . . . . . . . . . . . . 52
2.1.8 disjoint and partition . . . . . . . . . . . . . . . . . . . . . . . . . . . 54
2.1.9 set operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56
2.1.10 closing remarks about set theory . . . . . . . . . . . . . . . . . . . . . 57
viicontents
2.2 probability space . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58
2.2.1 sample space ω . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59
2.2.2 event space f. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61
2.2.3 probability law p. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66
2.2.4 measure zero sets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 71
2.2.5 summary of the probability space . . . . . . . . . . . . . . . . . . . . 74
2.3 axioms of probability . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74
2.3.1 why these three probability axioms? . . . . . . . . . . . . . . . . . . . 75
2.3.2 axioms through the lens of measure . . . . . . . . . . . . . . . . . . . 76
2.3.3 corollaries derived from the axioms . . . . . . . . . . . . . . . . . . . 77
2.4 conditional probability . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80
2.4.1 definition of conditional probability . . . . . . . . . . . . . . . . . . . 81
2.4.2 independence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 85
2.4.3 bayes’ theorem and the law of total probability . . . . . . . . . . . . . 89
2.4.4 the three prisoners problem . . . . . . . . . . . . . . . . . . . . . . . 92
2.5 summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 95
2.6 references . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96
2.7 problems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 97
3 discrete random variables 103
3.1 random variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105
3.1.1 a motivating example . . . . . . . . . . . . . . . . . . . . . . . . . . . 105
3.1.2 definition of a random variable . . . . . . . . . . . . . . . . . . . . . . 105
3.1.3 probability measure on random variables . . . . . . . . . . . . . . . . 107
3.2 probability mass function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 110
3.2.1 definition of probability mass function . . . . . . . . . . . . . . . . . . 110
3.2.2 pmf and probability measure . . . . . . . . . . . . . . . . . . . . . . . 110
3.2.3 normalization property . . . . . . . . . . . . . . . . . . . . . . . . . . 112
3.2.4 pmf versus histogram . . . . . . . . . . . . . . . . . . . . . . . . . . . 113
3.2.5 estimating histograms from real data . . . . . . . . . . . . . . . . . . 117
3.3 cumulative distribution functions (discrete) . . . . . . . . . . . . . . . . . . 121
3.3.1 definition of the cumulative distribution function . . . . . . . . . . . . 121
3.3.2 properties of the cdf . . . . . . . . . . . . . . . . . . . . . . . . . . . 123
3.3.3 converting between pmf and cdf . . . . . . . . . . . . . . . . . . . 124
3.4 expectation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125
3.4.1 definition of expectation . . . . . . . . . . . . . . . . . . . . . . . . . . 125
3.4.2 existence of expectation . . . . . . . . . . . . . . . . . . . . . . . . . . 130
3.4.3 properties of expectation . . . . . . . . . . . . . . . . . . . . . . . . . 130
3.4.4 moments and variance . . . . . . . . . . . . . . . . . . . . . . . . . . . 133
3.5 common discrete random variables . . . . . . . . . . . . . . . . . . . . . . . 136
3.5.1 bernoulli random variable . . . . . . . . . . . . . . . . . . . . . . . . . 137
3.5.2 binomial random variable . . . . . . . . . . . . . . . . . . . . . . . . . 143
3.5.3 geometric random variable . . . . . . . . . . . . . . . . . . . . . . . . 149
3.5.4 poisson random variable . . . . . . . . . . . . . . . . . . . . . . . . . . 152
3.6 summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 164
3.7 references . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 165
3.8 problems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 166
viiicontents
4 continuous random variables 171
4.1 probability density function . . . . . . . . . . . . . . . . . . . . . . . . . . . 172
4.1.1 some intuitions about probability density functions . . . . . . . . . . . 172
4.1.2 more in-depth discussion about pdfs . . . . . . . . . . . . . . . . . . 174
4.1.3 connecting with the pmf . . . . . . . . . . . . . . . . . . . . . . . . . 178
4.2 expectation, moment, and variance . . . . . . . . . . . . . . . . . . . . . . . 180
4.2.1 definition and properties . . . . . . . . . . . . . . . . . . . . . . . . . 180
4.2.2 existence of expectation . . . . . . . . . . . . . . . . . . . . . . . . . . 183
4.2.3 moment and variance . . . . . . . . . . . . . . . . . . . . . . . . . . . 184
4.3 cumulative distribution function . . . . . . . . . . . . . . . . . . . . . . . . 185
4.3.1 cdf for continuous random variables . . . . . . . . . . . . . . . . . . 186
4.3.2 properties of cdf . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 188
4.3.3 retrieving pdf from cdf . . . . . . . . . . . . . . . . . . . . . . . . 193
4.3.4 cdf: unifying discrete and continuous random variables . . . . . . . 194
4.4 median, mode, and mean . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 196
4.4.1 median . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 196
4.4.2 mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 198
4.4.3 mean . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 199
4.5 uniform and exponential random variables . . . . . . . . . . . . . . . . . . . 201
4.5.1 uniform random variables . . . . . . . . . . . . . . . . . . . . . . . . . 202
4.5.2 exponential random variables . . . . . . . . . . . . . . . . . . . . . . . 205
4.5.3 origin of exponential random variables . . . . . . . . . . . . . . . . . . 207
4.5.4 applications of exponential random variables . . . . . . . . . . . . . . 209
4.6 gaussian random variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . 211
4.6.1 definition of a gaussian random variable . . . . . . . . . . . . . . . . 211
4.6.2 standard gaussian . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 213
4.6.3 skewness and kurtosis . . . . . . . . . . . . . . . . . . . . . . . . . . . 216
4.6.4 origin of gaussian random variables . . . . . . . . . . . . . . . . . . 220
4.7 functions of random variables . . . . . . . . . . . . . . . . . . . . . . . . . . 223
4.7.1 general principle . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 223
4.7.2 examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 225
4.8 generating random numbers . . . . . . . . . . . . . . . . . . . . . . . . . . . 229
4.8.1 general principle . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 229
4.8.2 examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 230
4.9 summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 235
4.10 reference . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 236
4.11 problems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 237
5 joint distributions 241
5.1 joint pmf and joint pdf . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 244
5.1.1 probability measure in 2d . . . . . . . . . . . . . . . . . . . . . . . . . 244
5.1.2 discrete random variables . . . . . . . . . . . . . . . . . . . . . . . . . 245
5.1.3 continuous random variables . . . . . . . . . . . . . . . . . . . . . . . 247
5.1.4 normalization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 248
5.1.5 marginal pmf and marginal pdf . . . . . . . . . . . . . . . . . . . . 250
5.1.6 independent random variables . . . . . . . . . . . . . . . . . . . . . . 251
5.1.7 joint cdf . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 255
5.2 joint expectation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 257
ixcontents
5.2.1 definition and interpretation . . . . . . . . . . . . . . . . . . . . . . . 257
5.2.2 covariance and correlation coefficient . . . . . . . . . . . . . . . . . . 261
5.2.3 independence and correlation . . . . . . . . . . . . . . . . . . . . . . . 263
5.2.4 computing correlation from data . . . . . . . . . . . . . . . . . . . . . 265
5.3 conditional pmf and pdf . . . . . . . . . . . . . . . . . . . . . . . . . . . . 266
5.3.1 conditional pmf . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 267
5.3.2 conditional pdf . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 271
5.4 conditional expectation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 275
5.4.1 definition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 275
5.4.2 the law of total expectation . . . . . . . . . . . . . . . . . . . . . . . 276
5.5 sum of two random variables . . . . . . . . . . . . . . . . . . . . . . . . . . 280
5.5.1 intuition through convolution . . . . . . . . . . . . . . . . . . . . . . . 280
5.5.2 main result . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 281
5.5.3 sum of common distributions . . . . . . . . . . . . . . . . . . . . . . . 282
5.6 random vectors and covariance matrices . . . . . . . . . . . . . . . . . . . . 286
5.6.1 pdf of random vectors . . . . . . . . . . . . . . . . . . . . . . . . . . 286
5.6.2 expectation of random vectors . . . . . . . . . . . . . . . . . . . . . . 288
5.6.3 covariance matrix . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 289
5.6.4 multidimensional gaussian . . . . . . . . . . . . . . . . . . . . . . . . 290
5.7 transformation of multidimensional gaussians . . . . . . . . . . . . . . . . . 293
5.7.1 linear transformation of mean and covariance . . . . . . . . . . . . . . 293
5.7.2 eigenvalues and eigenvectors . . . . . . . . . . . . . . . . . . . . . . . 295
5.7.3 covariance matrices are always positive semi-definite . . . . . . . . . . 297
5.7.4 gaussian whitening . . . . . . . . . . . . . . . . . . . . . . . . . . . . 299
5.8 principal-component analysis . . . . . . . . . . . . . . . . . . . . . . . . . . 303
5.8.1 the main idea: eigendecomposition . . . . . . . . . . . . . . . . . . . 303
5.8.2 the eigenface problem . . . . . . . . . . . . . . . . . . . . . . . . . . . 309
5.8.3 what cannot be analyzed by pca? . . . . . . . . . . . . . . . . . . . 311
5.9 summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 312
5.10 references . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 313
5.11 problems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 314
6 sample statistics 319
6.1 moment-generating and characteristic functions . . . . . . . . . . . . . . . . 324
6.1.1 moment-generating function . . . . . . . . . . . . . . . . . . . . . . . . 324
6.1.2 sum of independent variables via mgf . . . . . . . . . . . . . . . . . 327
6.1.3 characteristic functions . . . . . . . . . . . . . . . . . . . . . . . . . . 329
6.2 probability inequalities . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 333
6.2.1 union bound . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 333
6.2.2 the cauchy-schwarz inequality . . . . . . . . . . . . . . . . . . . . . . 335
6.2.3 jensen’s inequality . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 336
6.2.4 markov’s inequality . . . . . . . . . . . . . . . . . . . . . . . . . . . . 339
6.2.5 chebyshev’s inequality . . . . . . . . . . . . . . . . . . . . . . . . . . . 341
6.2.6 chernoff’s bound . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 343
6.2.7 comparing chernoff and chebyshev . . . . . . . . . . . . . . . . . . . 344
6.2.8 hoeffding’s inequality . . . . . . . . . . . . . . . . . . . . . . . . . . . 348
6.3 law of large numbers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 351
6.3.1 sample average . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 351
xcontents
6.3.2 weak law of large numbers (wlln) . . . . . . . . . . . . . . . . . . . 354
6.3.3 convergence in probability . . . . . . . . . . . . . . . . . . . . . . . . 356
6.3.4 can we prove wlln using chernoff’s bound? . . . . . . . . . . . . . 358
6.3.5 does the weak law of large numbers always hold? . . . . . . . . . . . . 359
6.3.6 strong law of large numbers . . . . . . . . . . . . . . . . . . . . . . . . 360
6.3.7 almost sure convergence . . . . . . . . . . . . . . . . . . . . . . . . . . 362
6.3.8 proof of the strong law of large numbers . . . . . . . . . . . . . . . . . 364
6.4 central limit theorem . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 366
6.4.1 convergence in distribution . . . . . . . . . . . . . . . . . . . . . . . . 367
6.4.2 central limit theorem . . . . . . . . . . . . . . . . . . . . . . . . . . 372
6.4.3 examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 377
6.4.4 limitation of the central limit theorem . . . . . . . . . . . . . . . . 378
6.5 summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 380
6.6 references . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 381
6.7 problems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 383
7 regression 389
7.1 principles of regression . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 394
7.1.1 intuition: how to fit a straight line? . . . . . . . . . . . . . . . . . . . 395
7.1.2 solving the linear regression problem . . . . . . . . . . . . . . . . . . . 397
7.1.3 extension: beyond a straight line . . . . . . . . . . . . . . . . . . . . . 401
7.1.4 overdetermined and underdetermined systems . . . . . . . . . . . . . 409
7.1.5 robust linear regression . . . . . . . . . . . . . . . . . . . . . . . . . . 412
7.2 overfitting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 418
7.2.1 overview of overfitting . . . . . . . . . . . . . . . . . . . . . . . . . . . 419
7.2.2 analysis of the linear case . . . . . . . . . . . . . . . . . . . . . . . . . 420
7.2.3 interpreting the linear analysis results . . . . . . . . . . . . . . . . . . 425
7.3 bias and variance trade-off . . . . . . . . . . . . . . . . . . . . . . . . . . . . 429
7.3.1 decomposing the testing error . . . . . . . . . . . . . . . . . . . . . . 430
7.3.2 analysis of the bias . . . . . . . . . . . . . . . . . . . . . . . . . . . . 433
7.3.3 variance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 436
7.3.4 bias and variance on the learning curve . . . . . . . . . . . . . . . . . 438
7.4 regularization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 440
7.4.1 ridge regularization . . . . . . . . . . . . . . . . . . . . . . . . . . . . 440
7.4.2 lasso regularization . . . . . . . . . . . . . . . . . . . . . . . . . . . 449
7.5 summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 457
7.6 references . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 458
7.7 problems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 459
8 estimation 465
8.1 maximum-likelihood estimation . . . . . . . . . . . . . . . . . . . . . . . . . 468
8.1.1 likelihood function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 468
8.1.2 maximum-likelihood estimate . . . . . . . . . . . . . . . . . . . . . . . 472
8.1.3 application 1: social network analysis . . . . . . . . . . . . . . . . . . 478
8.1.4 application 2: reconstructing images . . . . . . . . . . . . . . . . . . 481
8.1.5 more examples of ml estimation . . . . . . . . . . . . . . . . . . . . . 484
8.1.6 regression versus ml estimation . . . . . . . . . . . . . . . . . . . . . 487
8.2 properties of ml estimates . . . . . . . . . . . . . . . . . . . . . . . . . . . . 491
xicontents
8.2.1 estimators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 491
8.2.2 unbiased estimators . . . . . . . . . . . . . . . . . . . . . . . . . . . . 492
8.2.3 consistent estimators . . . . . . . . . . . . . . . . . . . . . . . . . . . 494
8.2.4 invariance principle . . . . . . . . . . . . . . . . . . . . . . . . . . . . 500
8.3 maximum a posteriori estimation . . . . . . . . . . . . . . . . . . . . . . . . 502
8.3.1 the trio of likelihood, prior, and posterior . . . . . . . . . . . . . . . . 503
8.3.2 understanding the priors . . . . . . . . . . . . . . . . . . . . . . . . . 504
8.3.3 map formulation and solution . . . . . . . . . . . . . . . . . . . . . . 506
8.3.4 analyzing the map solution . . . . . . . . . . . . . . . . . . . . . . . 508
8.3.5 analysis of the posterior distribution . . . . . . . . . . . . . . . . . . . 511
8.3.6 conjugate prior . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 513
8.3.7 linking map with regression . . . . . . . . . . . . . . . . . . . . . . . 517
8.4 minimum mean-square estimation . . . . . . . . . . . . . . . . . . . . . . . . 520
8.4.1 positioning the minimum mean-square estimation . . . . . . . . . . . 520
8.4.2 mean squared error . . . . . . . . . . . . . . . . . . . . . . . . . . . . 522
8.4.3 mmse estimate = conditional expectation . . . . . . . . . . . . . . . 523
8.4.4 mmse estimator for multidimensional gaussian . . . . . . . . . . . . 529
8.4.5 linking mmse and neural networks . . . . . . . . . . . . . . . . . . . 533
8.5 summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 534
8.6 references . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 535
8.7 problems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 536
9 confidence and hypothesis 541
9.1 confidence interval . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 543
9.1.1 the randomness of an estimator . . . . . . . . . . . . . . . . . . . . . 543
9.1.2 understanding confidence intervals . . . . . . . . . . . . . . . . . . . . 545
9.1.3 constructing a confidence interval . . . . . . . . . . . . . . . . . . . . 548
9.1.4 properties of the confidence interval . . . . . . . . . . . . . . . . . . . 551
9.1.5 student’s t-distribution . . . . . . . . . . . . . . . . . . . . . . . . . . 554
9.1.6 comparing student’s t-distribution and gaussian . . . . . . . . . . . . 558
9.2 bootstrapping . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 559
9.2.1 a brute force approach . . . . . . . . . . . . . . . . . . . . . . . . . . 560
9.2.2 bootstrapping . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 562
9.3 hypothesis testing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 566
9.3.1 what is a hypothesis? . . . . . . . . . . . . . . . . . . . . . . . . . . . 566
9.3.2 critical-value test . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 567
9.3.3 p-value test . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 571
9.3.4 z-test and t-test . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 574
9.4 neyman-pearson test . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 577
9.4.1 null and alternative distributions . . . . . . . . . . . . . . . . . . . . . 577
9.4.2 type 1 and type 2 errors . . . . . . . . . . . . . . . . . . . . . . . . . 579
9.4.3 neyman-pearson decision . . . . . . . . . . . . . . . . . . . . . . . . . 582
9.5 roc and precision-recall curve . . . . . . . . . . . . . . . . . . . . . . . . . 589
9.5.1 receiver operating characteristic (roc) . . . . . . . . . . . . . . . . 589
9.5.2 comparing roc curves . . . . . . . . . . . . . . . . . . . . . . . . . . 592
9.5.3 the roc curve in practice . . . . . . . . . . . . . . . . . . . . . . . . 598
9.5.4 the precision-recall (pr) curve . . . . . . . . . . . . . . . . . . . . . 601
9.6 summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 605
xiicontents
9.7 reference . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 606
9.8 problems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 607
10 random processes 611
10.1 basic concepts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 612
10.1.1 everything you need to know about a random process . . . . . . . . . 612
10.1.2 statistical and temporal perspectives . . . . . . . . . . . . . . . . . . . 614
10.2 mean and correlation functions . . . . . . . . . . . . . . . . . . . . . . . . . 618
10.2.1 mean function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 618
10.2.2 autocorrelation function . . . . . . . . . . . . . . . . . . . . . . . . . . 622
10.2.3 independent processes . . . . . . . . . . . . . . . . . . . . . . . . . . . 629
10.3 wide-sense stationary processes . . . . . . . . . . . . . . . . . . . . . . . . . 630
10.3.1 definition of a wss process . . . . . . . . . . . . . . . . . . . . . . . . 631
10.3.2 properties of rx(τ) . . . . . . . . . . . . . . . . . . . . . . . . . . . . 632
10.3.3 physical interpretation of rx(τ) . . . . . . . . . . . . . . . . . . . . . 633
10.4 power spectral density . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 636
10.4.1 basic concepts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 636
10.4.2 origin of the power spectral density . . . . . . . . . . . . . . . . . . . 640
10.5 wss process through lti systems . . . . . . . . . . . . . . . . . . . . . . . . 643
10.5.1 review of linear time-invariant systems . . . . . . . . . . . . . . . . . 643
10.5.2 mean and autocorrelation through lti systems . . . . . . . . . . . . . 644
10.5.3 power spectral density through lti systems . . . . . . . . . . . . . . . 646
10.5.4 cross-correlation through lti systems . . . . . . . . . . . . . . . . . . 649
10.6 optimal linear filter . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 653
10.6.1 discrete-time random processes . . . . . . . . . . . . . . . . . . . . . . 653
10.6.2 problem formulation . . . . . . . . . . . . . . . . . . . . . . . . . . . . 654
10.6.3 yule-walker equation . . . . . . . . . . . . . . . . . . . . . . . . . . . 656
10.6.4 linear prediction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 658
10.6.5 wiener filter . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 662
10.7 summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 669
10.8 appendix . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 670
10.8.1 the mean-square ergodic theorem . . . . . . . . . . . . . . . . . . . 674
10.9 references . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 675
10.10problems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 676
a appendix 681
xiiicontents
xivchapter 1
mathematical background
“data science” has different meanings to different people. if you ask a biologist, data science
could mean analyzing dna sequences. if you ask a banker, data science could mean pre-
dicting the stock market. if you ask a software engineer, data science could mean programs
and data structures; if you ask a machine learning scientist, data science could mean models
and algorithms. however, one thing that is common in all these disciplines is the concept of
uncertainty . we choose to learn from data because we believe that the latent information
is embedded in the data — unprocessed, contains noise, and could have missing entries. if
there is no randomness, all data scientists can close their business because there is simply
no problem to solve. however, the moment we see randomness, our business comes back.
therefore, data science is the subject of making decisions in uncertainty.
the mathematics of analyzing uncertainty is probability . it is thetool to help us model,
analyze, and predict random events. probability can be studied in as many ways as you can
think of. you can take a rigorous course in probability theory, or a “probability for dummies”
on the internet, or a typical undergraduate probability course offered by your school. this
book is different from all these. our goal is to tell you how things work in the context of data
science. for example, why do we need those three axioms of probabilities and not others?
where does the “bell shape” gaussian random variable come from? how many samples do
we need to construct a reliable histogram? these questions are at the core of data science,
and they deserve close attention rather than sweeping them under the rug.
to help you get used to the pace and style of this book, in this chapter, we review some
of the very familiar topics in undergraduate algebra and calculus. these topics are meant
to warm up your mathematics background so that you can follow the subsequent chapters.
specifically, in this chapter, we cover several topics. first, in section 1.1 we discuss infinite
series, something that will be used frequently when we evaluate the expectation and variance
of random variables in chapter 3. in section 1.2 we review the taylor approximation,
which will be helpful when we discuss continuous random variables. section 1.3 discusses
integration and reviews several tricks we can use to make integration easy. section 1.4
deals with linear algebra, aka matrices and vectors, which are fundamental to modern data
analysis. finally, section 1.5 discusses permutation and combination, two basic techniques
to count events.
1chapter 1. mathematical background
1.1 infinite series
imagine that you have a fair coin . if you get a tail, you flip it again. you do this repeatedly
until you finally get a head. what is the probability that you need to flip the coin three
times to get one head?
this is a warm-up exercise. since the coin is fair, the probability of obtaining a head
is1
2. the probability of getting a tail followed by a head is1
2×1
2=1
4. similarly, the
probability of getting two tails and then a head is1
2×1
2×1
2=1
8. if you follow this logic, you
can write down the probabilities for all other cases. for your convenience, we have drawn the
first few in figure 1.1 . as you have probably noticed, the probabilities follow the pattern
{1
2,1
4,1
8, . . .}.
figure 1.1: suppose you flip a coin until you see a head. this requires you to have n−1tails followed
by a head. the probability of this sequence of events are1
2,1
4,1
8, . . . , which forms an infinite sequence.
we can also summarize these probabilities using a familiar plot called the histogram
as shown in figure 1.2 . the histogram for this problem has a special pattern, that every
value is one order higher than the preceding one, and the sequence is infinitely long.
1 2 3 4 5 6 7 8 9 1000.10.20.30.40.5
figure 1.2: the histogram of flipping a coin until we see a head. the x-axis is the number of coin flips,
and the y-axis is the probability.
let us ask something harder: on average, if you want to be 90% sure that you will
get a head, what is the minimum number of attempts you need to try? five attempts?
ten attempts? indeed, if you try ten attempts, you will very likely accomplish your goal.
however, this would seem to be overkill. if you try five attempts, then it becomes unclear
whether you will be 90% sure.
21.1. infinite series
this problem can be answered by analyzing the sequence of probabilities. if we make
two attempts, then the probability of getting a head is the sum of the probabilities for one
attempt and that of two attempts:
p[success after 1 attempt] =1
2= 0.5
p[success after 2 attempts] =1
2+1
4= 0.75
therefore, if you make 3 attempts or 4 attempts, you get the following probabilities:
p[success after 3 attempts] =1
2+1
4+1
8= 0.875
p[success after 4 attempts] =1
2+1
4+1
8+1
16= 0.9375.
so if we try four attempts, we will have a 93.75% probability of getting a head. thus, four
attempts is the answer.
the matlab / python codes we used to generate figure 1.2 are shown below.
% matlab code to generate a geometric sequence
p = 1/2;
n = 1:10;
x = p.^n;
bar(n,x,’facecolor’,[0.8, 0.2,0.2]);
# python code to generate a geometric sequence
import numpy as np
import matplotlib.pyplot as plt
p = 1/2
n = np.arange(0,10)
x = np.power(p,n)
plt.bar(n,x)
this warm-up exercise has perhaps raised some of your interest in the subject. however,
we will not tell you everything now. we will come back to the probability in chapter 3
when we discuss geometric random variables. in the present section, we want to make sure
you have the basic mathematical tools to calculate quantities, such as a sum of fractional
numbers. for example, what if we want to calculate p[success after 107 attempts]? is there
a systematic way of performing the calculation?
remark . you should be aware that the 93.75% only says that the probability of achieving
the goal is high. if you have a bad day, you may still need more than four attempts. therefore,
when we stated the question, we asked for 90% “on average”. sometimes you may need
more attempts and sometimes fewer attempts, but on average, you have a 93.75% chance
of succeeding.
1.1.1 geometric series
a geometric series is the sum of a finite or an infinite sequence of numbers with a constant
ratio between successive terms. as we have seen in the previous example, a geometric series
3chapter 1. mathematical background
appears naturally in the context of discrete events. in chapter 3 of this book, we will use
geometric series when calculating the expectation andmoments of a random variable.
definition 1.1. let0< r < 1, afinite geometric sequence of power nis a sequence
of numbers
1, r, r2, . . . , rn
.
aninfinite geometric sequence is a sequence of numbers

1, r, r2, r3, . . .
.
theorem 1.1. the sum of a finite geometric series of power nis
nx
k=0rk= 1 + r+r2+···+rn=1−rn+1
1−r. (1.1)
proof . we multiply both sides by 1 −r. the left hand side becomes
 nx
k=0rk!
(1−r) = 
1 +r+r2+···+rn
(1−r)
= 
1 +r+r2+···+rn
− 
r+r2+r3+···+rn+1
(a)= 1−rn+1,
where ( a) holds because terms are canceled due to subtractions.
□
a corollary of equation (1.1) is the sum of an infinite geometric sequence.
corollary 1.1. let0< r < 1. the sum of an infinite geometric series is
∞x
k=0rk= 1 + r+r2+···=1
1−r. (1.2)
proof . we take the limit in equation (1.1). this yields
∞x
k=0rk= lim
n→∞nx
k=0rk= lim
n→∞1−rn+1
1−r=1
1−r.
□
remark . note that the condition 0 < r < 1 is important. if r > 1, then the limit
limn→∞rn+1in equation (1.2) will diverge. the constant rcannot equal to 1, for oth-
erwise the fraction (1 −rn+1)/(1−r) is undefined. we are not interested in the case when
r= 0, because the sum is trivially 1:p∞
k=00k= 1 + 01+ 02+···= 1.
41.1. infinite series
practice exercise 1.1 . compute the infinite series∞p
k=21
2k.
solution .
∞x
k=21
2k=1
4+1
8+···+
=1
4
1 +1
2+1
4+···
=1
4·1
1−1
2=1
2.
remark . you should not be confused about a geometric series and a harmonic series . a
harmonic series concerns with the sum of {1,1
2,1
3,1
4, . . .}. it turns out that1
∞x
n=11
n= 1 +1
2+1
3+1
4+···=∞.
on the other hand, a squared harmonic series {1,1
22,1
32,1
42, . . .}converges:
∞x
n=11
n2= 1 +1
22+1
32+1
42+···=π2
6.
the latter result is known as the basel problem .
we can extend the main theorem by considering more complicated series, for example
the following one.
corollary 1.2. let0< r < 1. it holds that
∞x
k=1krk−1= 1 + 2 r+ 3r2+···=1
(1−r)2. (1.3)
proof . take the derivative on both sides of equation (1.2). the left hand side becomes
d
dr∞x
k=0rk=d
dr 
1 +r+r2+···
= 1 + 2 r+ 3r2+···=∞x
k=1krk−1
the right hand side becomesd
dr1
1−r
=1
(1−r)2.
□
practice exercise 1.2 . compute the infinite sump∞
k=1k·1
3k.
1this result can be found in tom apostol, mathematical analysis , 2nd edition, theorem 8.11.
5chapter 1. mathematical background
solution . we can use the derivative result:
∞x
k=1k·1
3k= 1·1
3+ 2·1
9+ 3·1
27+···
=1
3·
1 + 2·1
3+ 3·1
9+···
=1
3·1
(1−1
3)2=1
3·1
4
9=3
4.
1.1.2 binomial series
a geometric series is useful when handling situations such as n−1 failures followed by
a success. however, we can easily twist the problem by asking: what is the probability
of getting one head out of 3 independent coin tosses? in this case, the probability can be
determined by enumerating all possible cases:
p[1 head in 3 coins] = p[h,t,t] + p[t,h,t] + p[t,t,h]
=1
2×1
2×1
2
+1
2×1
2×1
2
+1
2×1
2×1
2
=3
8.
figure 1.3 illustrates the situation.
figure 1.3: when flipping three coins independently, the probability of getting exactly one head can
come from three different possibilities.
what lessons have we learned in this example? notice that you need to enumerate
all possible combinations of one head and two tails to solve this problem. the number is
3 in our example. in general, the number of combinations can be systematically studied
using combinatorics , which we will discuss later in the chapter. however, the number of
combinations motivates us to discuss another background technique known as the binomial
series. the binomial series is instrumental in algebra when handling polynomials such as
(a+b)2or (1 + x)3. it provides a valuable formula when computing these powers.
theorem 1.2 (binomial theorem ).for any real numbers aandb, the binomial series
of power nis
(a+b)n=nx
k=0n
k
an−kbk, (1.4)
where n
k
=n!
k!(n−k)!.
thebinomial theorem is valid for any real numbers aandb. the quantity n
k
reads
as “nchoose k”. its definition is
n
k
def=n!
k!(n−k)!,
61.1. infinite series
where n! =n(n−1)(n−2)···3·2·1. we shall discuss the physical meaning of n
k
in
section 1.5. but we can quickly plug in the “ nchoose k” into the coin flipping example by
letting n= 3 and k= 1:
number of combinations for 1 head and 2 tails =3
1
=3!
1!2!= 3.
so you can see why we want you to spend your precious time learning about the binomial
theorem. in matlab and python, n
k
can be computed using the commands as follows.
% matlab code to compute (n choose k) and k!
n = 10;
k = 2;
nchoosek(n,k)
factorial(k)
# python code to compute (n choose k) and k!
from scipy.special import comb, factorial
n = 10
k = 2
comb(n, k)
factorial(k)
the binomial theorem makes the most sense when we also learn about the pascal’s
identity .
theorem 1.3 (pascal’s identity ).letnandkbe positive integers such that k≤n.
then,n
k
+n
k−1
=n+ 1
k
. (1.5)
proof . we start by recalling the definition of n
k
. this gives us
n
k
+n
k−1
=n!
k!(n−k)!+n!
(k−1)!(n−(k−1))!
=n!1
k!(n−k)!+1
(k−1)!(n−k+ 1)!
,
where we factor out n! to obtain the second equation. next, we observe that
1
k!(n−k)!×(n−k+ 1)
(n−k+ 1)=n−k+ 1
k!(n−k+ 1)!,
1
(k−1)!(n−k+ 1)!×k
k=k
k!(n−k+ 1)!.
7chapter 1. mathematical background
substituting into the previous equation we obtain
n
k
+n
k−1
=n!n−k+ 1
k!(n−k+ 1)!+k
k!(n−k+ 1)!
=n!n+ 1
k!(n−k+ 1)!
=(n+ 1)!
k!(n+ 1−k)!
=n+ 1
k
.
□
the pascal triangle is a visualization of the coefficients of ( a+b)nas shown in fig-
ure 1.4 . for example, when n= 5, we know that 5
3
= 10. however, by pascal’s identity, we
know that 5
3
= 4
2
+ 4
3
. so the number 10 is actually obtained by summing the numbers
4 and 6 of the previous row.
figure 1.4: pascal triangle for n= 0, . . . , 5. note that a number in one row is obtained by summing
two numbers directly above it.
practice exercise 1.3 . find (1 + x)3.
solution . using the binomial theorem, we can show that
(1 +x)3=nx
k=03
k
13−kxk
= 1 + 3 x+ 3x2+x3.
practice exercise 1.4 . let 0 < p < 1. find
nx
k=0n
k
pn−k(1−p)k.
81.1. infinite series
solution . by using the binomial theorem, we have
nx
k=0n
k
pn−k(1−p)k= (p+ (1−p))n= 1.
this result will be helpful when evaluating binomial random variables in chapter 3.
we now prove the binomial theorem. please feel free to skip the proof if this is your first
time reading the book.
proof of the binomial theorem . we prove by induction. when n= 1,
(a+b)1=a+b
=1x
k=0a1−kbk.
therefore, the base case is verified. assume up to case n. we need to verify case n+ 1.
(a+b)n+1= (a+b)(a+b)n
= (a+b)nx
k=0n
k
an−kbk
=nx
k=0n
k
an−k+1bk+nx
k=0n
k
an−kbk+1.
we want to apply the pascal’s identity to combine the two terms. in order to do so, we note
that the second term in this sum can be rewritten as
nx
k=0n
k
an−kbk+1=nx
k=0n
k
an+1−k−1bk+1
=n+1x
ℓ=1n
ℓ−1
an+1−ℓbℓ, where ℓ=k+ 1
=nx
ℓ=1n
ℓ−1
an+1−ℓbℓ+bn+1.
the first term in the sum can be written as
nx
k=0n
k
an−k+1bk=nx
ℓ=1n
ℓ
an+1−ℓbℓ+an+1, where ℓ=k.
therefore, the two terms can be combined using pascal’s identity to yield
(a+b)n+1=nx
ℓ=1n
ℓ
+n
ℓ−1
an+1−ℓbℓ+an+1+bn+1
=nx
ℓ=1n+ 1
ℓ
an+1−ℓbℓ+an+1+bn+1=n+1x
ℓ=0n+ 1
ℓ
an+1−ℓbℓ.
9chapter 1. mathematical background
hence, the ( n+ 1)th case is also verified. by the principle of mathematical induction, we
have completed the proof.
□
the end of the proof. please join us again.
1.2 approximation
consider a function f(x) = log(1 + x), for x >0 as shown in figure 1.5 . this is a nonlinear
function, and we all know that nonlinear functions are not fun to deal with. for example,
if you want to integrate the functionrb
axlog(1 + x)dx, then the logarithm will force you
to do integration by parts. however, in many practical problems, you may not need the full
range of x >0. suppose that you are only interested in values x≪1. then the logarithm
can be approximated, and thus the integral can also be approximated.
0 1 2 3 4 500.511.52
0 0.05 0.1 0.15 0.200.050.10.150.2
figure 1.5: the function f(x) = log(1 + x)and the approximation bf(x) =x.
to see how this is even possible, we show in figure 1.5 the nonlinear function f(x) =
log(1 + x) and an approximation bf(x) =x. the approximation is carefully chosen such that
forx≪1, the approximation bf(x) is close to the true function f(x). therefore, we can
argue that for x≪1,
log(1 + x)≈x, (1.6)
thereby simplifying the calculation. for example, if you want to integrate xlog(1 + x) for
0< x < 0.1, then the integral can be approximated byr0.1
0xlog(1 + x)dx≈r0.1
0x2dx=
x3
3= 3.33×10−4. (the actual integral is 3 .21×10−4.) in this section we will learn about
the basic approximation techniques. we will use them when we discuss limit theorems in
chapter 6, as well as various distributions, such as from binomial to poisson.
101.2. approximation
1.2.1 taylor approximation
given a function f:r→r, it is often useful to analyze its behavior by approximating f
using its local information. taylor approximation (or taylor series) is one of the tools for
such a task. we will use the taylor approximation on many occasions.
definition 1.2 (taylor approximation ).letf:r→rbe a continuous function with
infinite derivatives. let a∈rbe a fixed constant. the taylor approximation of fat
x=ais
f(x) =f(a) +f′(a)(x−a) +f′′(a)
2!(x−a)2+···
=∞x
n=0f(n)(a)
n!(x−a)n, (1.7)
where f(n)denotes the nth-order derivative of f.
taylor approximation is a geometry-based approximation. it approximates the function
according to the offset, slope, curvature, and so on. according to definition 1.2, the taylor
series has an infinite number of terms. if we use a finite number of terms, we obtain the
nth-order taylor approximation:
first-order : f(x) =f(a)|{z}
offset+f′(a)(x−a)|{z}
slope+o((x−a)2)
second-order : f(x) =f(a)|{z}
offset+f′(a)(x−a)|{z}
slope+f′′(a)
2!(x−a)2
|{z }
curvature+o((x−a)3).
here, the big-o notation o(εk) means any term that has an order at least power k. for
small ε, i.e., ε≪1, a high-order term o(εk)≈0 for large k.
example 1.1 . let f(x) = sin x. then the taylor approximation at x= 0 is
f(x)≈f(0) + f′(0)(x−0) +f′′(0)
2!(x−0)2+f′′′(0)
3!(x−0)3
= sin(0) + (cos 0)( x−0)−sin(0)
2!(x−0)2−cos(0)
3!(x−0)3
= 0 + x−0−x3
6=x−x3
6.
we can expand further to higher orders, which yields
f(x) =x−x3
3!+x5
5!−x7
7!+···
we show the first few approximations in figure 1.6 .
one should be reminded that taylor approximation approximates a function f(x)
at a particular point x=a. therefore, the approximation of fnear x= 0 and the
11chapter 1. mathematical background
approximation of fnearx=π/2 are different. for example, the taylor approximation
atx=π/2 for f(x) = sin xis
f(x) = sinπ
2+ cosπ
2
x−π
2
−sinπ
2
2!
x−π
22
−cosπ
2
3!
x−π
23
= 1 + 0 −1
4
x−π
22
−0 = 1−1
4
x−π
22
.
-10 -5 0 5 10
x-4-2024
sin x
3rd order
5th order
7th order
-10 -5 0 5 10
x-4-2024
sin x
3rd order
5th order
7th order
(a) approximate at x= 0 (b) approximate at x=π/2
figure 1.6: taylor approximation of the function f(x) = sin x.
1.2.2 exponential series
an immediate application of the taylor approximation is to derive the exponential series .
theorem 1.4. letxbe any real number. then,
ex= 1 + x+x2
2+x3
3!+···=∞x
k=0xk
k!. (1.8)
proof . let f(x) =exfor any x. then, the taylor approximation around x= 0 is
f(x) =f(0) + f′(0)(x−0) +f′′(0)
2!(x−0)2+···
=e0+e0(x−0) +e0
2!(x−0)2+···
= 1 + x+x2
2+···=∞x
k=0xk
k!.
□
practice exercise 1.5 . evaluate∞x
k=0λke−λ
k!.
121.2. approximation
solution .∞x
k=0λke−λ
k!=e−λ∞x
k=0λk
k!=e−λeλ= 1.
this result will be useful for poisson random variables in chapter 3.
if we substitute x=jθwhere j=√−1, then we can show that
ejθ
|{z}
=cos θ+jsinθ= 1 + jθ+(jθ)2
2!+···
=
1−θ2
2!+θ4
4!+···
| {z }
real+j
θ−θ3
3!+···
| {z }
imaginary
matching the real and the imaginary terms, we can show that
cosθ= 1−θ2
2!+θ4
4!+···
sinθ=θ−θ3
3!+θ5
5!+···
this gives the infinite series representations of the two trigonometric functions.
1.2.3 logarithmic approximation
taylor approximation also allows us to find approximations to logarithmic functions. we
start by presenting a lemma.
lemma 1.1. let0< x < 1be a constant. then,
log(1 + x) =x−x2+o(x3). (1.9)
proof . let f(x) = log(1 + x). then, the derivatives of fare
f′(x) =1
(1 +x),and f′′(x) =−1
(1 +x)2.
taylor approximation at x= 0 gives
f(x) =f(0) + f′(0)(x−0) +f′′(0)
2(x−0)2+o(x3)
= log 1 +1
(1 + 0)
x−1
(1 + 0)2
x2+o(x3)
=x−x2+o(x3).
□
the difference between this result and the result we showed in the beginning of this
section is the order of polynomials we used to approximate the logarithm:
13chapter 1. mathematical background
first-order: log(1 + x) =x
second-order: log(1 + x) =x−x2.
what order of approximation is good? it depends on where you want the approximation to
be good, and how faryou want the approximation to go. the difference between first-order
and second-order approximations is shown in figure 1.7 .
0 1 2 3 4 500.511.52
0 1 2 3 4 500.511.52
first-order approximation second-order approximation
figure 1.7: the function f(x) = log(1 + x), the first-order approximation bf(x) =x, and the second-
order approximation bf(x) =x−x2.
example 1.2 . when we prove the central limit theorem in chapter 6, we need to
use the following result.
lim
n→∞
1 +s2
2nn
=es2/2.
the proof of this equation can be done using the taylor approximation. consider
nlog
1 +s2
n
. by the logarithmic lemma, we can obtain the second-order approxi-
mation:
log
1 +s2
2n
=s2
2n−s4
4n2.
therefore, multiplying both sides by nyields
nlog
1 +s2
2n
=s2
2−s4
4n.
putting the limit n→ ∞ we can show that
lim
n→∞
nlog
1 +s2
2n
=s2
2.
taking exponential on both sides yields
exp
lim
n→∞nlog
1 +s2
2n
= exps2
2
.
moving the limit outside the exponential yields the result. figure 1.8 provides a pic-
torial illustration.
141.3. integration
0 0.2 0.4 0.6 0.8 111.21.41.61.8
figure 1.8: we plot a sequence of function fn(x) =
1 +s2
2nn
and its limit f(x) =es2/2.
1.3 integration
when you learned calculus, your teacher probably told you that there are two ways to
compute an integral:
substitution : z
f(ax)dx=1
az
f(u)du.
by parts : z
u dv =u v−z
v du.
besides these two, we want to teach you two more. the first technique is even and odd
functions when integrating a function symmetrically about the y-axis. if a function is even,
you just need to integrate half of the function. if a function is odd, you will get a zero. the
second technique is to leverage the fact that a probability density function integrates to 1.
we will discuss the first technique here and defer the second technique to chapter 4.
besides the two integration techniques, we will review the fundamental theorem of
calculus. we will need it when we study cumulative distribution functions in chapter 4.
1.3.1 odd and even functions
definition 1.3. a function f:r→riseven if for any x∈r,
f(x) =f(−x), (1.10)
andfisoddif
f(x) =−f(−x). (1.11)
15chapter 1. mathematical background
essentially, an even function flips over about the y-axis, whereas an odd function flips over
both the x- and y-axes.
example 1.3 . the function f(x) =x2−0.4x4is even, because
f(−x) = (−x)2−0.4(−x)4=x2−0.4x4=f(x).
seefigure 1.9 (a) for illustration. when integrating the function, we have
z1
−1f(x)dx= 2z1
0f(x)dx= 2z1
0x2−0.44dx= 2x3
3−0.4
5x5x=1
x=0=38
75.
example 1.4 . the function f(x) =xexp(−x2/2) is odd, because
f(−x) = (−x) exp
−(−x)2
2
=−xexp
−x2
2
=−f(x).
seefigure 1.9 (b) for illustration. when integrating the function, we can let u=−x.
then, the integral becomes
z1
−1f(x)dx=z0
−1f(x)dx+z1
0f(x)dx
=z1
0f(−u)du+z1
0f(x)dx
=−z1
0f(u)du+z1
0f(x)dx= 0.
-1.5 -1 -0.5 0 0.5 1 1.5
x-1-0.500.51
-1.5 -1 -0.5 0 0.5 1 1.5
x-1-0.500.51
(a) even function (b) odd function
figure 1.9: an even function is symmetric about the y-axis, and so the integrationra
−af(x)dx=
2ra
0f(x)dx. an odd function is anti-symmetric about the y-axis. thus,ra
−af(x)dx= 0.
161.3. integration
1.3.2 fundamental theorem of calculus
our following result is the fundamental theorem of calculus . it is a handy tool that links
integration and differentiation.
theorem 1.5 (fundamental theorem of calculus ).letf: [a, b]→rbe a continu-
ous function defined on a closed interval [a, b]. then, for any x∈(a, b),
f(x) =d
dxzx
af(t)dt, (1.12)
before we prove the result, let us understand the theorem if you have forgotten its meaning.
example 1.5 . consider a function f(t) =t2. if we integrate the function from 0 to
x, we will obtain another function
f(x)def=zx
0f(t)dt=zx
0t2dt=x3
3.
on the other hand, we can differentiate f(x) to obtain f(x):
f(x) =d
dxf(x) =d
dxx3
3=x2.
the fundamental theorem of calculus basically puts the two together:
f(x) =d
dxzx
0f(t)dt.
that’s it. nothing more and nothing less.
how can the fundamental theorem of calculus ever be useful when studying probabil-
ity? very soon you will learn two concepts: probability density function andcumulative
distribution function . these two functions are related to each other by the fundamental
theorem of calculus. to give you a concrete example, we write down the probability density
function of an exponential random variable. (please do not panic about the exponential
random variable. just think of it as a “rapidly decaying” function.)
f(x) =e−x, x≥0.
it turns out that the cumulative distribution function is
f(x) =zx
0f(t)dt=zx
0e−tdt= 1−e−x.
you can also check that f(x) =d
dxf(x). the fundamental theorem of calculus says that if
you tell me f(x) =rx
0e−tdt(for whatever reason), i will be able to tell you that f(x) =e−x
merely by visually inspecting the integrand without doing the differentiation.
figure 1.10 illustrates the pair of functions f(x) =e−xandf(x) = 1−e−x. one thing
you should notice is that the height off(x) is the area under the curve of f(t) from −∞tox.
for example, in figure 1.10 we show the area under the curve from 0 to 2. correspondingly
inf(x), the height is f(2).
17chapter 1. mathematical background
0 1 2 3 4 500.20.40.60.81
0 1 2 3 4 500.20.40.60.81
f(x) f(x)
figure 1.10: the pair of functions f(x) =e−xandf(x) = 1−e−x
the following proof of the fundamental theorem of calculus can be skipped if it is your
first time reading the book.
proof . our proof is based on stewart (6th edition), section 5.3. define the integral as a
function f:
f(x) =zx
af(t)dt.
the derivative of fwith respect to xis
d
dxf(x) = lim
h→0f(x+h)−f(x)
h
= lim
h→01
h zx+h
af(t)dt−zx
af(t)dt!
= lim
h→01
hzx+h
xf(t)dt
(a)
≤lim
h→01
hzx+h
x
max
x≤τ≤x+hf(τ)
dt
= lim
h→0
max
x≤τ≤x+hf(τ)
.
here, the inequality in ( a) holds because
f(t)≤max
x≤τ≤x+hf(τ)
for all x≤t≤x+h. the maximum exists because fis continuous in a closed interval.
181.3. integration
using the parallel argument, we can show that
d
dxf(x) = lim
h→0f(x+h)−f(x)
h
= lim
h→01
h zx+h
af(t)dt−zx
af(t)dt!
= lim
h→01
hzx+h
xf(t)dt
≥lim
h→01
hzx+h
x
min
x≤τ≤x+hf(τ)
dt
= lim
h→0
min
x≤τ≤x+hf(τ)
.
combining the two results, we have that
lim
h→0
min
x≤τ≤x+hf(τ)
≤d
dxf(x)≤lim
h→0
max
x≤τ≤x+hf(τ)
.
however, since the two limits are both converging to f(x) as h→0, we conclude that
d
dxf(x) =f(x).
□
remark . an alternative proof is to use mean value theorem in terms of riemann-stieltjes
integrals (see, e.g., tom apostol, mathematical analysis , 2nd edition, theorem 7.34). to
handle more general functions such as delta functions, one can use techniques in lebesgue’s
integration. however, this is beyond the scope of this book.
this is the end of the proof. please join us again.
in many practical problems, the fundamental theorem of calculus needs to be used in
conjunction with the chain rule .
corollary 1.3. letf: [a, b]→rbe a continuous function defined on a closed interval
[a, b]. let g:r→[a, b]be a continuously differentiable function. then, for any x∈
(a, b),
d
dxzg(x)
af(t)dt=g′(x)·f(g(x)). (1.13)
proof . we can prove this with the chain rule: let y=g(x). then we have
d
dxzg(x)
af(t)dt=dy
dx·d
dyzy
af(t)dt=g′(x)f(y),
which completes the proof.
□
19chapter 1. mathematical background
practice exercise 1.6 . evaluate the integral
d
dxzx−µ
01√
2πσ2exp
−t2
2σ2
dt.
solution . let y=x−µ. then by using the fundamental theorem of calculus, we can
show that
d
dxzx−µ
01√
2πσ2exp
−t2
2σ2
dt=dy
dx·d
dyzy
01√
2πσ2exp
−t2
2σ2
dt
=d(x−µ)
dx·1√
2πσ2exp
−y2
2σ2
=1√
2πσ2exp
−(x−µ)2
2σ2
.
this result will be useful when we do linear transformations of a gaussian random
variable in chapter 4.
1.4 linear algebra
the two most important subjects for data science are probability , which is the subject of the
book you are reading, and linear algebra , which concerns matrices and vectors. we cannot
cover linear algebra in detail because this would require another book. however, we need to
highlight some ideas that are important for doing data analysis.
1.4.1 why do we need linear algebra in data science?
consider a dataset of the crime rate of several cities as shown below, downloaded from
https://web.stanford.edu/ ~hastie/statlearnsparsity/data.html .
the table shows that the crime rate depends on several factors such as funding for the
police department, the percentage of high school graduates, etc.
city crime rate funding hs no-hs college college4
1 478 40 74 11 31 20
2 494 32 72 11 43 18
3 643 57 71 18 16 16
4 341 31 71 11 25 19
.....................
50 940 66 67 26 18 16
201.4. linear algebra
what questions can we ask about this table? we can ask: what is the most influential
cause of the crime rate? what are the leading contributions to the crime rate? to answer
these questions, we need to describe these numbers. one way to do it is to put the numbers
in matrices and vectors. for example,
ycrime =
478
494
...
940
,xfund=
40
32
...
66
,xhs=
74
72
...
67
, . . .
with this vector expression of the data, the analysis questions can roughly be translated
to finding β’s in the following equation:
ycrime =βfundxfund+βhsxhs+···+βcollege4 xcollege4 .
this equation offers a lot of useful insights. first, it is a linear model ofycrime. we call
it a linear model because the observable ycrime is written as a linear combination of the
variables xfund,xhs, etc. the linear model assumes that the variables are scaled and added
to generate the observed phenomena. this assumption is not always realistic, but it is often
a fair assumption that greatly simplifies the problem. for example, if we can show that all
β’s are zero except βfund, then we can conclude that the crime rate is solely dependent on
the police funding. if two variables are correlated, e.g., high school graduate and college
graduate, we would expect the β’s to change simultaneously.
the linear model can further be simplified to a matrix-vector equation:

|
|
ycrime
|
|
=
| | |
| | |
xfund xhs···xcollege4
| | |
| | |

βfund
βhs
...
βcollege4

here, the lines “ |” emphasize that the vectors are column vectors. if we denote the matrix
in the middle as aand the vector as β, then the equation is equivalent to y=aβ. so we
can find βby appropriately inverting the matrix a. if two columns of aare dependent, we
will not be able to resolve the corresponding β’s uniquely.
as you can see from the above data analysis problem, matrices and vectors offer a way
to describe the data. we will discuss the calculations in chapter 7. however, to understand
how to interpret the results from the matrix-vector equations, we need to review some basic
ideas about matrices and vectors.
1.4.2 everything you need to know about linear algebra
throughout this book, you will see different sets of notations. for linear algebra, we also
have a set of notations. we denote x∈rdad-dimensional vector taking real numbers as its
entries. an m-by-nmatrix is denoted as x∈rm×n. the transpose of a matrix is denoted
asxt. a matrix xcan be viewed according to its columns and its rows:
x=
| | |
x1x2···xn
| | |
,and x=
—x1—
—x2—
...
—xm—
.
21chapter 1. mathematical background
here, xjdenotes the jth column of x, andxidenotes the ith row of x. the ( i, j)th element
ofxis denoted as xijor [x]ij. the identity matrix is denoted as i. the ith column of i
is denoted as ei= [0, . . . , 1, . . . , 0]t, and is called the ithstandard basis vector . an all-zero
vector is denoted as 0= [0, . . . , 0]t.
what is the most important thing to know about linear algebra? from a data analysis
point of view, figure 1.11 gives us the answer. the picture is straightforward, but it captures
all the essence. in almost all the data analysis problems, ultimately, there are three things we
care about: (i) the observable vector y, (ii) the variable vectors xn, and (iii) the coefficients
βn. the set of variable vectors {xn}n
n=1spans a vector space in which all vectors are living.
some of these variable vectors are correlated, and some are not. however, for the sake of
this discussion, let us assume they are independent of each other. then for any observable
vector y, we can always project yin the directions determined by {xn}n
n=1. the projection
ofyontoxnis the coefficient βn. a larger value of βnmeans that the variable xnhas more
contributions.
figure 1.11: representing an observable vector yby a linear combination of variable vectors x1,x2
andx3. the combination weights are β1, β2, β3.
why is this picture so important? because most of the data analysis problems can be
expressed, or approximately expressed, by the picture:
y=nx
n=1βnxn.
if you recall the crime rate example, this equation is precisely the linear model we used to
describe the crime rate. this equation can also describe many other problems.
example 1.6 .polynomial fitting . consider a dataset of pairs of numbers ( tm, ym) for
m= 1, . . . , m , as shown in figure 1.12 . after a visual inspection of the dataset, we
propose to use a line to fit the data. a line is specified by the equation
ym=atm+b, m = 1, . . . , m,
where a∈ris the slope and b∈ris the y-intercept. the goal of this problem is to
find one line (which is fully characterized by ( a, b)) such that it has the best fit to all
the data pairs ( tm, ym) for m= 1, . . . , m . this problem can be described in matrices
221.4. linear algebra
and vectors by noting that

y1
...
ym

|{z}
y=a|{z}
β1
t1
...
tm

|{z}
x1+b|{z}
β2
1
...
1

|{z}
x2,
or more compactly,
y=β1x1+β2x2.
here, x1= [t1, . . . , t m]tcontains all the variable values, and x2= [1, . . . , 1]tcontains
a constant offset.
tm ym
0.1622 2.1227
0.7943 3.3354
......
0.7379 3.4054
0.2691 2.5672
0.4228 2.3796
0.6020 3.2942
0 0.2 0.4 0.6 0.8 112345
data
best fit
candidate
figure 1.12: example of fitting a set of data points. the problem can be described by y=
β1x1+β2x2.
example 1.7 .image compression . the jpeg compression for images is based on
the concept of discrete cosine transform (dct). the dct consists of a set of basis
vectors , or{xn}n
n=1using our notation. in the most standard setting, each basis vector
xnconsists of 8 ×8 pixels, and there are n= 64 of these xn’s. given an image, we can
partition the image into msmall blocks of 8 ×8 pixels. let us call one of these blocks
y. then, dct represents the observation yas a linear combination of the dct basis
vectors:
y=nx
n=1βnxn.
the coefficients {βn}n
n=1are called the dct coefficients. they provide a representa-
tionofy, because once we know {βn}n
n=1, we can completely describe ybecause the
basis vectors {xn}n
n=1are known and fixed. the situation is depicted in figure 1.13 .
how can we compress images using dct? in the 1970s, scientists found that most
images have strong leading dct coefficients but weak tail dct coefficients. in other
words, among the n= 64 βn’s, only the first few are important. if we truncate the
number of dct coefficients, we can effectively compress the number of bits required
to represent the image.
23chapter 1. mathematical background
figure 1.13: jpeg image compression is based on the concept of discrete cosine transform, which
can be formulated as a matrix-vector problem.
we hope by now you are convinced of the importance of matrices and vectors in the
context of data science. they are not “yet another” subject but an essential tool you must
know how to use. so, what are the technical materials you must master? here we go.
1.4.3 inner products and norms
we assume that you know the basic operations such as matrix-vector multiplication, taking
the transpose, etc. if you have forgotten these, please consult any undergraduate linear
algebra textbook such as gilbert strang’s linear algebra and its applications . we will
highlight a few of the most important operations for our purposes.
definition 1.4 (inner product ).letx= [x1, . . . , x n]t, and y= [y1, . . . , y n]t. the
inner product xtyis
xty=nx
i=1xiyi. (1.14)
practice exercise 1.7 . letx= [1,0,−1]t, and y= [3,2,0]t. find xty.
solution . the inner product is xty= (1)(3) + (0)(2) + ( −1)(0) = 3.
inner products are important because they tell us how two vectors are correlated.
figure 1.14 depicts the geometric meaning of an inner product. if two vectors are correlated
(i.e., nearly parallel), then the inner product will give us a large value. conversely, if the
two vectors are close to perpendicular, then the inner product will be small. therefore, the
inner product provides a measure of the closeness/similarity between two vectors.
figure 1.14: geometric interpretation of inner product: we project one vector onto the other vector.
the projected distance is the inner product.
241.4. linear algebra
creating vectors and computing the inner products are straightforward in matlab.
we simply need to define the column vectors xandyby using the command []with ;to
denote the next row. the inner product is done using the transpose operation x’and vector
multiplication *.
% matlab code to perform an inner product
x = [1 0 -1];
y = [3 2 0];
z = x’*y;
in python, constructing a vector is done using the command np.array . inside this
command, one needs to enter the array. for a column vector, we write [[1],[2],[3]] , with
an outer [], and three inner []for each entry. if the vector is a row vector, the one can omit
the inner []’s by just calling np.array([1, 2, 3]) . given two column vectors xand y,
the inner product is computed via np.dot(x.t,y) , where np.dot is the command for inner
product, and x.treturns the transpose of x. one can also call np.transpose(x) , which is
the same as x.t.
# python code to perform an inner product
import numpy as np
x = np.array([[1],[0],[-1]])
y = np.array([[3],[2],[0]])
z = np.dot(np.transpose(x),y)
print(z)
in data analytics, the inner product of two vectors can be useful. consider the vectors
intable 1.1 . just from looking at the numbers, you probably will not see anything wrong.
however, let’s compute the inner products. it turns out that xt
1x2=−0.0031, whereas
xt
1x3= 2.0020. there is almost no correlation between x1andx2, but there is a substan-
tial correlation between x1andx3. what happened? the vectors x1andx2are random
vectors constructed independently and uncorrelated to each other. the last vector x3was
constructed by x3= 2x1−π/1000. since x3is completely constructed from x1, they have
to be correlated.
x1 x2 x3
0.0006 −0.0011 −0.0020
−0.0014 −0.0024 −0.0059
−0.0034 0 .0073 −0.0099
.........
0.0001 −0.0066 −0.0030
0.0074 0 .0046 0 .0116
0.0007 −0.0061 −0.0017
table 1.1: three example vectors.
one caveat for this example is that the naive inner product xt
ixjis scale-dependent.
for example, the vectors x3=x1andx3= 1000 x1have the same amount of correlation,
25chapter 1. mathematical background
but the simple inner product will give a larger value for the latter case. to solve this problem
we first define the norm of the vectors:
definition 1.5 (norm ).letx= [x1, . . . , x n]tbe a vector. the ℓp-norm of xis
∥x∥p= nx
i=1xp
i!1/p
, (1.15)
for any p≥1.
the norm essentially tells us the length of the vector. this is most obvious if we consider
theℓ2-norm:
∥x∥2= nx
i=1x2
i!1/2
.
by taking the square on both sides, one can show that ∥x∥2
2=xtx. this is called the
squared ℓ2-norm , and is the sum of the squares.
on matlab, computing the norm is done using the command norm. here, we can
indicate the types of norms, e.g., norm(x,1) returns the ℓ1-norm whereas norm(x,2) returns
theℓ2-norm (which is also the default).
% matlab code to compute the norm
x = [1 0 -1];
x_norm = norm(x);
on python, the norm command is listed in the np.linalg . to call the ℓ1-norm, we use
np.linalg.norm(x,1) , and by default the ℓ2-norm is np.linalg.norm(x) .
# python code to compute the norm
import numpy as np
x = np.array([[1],[0],[-1]])
x_norm = np.linalg.norm(x)
using the norm, one can define an angle called the cosine angle between two vectors.
definition 1.6. thecosine angle between two vectors xandyis
cosθ=xty
∥x∥2∥y∥2. (1.16)
the difference between the cosine angle and the basic inner product is the normaliza-
tion in the denominator, which is the product ∥x∥2∥y∥2. this normalization factor scales
the vector xtox/∥x∥2andytoy/∥y∥2. the scaling makes the length of the new vector
equal to unity, but it does not change the vector’s orientation. therefore, the cosine angle
is not affected by a very long vector or a very short vector. only the angle matters. see
figure 1.15 .
261.4. linear algebra
figure 1.15: the cosine angle is the inner product divided by the norms of the vectors.
going back to the previous example, after normalization we can show that the cosine
angle between x1andx2is cos θ1,2=−0.0031, whereas the cosine angle between x1and
x3is cos θ1,3= 0.8958. there is still a strong correlation between x1andx3, but now using
the cosine angle the value is between −1 and +1.
remark 1 : there are other norms one can use. the ℓ1-norm is useful for sparse models
where we want to have the fewest possible non-zeros. the ℓ1-norm of xis
∥x∥1=nx
i=1|xi|,
which is the sum of absolute values. the ℓ∞-norm picks the maximum of {x1, . . . , x n}:
∥x∥∞= lim
p→∞ nx
i=1xp
i!1/p
= max {x1, . . . , x n},
because as p→ ∞ , only the largest element will be amplified.
remark 2 : the standard ℓ2-norm is a circle: just consider x= [x1, x2]t. the norm
is∥x∥2=p
x2
1+x2
2. we can convert the circle to ellipses by considering a weighted norm.
definition 1.7 (weighted ℓ2-norm square ).letx= [x1, . . . , x n]tand let w=
diag(w1, . . . , w n)be a non-negative diagonal matrix. the weighted ℓ2-norm square of
xis
∥x∥2
w=xtwx
=x1. . . x n
w1. . . 0
.........
0. . . w n

x1
...
xn
=nx
i=1wix2
i. (1.17)
the geometry of the weighted ℓ2-norm is determined by the matrix w. for example,
ifw=i(the identity operator), then ∥x∥2
w=∥x∥2
2, which defines a circle. if wis any
“non-negative” matrix2, then ∥x∥2
wdefines an ellipse.
2the technical term for these matrices is positive semi-definite matrices.
27chapter 1. mathematical background
in matlab, the weighted inner product is just a sequence of two matrix-vector mul-
tiplications. this can be done using the command x’*w*x as shown below.
% matlab code to compute the weighted norm
w = [1 2 3; 4 5 6; 7 8 9];
x = [2; -1; 1];
z = x’*w*x
in python, constructing the matrix wand the column vector xis done using np.array .
the matrix-vector multiplication is done using two np.dot commands: one for np.dot(w,x)
and the other one for np.dot(x.t, np.dot(w,x)) .
# python code to compute the weighted norm
import numpy as np
w = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
x = np.array([[2],[-1],[1]])
z = np.dot(x.t, np.dot(w,x))
print(z)
1.4.4 matrix calculus
the last linear algebra topic we need to review is matrix calculus. as its name indicates,
matrix calculus is about the differentiation of matrices and vectors. why do we need differ-
entiation for matrices and vectors? because we want to find the minimum or maximum of
a scalar function with a vector input.
let us go back to the crime rate problem we discussed earlier. given the data, we
want to find the model coefficients β1, . . . , β nsuch that the variables can best explain the
observation. in other words, we want to minimize the deviation between yand the prediction
offered by our model:
minimize
β1,...,β ny−nx
n=1βnxn2
.
this equation is self-explanatory. the norm ∥♣ − ♡∥2measures the deviation. if ycan
be perfectly explained by {xn}n
n=1, then the norm can eventually go to zero by finding a
good set of {β1, . . . , β n}. the symbol minimize
β1,...,β nmeans to minimize the function by finding
{β1, . . . , β n}. note that the norm is taking a vector as the input and generating a scalar as
the output. it can be expressed as
ε(β)def=y−nx
n=1βnxn2
,
to emphasize this relationship. here we define β= [β1, . . . , β n]tas the collection of all
coefficients.
given this setup, how would you determine βsuch that the deviation is minimized?
our calculus teachers told us that we could take the function’s derivative and set it to zero
281.4. linear algebra
for scalar problems. it is the same story for vectors. what we do is to take the derivative of
the error and set it equal to zero:
d
dβε(β) = 0 .
now the question arises, how do we take the derivatives of ε(β) when it takes a vector as
input? if we can answer this question, we will find the best β. the answer is straightforward.
since the function has one output and many inputs, take the derivative for each element
independently. this is called the scalar differentiation of vectors .
definition 1.8 (scalar differentiation of vectors ).letf:rn→rbe a differentiable
scalar function, and let y=f(x)for some input x∈rn. then,
dy
dx=
dy/dx 1
...
dy/dx n
.
as you can see from this definition, there is nothing conceptually challenging here. the only
difficulty is that things can get tedious because there will be many terms. however, the good
news is that mathematicians have already compiled a list of identities for common matrix
differentiation. so instead of deriving every equation from scratch, we can enjoy the fruit of
their hard work by referring to those formulae. the best place to find these equations is the
matrix cookbook by petersen and pedersen.3here, we will mention two of the most useful
results.
example 1.8 . let y=xtaxfor any matrix a∈rn×n. finddy
dx.
solution .d
dx 
xtax
=ax+atx.
now, if ais symmetric, i.e., a=at, then
d
dx 
xtax
= 2ax.
example 1.9 . let ε=∥ax−y∥2
2, where a∈rn×nis symmetric. finddε
dx.
solution . first, we note that
ε=∥ax−y∥2
2=xtatax−2ytax+yty.
3https://www.math.uwaterloo.ca/ ~hwolkowi/matrixcookbook.pdf
29chapter 1. mathematical background
taking the derivative with respect to xyields
dε
dx= 2atax−2aty
= 2at(ax−y).
going back to the crime rate problem, we can now show that
0 =dε
dβ∥y−xβ∥2= 2xt(xβ−y).
therefore, the solution is
bβ= (xtx)−1xy.
as you can see, if we do not have access to the matrix calculus, we will not be able to solve the
minimization problem. (there are alternative paths that do not require matrix calculus, but
they require an understanding of linear subspaces and properties of the projection operators.
so in some sense, matrix calculus is the easiest way to solve the problem.) when we discuss
the linear regression methods in chapter 7, we will cover the interpretation of the inverses
and related topics.
in matlab and python, matrix inversion is done using the command invin mat-
lab and np.linalg.inv in python. below is an example in python.
# python code to compute a matrix inverse
import numpy as np
x = np.array([[1, 3], [-2, 7], [0, 1]])
xtx = np.dot(x.t, x)
xtxinv = np.linalg.inv(xtx)
print(xtxinv)
sometimes, instead of computing the matrix inverse we are more interested in solving a
linear equation xβ=y(the solution of which is bβ= (xtx)−1xy). in both matlab and
python, there are built-in commands to do this. in matlab, the command is \(backslash).
% matlab code to solve x beta = y
x = [1 3; -2 7; 0 1];
y = [2; 1; 0];
beta = x\y;
in python, the built-in command is np.linalg.lstsq .
# python code to solve x beta = y
import numpy as np
x = np.array([[1, 3], [-2, 7], [0, 1]])
y = np.array([[2],[1],[0]])
beta = np.linalg.lstsq(x, y, rcond=none)[0]
print(beta)
301.5. basic combinatorics
closing remark : in this section, we have given a brief introduction to a few of the most
relevant concepts in linear algebra. we will introduce further concepts in linear algebra in
later chapters, such as eigenvalues, principal component analysis, linear transformations,
and regularization, as they become useful for our discussion.
1.5 basic combinatorics
the last topic we review in this chapter is combinatorics . combinatorics concerns the
number of configurations that can be obtained from certain discrete experiments. it is useful
because it provides a systematic way of enumerating cases. combinatorics often becomes
very challenging as the complexity of the event grows. however, you may rest assured that
in this book, we will not tackle the more difficult problems of combinatorics; we will confine
our discussion to two of the most basic principles: permutation andcombination .
1.5.1 birthday paradox
to motivate the discussion of combinatorics, let us start with the following problem. suppose
there are 50 people in a room. what is the probability that at least one pair of people have
the same birthday (month and day)? (we exclude feb. 29 in this problem.)
the first thing you might be thinking is that since there are 365 days, we need at least
366 people to ensure that one pair has the same birthday. therefore, the chance that 2 of
50 people have the same birthday is low. this seems reasonable, but let’s do a simulated
experiment. in figure 1.16 we plot the probability as a function of the number of people.
for a room containing 50 people, the probability is 97%. to get a 50% probability, we just
need 23 people! how is this possible?
0 10 20 30 40 50 60 70 80 90 100
number of people00.10.20.30.40.50.60.70.80.91probability
figure 1.16: the probability for two people in a group to have the same birthday as a function of the
number of people in the group.
if you think about this problem more deeply, you will probably realize that to solve the
problem, we must carefully enumerate all the possible configurations. how can we do this?
well, suppose you walk into the room and sequentially pick two people. the probability
31chapter 1. mathematical background
that they have different birthdays is
p[the first 2 people have different birthdays] =365
365×364
365.
when you ask the first person to tell you their birthday, he or she can occupy any of the
365 slots. this gives us365
365. the second person has one slot short because the first person
has taken it, and so the probability that he or she has a different birthday from the first
person is364
365. note that this calculation is independent of how many people you have in the
room because you are picking them sequentially.
if you now choose a third person, the probability that they have different birthdays is
p[the first 3 people have different birthdays] =365
365×364
365×363
365.
this process can be visualized in figure 1.17 .
figure 1.17: the probability for two people to have the same birthday as a function of the number of
people in the group. when there is only one person, this person can land on any of the 365 days. when
there are two people, the first person has already taken one day (out of 365 days), so the second person
can only choose 364 days. when there are three people, the first two people have occupied two days,
so there are only 363 days left. if we generalize this process, we see that the number of configurations
is365×364× ··· × (365−k+ 1), where kis the number of people in the room.
so imagine that you keep going down the list to the 50th person. the probability that
none of these 50 people will have the same birthday is
p[the first 50 people have different birthdays]
=365
365×364
365×363
365× ··· ×316
365≈0.03.
that means that the probability for 50 people to have different birthdays, the probability is
as little as 3%. if you take the complement, you can show that with 97% probability, there
is at least one pair of people having the same birthday.
the general equation for this problem is now easy to see:
p[the first kpeople have different birthdays] =365×364× ··· × (365−k+ 1)
365×365× ··· × 365
=365!
(365−k)!×1
365k.
321.5. basic combinatorics
the first term in our equation,365!
(365−k)!, is called the permutation of picking kdays from
365 options. we shall discuss this operation shortly.
why is the probability so high with only 50 people while it seems that we need 366
people to ensure two identical birthdays? the difference is the notion of probabilistic and
deterministic . the 366-people argument is deterministic. if you have 366 people, you are
certain that two people will have the same birthday. this has no conflict with the proba-
bilistic argument because the probabilistic argument says that with 50 people, we have a
97% chance of getting two identical birthdays. with a 97% success rate, you still have a
3% chance of failing. it is unlikely to happen, but it can still happen. the more people you
put into the room, the stronger guarantee you will have. however, even if you have 364
people and the probability is almost 100%, there is still no guarantee. so there is no conflict
between the two arguments since they are answering two different questions.
now, let’s discuss the two combinatorics questions.
1.5.2 permutation
permutation concerns the following question:
consider a set of ndistinct balls. suppose we want to pick kballs from the set without
replacement. how many ordered configurations can we obtain?
note that in the above question, the word “ordered” is crucial. for example, the set
a={a, b, c}can lead to 6 different ordered configurations
(a, b, c ),(a, c, b ),(b, a, c ),(b, c, a ),(c, a, b ),(c, b, a ).
as a simple illustration of how to compute the permutation, we can consider a set of
5 colored balls as shown in figure 1.18 .
figure 1.18: permutation. the number of choices is reduced in every stage. therefore, the total number
isn×(n−1)× ··· × (n−k+ 1) if there are kstages.
if you start with the base, which contains five balls, you will have five choices. at one
level up, since one ball has already been taken, you have only four choices. you continue
the process until you reached the number of balls you want to collect. the number of
configurations you have generated is the permutation. here is the formula:
33chapter 1. mathematical background
theorem 1.6. the number of permutations of choosing kout of nis
n!
(n−k)!
where n! =n(n−1)(n−2)···3·2·1.
proof . let’s list all possible ways:
which ball to pick number of choices why?
the 1st ball n no has been picked, so we
have nchoices
the 2nd ball n−1 the first ball has been
picked
the 3rd ball n−2 the first two balls have
been picked
.........
thekth ball n−k+ 1 the first k−1 balls have
been picked
total: n(n−1)···(n−k+ 1)
the total number of ordered configurations is n(n−1)···(n−k+ 1). this simplifies
to
n(n−1)(n−2)···(n−k+ 1)
=n(n−1)(n−2)···(n−k+ 1)·(n−k)(n−k−1)···3·2·1
(n−k)(n−k−1)···3·2·1
=n!
(n−k)!.
□
practice exercise 1.8 . consider a set of 4 balls {1,2,3,4}. we want to pick two
balls at random without replacement. the ordering matters. how many permutations
can we obtain?
solution . the possible configurations are (1,2), (2,1), (1,3), (3,1), (1,4), (4,1), (2,3),
(3,2), (2,4), (4,2), (3,4), (4,3). so totally there are 12 configurations. we can also
verify this number by noting that there are 4 balls altogether and so the number
of choices for picking the first ball is 4 and the number of choices for picking the
second ball is (4 −1) = 3. thus, the total is 4 ·3 = 12. referring to the formula, this
result coincides with the theorem, which states that the number of permutations is
4!
(4−2)!=4·3·2·1
2·1= 12.
1.5.3 combination
another operation in combinatorics is combination. combination concerns the following
question:
341.5. basic combinatorics
consider a set of ndistinct balls. suppose we want to pick kballs from the set without
replacement. how many unordered configurations can we obtain?
unlike permutation, combination treats a subset of balls with whatever ordering as
one single configuration. for example, the subset ( a, b, c ) is considered the same as ( a, c, b )
or (b, c, a ), etc.
let’s go back to the 5-ball exercise. suppose you have picked orange, green, and light
blue. this is the same combination as if you have picked {green, orange, and light blue },
or{green, light blue, and orange }.figure 1.19 lists all the six possible configurations for
these three balls. so what is combination? combination needs to take these repeated cases
into account.
figure 1.19: combination. in this problem, we are interested in picking 3 colored balls out of 5. this
will give us 5×4×3 = 60 permutations. however, since we are not interested in the ordering, some of
the permutations are repeated. for example, there are 6 combos of (green, light blue, orange), which is
computed from 3×2×1. dividing 60 permutations by these 6 choices of the orderings will give us 10
distinct combinations of the colors.
theorem 1.7. the number of combinations of choosing kout of nis
n!
k!(n−k)!
where n! =n(n−1)(n−2)···3·2·1.
proof . we start with the permutation result, which gives usn!
(n−k)!permutations. note that
every permutation has exactly kballs. however, while these kballs can be arranged in any
order, in combination, we treat them as one single configuration. therefore, the task is to
count the number of possible orderings for these kballs.
to this end, we note that for a set of kballs, there are in total k! possible ways of
ordering them. the number k! comes from the following table.
35chapter 1. mathematical background
which ball to pick number of choices
the 1st ball k
the 2nd ball k−1
......
thekth ball 1
total: k(k−1)···3·2·1
therefore, the total number of orderings for a set of kballs is k!. since permutation
gives usn!
(n−k)!and every permutation has k! repetitions due to ordering, we divide the
number by k!. thus the number of combinations is
n!
k!(n−k)!.
□
practice exercise 1.9 . consider a set of 4 balls {1,2,3,4}. we want to pick two
balls at random without replacement. the ordering does not matter. how many com-
binations can we obtain?
solution . the permutation result gives us 12 permutations. however, among all these
12 permutations, there are only 6 distinct pairs of numbers. we can confirm this by
noting that since we picked 2 balls, there are exactly 2 possible orderings for these 2
balls. therefore, we have12
2= 6 number of combinations. using the formula of the
theorem, we check that the number of combinations is
4!
2!(4−2)!=4·3·2·1
(2·1)(2·1)= 6.
example 1.10 . (ross, 8th edition, section 1.6) consider the equation
x1+x2+···+xk=n,
where {xk}are positive integers. how many combinations of solutions of this equation
are there?
solution . we can determine the number of combinations by considering the figure
below. the integer ncan be modeled as nballs in an urn. the number of variables k
is equivalent to the number of colors of these balls. since all variables are positive, the
problem can be translated to partitioning the nballs into kbuckets. this, in turn,
is the same as inserting k−1 dividers among n−1 holes. therefore, the number of
combinations is n−1
k−1
=(n−1)!
(k−1)!(n−k)!.
for example, if n= 16 and k= 4, then the number of solutions is
16−1
4−1
=15!
3!12!= 455 .
361.6. summary
figure 1.20: one possible solution for n= 16 andk= 4. in general, the problem is equivalent
to inserting k−1dividers among n−1balls.
closing remark . permutations and combinations are two ways to enumerate all the pos-
sible cases. while the conclusions are probabilistic, as the birthday paradox shows, permu-
tation and combination are deterministic. we do not need to worry about the distribution
of the samples, and we are not taking averages of anything. thus, modern data analysis
seldom uses the concepts of permutation and combination. accordingly, combinatorics does
not play a large role in this book.
does it mean that combinatorics is not useful? not quite, because it still provides us
with powerful tools for theoretical analysis. for example, in binomial random variables, we
need the concept of combination to calculate the repeated cases. the poisson random vari-
able can be regarded as a limiting case of the binomial random variable, and so combination
is also used. therefore, while we do not use the concepts of permutation per se, we use them
to define random variables.
1.6 summary
in this chapter, we have reviewed several background mathematical concepts that will be-
come useful later in the book. you will find that these concepts are important for under-
standing the rest of this book. when studying these materials, we recommend not just
remembering the “recipes” of the steps but focusing on the motivations andintuitions
behind the techniques.
we would like to highlight the significance of the birthday paradox. many of us come
from an engineering background in which we were told to ensure reliability and guarantee
success. we want to ensure that the product we deliver to our customers can survive even
in the worst-case scenario. we tend to apply deterministic arguments such as requiring 366
people to ensure complete coverage of the 365 days. in modern data analysis, the worst-case
scenario may not always be relevant because of the complexity of the problem and the cost
of such a warranty. the probabilistic argument, or the average argument, is more reasonable
and cost-effective, as you can see from our analysis of the birthday problem. the heart of
the problem is the trade-off between how much confidence you need versus how much effort
you need to expend. suppose an event is unlikely to happen, but if it happens, it will be
a disaster. in that case, you might prefer to be very conservative to ensure that such a
disaster event has a low chance of happening. industries related to risk management such
as insurance and investment banking are all operating under this principle.
37chapter 1. mathematical background
1.7 reference
introductory materials
1-1 erwin kreyszig, advanced engineering mathematics , wiley, 10th edition, 2011.
1-2 henry stark and john w. woods, probability and random processes with applications
to signal processing , prentice hall, 3rd edition, 2002. appendix.
1-3 michael j. evans and jeffrey s. rosenthal, probability and statistics: the science of
uncertainty , w. h. freeman, 2nd edition, 2009. appendix.
1-4 james stewart, single variable calculus, early transcendentals , thomson brooks/-
cole, 6th edition, 2008. chapter 5.
combinatorics
1-5 dimitri p. bertsekas and john n. tsitsiklis, introduction to probability , athena sci-
entific, 2nd edition, 2008. section 1.6.
1-6 alberto leon-garcia, probability, statistics, and random processes for electrical en-
gineering , prentice hall, 3rd edition, 2008. section 2.6.
1-7 athanasios papoulis and s. unnikrishna pillai, probability, random variables and
stochastic processes , mcgraw-hill, 4th edition, 2001. chapter 3.
analysis
in some sections of this chapter, we use results from calculus and infinite series. many formal
proofs can be found in the standard undergraduate real analysis textbooks.
1-8 tom m. apostol, mathematical analysis , pearson, 1974.
1-9 walter rudin, principles of mathematical analysis , mcgraw hill, 1976.
1.8 problems
exercise 1. (video solution)
(a) show that
nx
k=0rk=1−rn+1
1−r.
for any 0 < r < 1. evaluatep∞
k=0rk.
(b) using the result of (a), evaluate
1 + 2 r+ 3r2+···.
381.8. problems
(c) evaluate the sums
∞x
k=0k1
3k+1
,and∞x
k=2k1
4k−1
.
exercise 2. (video solution)
recall that∞x
k=0λk
k!=eλ.
evaluate∞x
k=0kλke−λ
k!,and∞x
k=0k2λke−λ
k!.
exercise 3. (video solution)
evaluate the integrals
(a)zb
a1
b−a
x−a+b
22
dx.
(b)z∞
0λxe−λxdx.
(c)z∞
−∞λx
2e−λ|x|dx.
exercise 4.
(a) compute the result of the following matrix vector multiplication using numpy. submit
your result and codes.

1 2 3
4 5 6
7 8 9
×
1
2
3
.
(b) plot a sine function on the interval [ −π, π] with 1000 data points.
(c) generate 10,000 uniformly distributed random numbers on interval [0, 1).
usematplotlib.pyplot.hist to generate a histogram of all the random numbers.
39chapter 1. mathematical background
exercise 5.
calculate∞x
k=0k2
3k+1
.
exercise 6.
let
x=x
y
,µ=1
0
,σ=4 1
1 1
.
(a) find σ−1, the inverse of σ.
(b) find |σ|, the determinant of σ.
(c) simplify the two-dimensional function
f(x) =1
2π|σ|1/2exp
−1
2(x−µ)tς−1(x−µ)
.
(d) use matplotlib.pyplot.contour , plot the function f(x) for the range [ −3,3]×
[−3,3].
exercise 7.
out of seven electrical engineering (ee) students and five mechanical engineering (me)
students, a committee consisting of three ees and two mes is to be formed. in how many
ways can this be done if
(a) any of the ees and any of the mes can be included?
(b) one particular ee must be on the committee?
(c) two particular mes cannot be on the committee?
exercise 8.
five blue balls, three red balls, and three white balls are placed in an urn. three balls are
drawn at random without regard to the order in which they are drawn. using the counting
approach to probability, find the probability that
(a) one blue ball, one red ball, and one white ball are drawn.
(b) all three balls drawn are red.
(c) exactly two of the balls drawn are blue.
exercise 9.
a collection of 26 english letters, a-z, is mixed in a jar. two letters are drawn at random,
one after the other.
401.8. problems
(a) what is the probability of drawing a vowel (a,e,i,o,u) and a consonant in either order?
(b) write a matlab / python program to verify your answer in part (a). randomly
draw two letters without replacement and check whether one is a vowel and the other
is a consonant. compute the probability by repeating the experiment 10000 times.
exercise 10.
there are 50 students in a classroom.
(a) what is the probability that there is at least one pair of students having the same
birthday? show your steps.
(b) write a matlab / python program to simulate the event and verify your answer
in (a). hint: you probably need to repeat the simulation many times to obtain a
probability. submit your code and result.
you may assume that a year only has 365 days. you may also assume that all days have an
equal likelihood of being taken.
41chapter 1. mathematical background
42chapter 2
probability
data and probability are inseparable. data is the computational side of the story, whereas
probability is the theoretical side of the story. any data science practice must be built on
the foundation of probability, and probability needs to address practical problems. however,
what exactly is “probability”? mathematicians have been debating this for centuries. the
frequentists argue that probability is the relative frequency of an outcome. for example,
flipping a fair coin has a 1/2 probability of getting a head because if you flip the coin
infinitely many times, you will have half of the time getting a head. the bayesians argue
that probability is a subjective belief. for example, the probability of getting an a in a
class is subjective because no one would want to take a class infinitely many times to obtain
the relative frequency. both the frequentists and bayesians have valid points. however, the
differentiation is often non-essential because the context of your problem will force you
to align with one or the other. for example, when you have a shortage of data, then the
subjectivity of the bayesians allows you to use prior knowledge, whereas the frequentists
tell us how to compute the confidence interval of an estimate.
no matter whether you prefer the frequentist’s view or the bayesian’s view, there is
something more fundamental thanks to andrey kolmogorov (1903-1987). the development
of this fundamental definition will take some effort on our part, but if we distill the essence,
we can summarize it as follows:
probability is a measure of the size of a set.
this sentence is not a formal definition; instead, it summarizes what we believe to be the
essence of probability. we need to clarify some puzzles later in this chapter, but if you can
understand what this sentence means, you are halfway done with this book. to spell out the
details, we will describe an elementary problem that everyone knows how to solve. as we
discuss this problem, we will highlight a few key concepts that will give you some intuitive
insights into our definition of probability, after which we will explain the sequence of topics
to be covered in this chapter.
prelude: probability of throwing a die
suppose that you have a fair die. it has 6 faces: {
,
,
,
,
,
}. what is the probability
that you get a number that is “less than 5” and is “an even number”? this is a straightfor-
43chapter 2. probability
ward problem. you probably have already found the answer, which is2
6because “less than
5” and “an even number” means {
,
}. however, let’s go through the thinking process
slowly by explicitly writing down the steps.
first of all, how do we know that the denominator in2
6is 6? well, because there are six
faces. these six faces form a set called the sample space . a sample space is the set containing
all possible outcomes, which in our case is ω = {
,
,
,
,
,
}. the denominator 6 is the
size of the sample space.
how do we know that the numerator is 2? again, implicitly in our minds, we have
constructed two events :e1= “less than 5” = {
,
,
,
}, and e2= “an even number”
={
,
,
}. then we take the intersection between these two events to conclude the event
e={
,
}. the numerical value “2” is the size of this event e.
so, when we say that “the probability is2
6,” we are saying that the size of the event
erelative to the sample space ω is the ratio2
6. this process involves measuring the size
ofeand ω. in this particular example, the measure we use is a “counter” that counts the
number of elements.
this example shows us all the necessary components of probability: (i) there is a
sample space , which is the set that contains all the possible outcomes. (ii) there is an event ,
which is a subset inside the sample space. (iii) two events e1ande2can be combined to
construct another event ethat is still a subset inside the sample space. (iv) probability is
a number assigned by certain rules such that it describes the relative size of the event e
compared with the sample space ω. so, when we say that probability is a measure of the
size of a set , we create a mapping that takes in a set and outputs the size of that set.
organization of this chapter
as you can see from this example, since probability is a measure of the size of a set, we need
to understand the operations of sets to understand probability. accordingly, in section 2.1
we first define sets and discuss their operations. after learning these basic concepts, we move
on to define the sample space and event space in section 2.2. there, we discuss sample spaces
that are not necessarily countable and how probabilities are assigned to events. of course,
assigning a probability value to an event cannot be arbitrary; otherwise, the probabilities
may be inconsistent. consequently, in section 2.3 we introduce the probability axioms and
formalize the notion of measure. section 2.4 consists of a trio of topics that concern the
relationship between events using conditioning. we discuss conditional probability in section
2.4.1, independence in section 2.4.2, and bayes’ theorem in section 2.4.3.
2.1 set theory
2.1.1 why study set theory?
in mathematics, we are often interested in describing a collection of numbers, for example, a
positive interval [ a, b] on the real line or the ordered pairs of numbers that define a circle on
a graph with two axes. these collections of numbers can be abstractly defined as sets. in a
nutshell, a set is simply a collection of things. these things can be numbers, but they can also
be alphabets, objects, or anything. set theory is a mathematical tool that defines operations
on sets. it provides the basic arithmetic for us to combine, separate, and decompose sets.
442.1. set theory
why do we start the chapter by describing set theory? because probability is a measure
of the size of a set . yes, probability is not just a number telling us the relative frequency of
events; it is an operator that takes a set and tells us how large the set is. using the example
we showed in the prelude, the event “even number” of a die is a set containing numbers
{
,
,
}. when we apply probability to this set, we obtain the number3
6, as shown in
figure 2.1 . thus sets are the foundation of the study of probability.
figure 2.1: probability is a measure of the size of a set. whenever we talk about probability, it has to
be the probability of a set.
2.1.2 basic concepts of a set
definition 2.1 (set).asetis a collection of elements. we denote
a={ξ1, ξ2, . . . , ξ n} (2.1)
as a set, where ξiis the ith element in the set.
in this definition, ais called a set. it is nothing but a collection of elements ξ1, . . . , ξ n. what
are these ξi’s? they can be anything. let’s see a few examples below.
example 2.1(a) .a={apple ,orange ,pear}is a finite set.
example 2.1(b) .a={1,2,3,4,5,6}is a finite set.
example 2.1(c) .a={2,4,6,8, . . .}is a countable but infinite set.
example 2.1(d) .a={x|0< x < 1}is a uncountable set.
to say that an element ξis drawn from a, we write ξ∈a. for example, the number 1
is an element in the set {1,2,3}. we write 1 ∈ {1,2,3}. there are a few common sets that
we will encounter. for example,
example 2.2(a) .ris the set of all real numbers including ±∞.
example 2.2(b) .r2is the set of ordered pairs of real numbers.
example 2.2(c) . [a, b] ={x|a≤x≤b}is a closed interval on r.
example 2.2(d) . (a, b) ={x|a < x < b }is an open interval on r.
example 2.2(e) . (a, b] ={x|a < x ≤b}is a semi-closed interval on r.
45chapter 2. probability
figure 2.2: from left to right: a closed interval, a semi-closed (or semi-open) interval, and an open
interval.
sets are not limited to numbers. a set can be used to describe a collection of functions .
example 2.3 .a={f:r→r|f(x) =ax+b, a, b ∈r}. this is the set of all straight
lines in 2d. the notation f:r→rmeans that the function ftakes an argument
fromrand sends it to another real number in r. the definition f(x) =ax+bsays
that fis taking the specific form of ax+b. since the constants aandbcan be any
real number, the equation f(x) =ax+benumerates all possible straight lines in 2d.
seefigure 2.3 (a).
example 2.4 .a={f:r→[−1,1]|f(t) = cos( ω0t+θ), θ∈[0,2π]}. this is
the set of all cosine functions of a fixed carrier frequency ω0. the phase θ, however,
is changing. therefore, the equation f(t) = cos( ω0t+θ) says that the set ais the
collection of all possible cosines with different phases. see figure 2.3 (b).
-2 -1 0 1 2
t-1-0.500.51f(t)
-1 -0.5 0 0.5 1
t-2-1012f(t)
figure 2.3: (a) the set of straight lines a={f:r→r|f(x) =ax+b, a, b ∈r}. (b) the set of
phase-shifted cosines a={f:r→[−1,1]|f(t) = cos( ω0t+θ), θ∈[0,2π]}.
a set can also be used to describe a collection of sets. let aandbbe two sets. then
c={a, b}is a set of sets.
example 2.5 . let a={1,2}andb={apple ,orange }. then
c={a, b}={{1,2},{apple ,orange }}
462.1. set theory
is a collection of sets. note that here we are not saying cis the union of two sets. we
are only saying that cis a collection of two sets. see the next example.
example 2.6 . let a={1,2}andb={3}, then c={a, b}means that
c={{1,2},{3}}.
therefore ccontains only two elements. one is the set {1,2}and the other is the set
{3}. note that {{1,2},{3}} ̸={1,2,3}. the former is a set of two sets. the latter is a
set of three elements.
2.1.3 subsets
given a set, we often want to specify a portion of the set, which is called a subset .
definition 2.2 (subset ).bis asubset ofaif for any ξ∈b,ξis also in a. we
write
b⊆a (2.2)
to denote that bis a subset of a.
bis called a proper subset ofaifbis a subset of aandb̸=a. we denote a proper subset
asb⊂a. two sets aandbare equal if and only if a⊆bandb⊆a.
example 2.7 .
ifa={1,2,3,4,5,6}, then b={1,3,5}is a proper subset of a.
ifa={1,2}, then b={1,2}is an improper subset of a.
ifa={t|t≥0}, then b={t|t >0}is a proper subset of a.
practice exercise 2.1 . let a={1,2,3}. list all the subsets of a.
solution . the subsets of aare:
a={∅,{1},{2},{3},{1,2},{1,3},{2,3},{1,2,3}}.
practice exercise 2.2 . prove that two sets aandbare equal if and only if a⊆b
andb⊆a.
solution . suppose a⊆bandb⊆a. assume by contradiction that a̸=b. then
necessarily there must exist an xsuch that x∈abutx̸∈b(or vice versa). but
a⊆bmeans that x∈awill necessarily be in b. so it is impossible to have x̸∈b.
conversely, suppose that a=b. then any x∈awill necessarily be in b. therefore,
we have a⊆b. similarly, if a=bthen any x∈bwill be in a, and so b⊆a.
47chapter 2. probability
2.1.4 empty set and universal set
definition 2.3 (empty set ).a set is empty if it contains no element. we denote
an empty set as
a=∅. (2.3)
a set containing an element 0 is not an empty set. it is a set of one element, {0}. the
number of elements of the empty set is 0. the empty set is a subset of any set, i.e., ∅ ⊆a
for any a. we use ⊆because acould also be an empty set.
example 2.8(a) . the set a={x|sinx >1}is empty because no x∈rcan make
sinx >1.
example 2.8(b) . the set a={x|x > 5 and x < 1}is empty because the two
conditions x >5 and x <1 are contradictory.
definition 2.4 (universal set ).theuniversal set is the set containing all elements
under consideration. we denote a universal set as
a= ω. (2.4)
the universal set ω contains itself, i.e., ω ⊆ω. the universal set is a relative concept.
usually, we first define a universal set ω before referring to subsets of ω. for example, we
can define ω = rand refer to intervals in r. we can also define ω = [0 ,1] and refer to
subintervals inside [0 ,1].
2.1.5 union
we now discuss basic set operations. by operations, we mean functions of two or more sets
whose output value is a set. we use these operations to combine and separate sets. let us
first consdier the union of two sets. see figure 2.4 for a graphical depiction.
definition 2.5 (finite union ).theunion of two sets aandbcontains all elements
inaorinb. that is,
a∪b={ξ|ξ∈aorξ∈b}. (2.5)
as the definition suggests, the union of two sets connects the sets using the logical operator
”or”. therefore, the union of two sets is always larger than or equal to the individual sets.
example 2.9(a) . ifa={1,2},b={1,5}, then a∪b={1,2,5}. the overlapping
element 1 is absorbed. also, note that a∪b̸={{1,2},{1,5}}. the latter is a set of
sets.
example 2.9(b) . ifa= (3,4],b= (3.5,∞), then a∪b= (3,∞).
example 2.9(c) . ifa={f:r→r|f(x) =ax}andb={f:r→r|f(x) =b},
then a∪b= a set of sloped lines with a slope aplus a set of constant lines with
482.1. set theory
height b. note that a∪b̸={f:r→r|f(x) =ax+b}because the latter is a set of
sloped lines with arbitrary y-intercept.
example 2.9(d) . ifa={1,2}andb=∅, then a∪b={1,2}.
example . ifa={1,2}andb= ω, then a∪b= ω.
figure 2.4: the union of two sets contains elements that are either in aorbor both.
the previous example can be generalized in the following exercise. what it says is that
ifais a subset of another set b, then the union of aandbis just b. intuitively, this should
be straightforward because whatever you have in ais already in b, so the union will just
beb. below is a formal proof that illustrates how to state the arguments clearly. you may
like to draw a picture to convince yourself that the proof is correct.
practice exercise 2.3 : prove that if a⊆b, then a∪b=b.
solution : we will show that a∪b⊆bandb⊆a∪b. let ξ∈a∪b. then ξmust
be inside either aorb(or both). in any case, since we know that a⊆b, it holds
that if ξ∈athen ξmust also be in b. therefore, for any ξ∈a∪bwe have ξ∈b.
this shows a∪b⊆b. conversely, if ξ∈b, then ξmust be inside a∪bbecause
a∪bis a larger set than b. so if ξ∈bthen ξ∈a∪band hence b⊆a∪b. since
a∪bis a subset of bor equal to b, and bis a subset of a∪bor equal to a∪b, it
follows that a∪b=b.
what should we do if we want to take the union of an infinite number of sets? first,
we need to define the concept of an infinite union .
definition 2.6 (infinite union ).for an infinite sequence of sets a1, a2, . . ., the in-
finite union is defined as
∞[
n=1an={ξ|ξ∈anforat least one nthat is finite. }. (2.6)
an infinite union is a natural extension of a finite union. it is not difficult to see that
ξ∈aorξ∈b⇐⇒ ξis inat least one of aandb.
49chapter 2. probability
similarly, an infinite union means that
ξ∈a1orξ∈a2orξ∈a3. . .⇐⇒ ξis inat least one of a1, a2, a3, . . . .
the finite nrequirement says that we only evaluate the sets for a finite number of n’s. this
ncan be arbitrarily large, but it is finite. why are we able to do this? because the concept
of an infinite union is to determine a∞, which is the limit of a sequence. like any sequence
of real numbers, the limit of a sequence of sets has to be defined by evaluating the instances
of all possible finite cases.
consider a sequence of sets an=
−1,1−1
n
, for n= 1,2, . . .. for example, a1=
[−1,0],a2=
−1,1
2
,a3=
−1,2
3
,a4=
−1,3
4
, etc.
figure 2.5: the infinite union ofs∞
n=1
−1,1−1
n
. no matter how large ngets, the point 1is never
included. so the infinite union is [−1,1)
to take the infinite union, we know that the set [ −1,1) is always included, because the
right-hand limit 1 −1
napproaches 1 as napproaches ∞. so the only question concerns the
number 1. should 1 be included? according to the definition above, we ask: is 1 an element
ofat least one of the sets a1,a2, . . . , an? clearly it is not: 1 ̸∈a1, 1̸∈a2,. . .. in fact,
1̸∈anfor any finite n. therefore 1 is not an element of the infinite union, and we conclude
that∞[
n=1an=∞[
n=1
−1,1−1
n
= [−1,1).
practice exercise 2.4 . find the infinite union of the sequences where (a) an=
−1,1−1
n
, (b) an= 
−1,1−1
n
.
solution . (a)s∞
n=1an= [−1,1). (b)s∞
n=1an= (−1,1).
2.1.6 intersection
the union of two sets is based on the logical operator or. if we use the logical operator and,
then the result is the intersection of two sets.
definition 2.7 (finite intersection ).theintersection of two sets aandbcontains
all elements in aandinb. that is,
a∩b={ξ|ξ∈aandξ∈b}. (2.7)
figure 2.6 portrays intersection graphically. intersection finds the common elements of the
two sets. it is not difficult to show that a∩b⊆aanda∩b⊆b.
502.1. set theory
figure 2.6: the intersection of two sets contains elements in both aandb.
example 2.10(a) . ifa={1,2,3,4},b={1,5,6}, then a∩b={1}.
example 2.10(b) . ifa={1,2},b={5,6}, then a∩b=∅.
example 2.10(c) . ifa= (3,4],b= [3.5,∞), then a∩b= [3.5,4].
example 2.10(d) . ifa= (3,4],b=∅, then a∩b=∅.
example 2.10(e) . ifa= (3,4],b= ω, then a∩b= (3,4].
example 2.11 . ifa={f:r→r|f(x) =ax}andb={f:r→r|f(x) =b}, then
a∩b= the intersection of a set of sloped lines with a slope aand a set of constant lines
with height b. the only line that can satisfy both sets is the line f(x) = 0. therefore,
a∩b={f|f(x) = 0}.
example 2.12 . ifa={{1},{2}}andb={{2,3},{4}}, then a∩b=∅. this is
because ais a set containing two sets, and bis a set containing two sets. the two sets
{2}and{2,3}are not the same. thus, aandbhave no elements in common, and so
a∩b=∅.
similarly to the infinite union, we can define the concept of infinite intersection .
definition 2.8 (infinite intersection ).for an infinite sequence of sets a1, a2, . . .,
theinfinite intersection is defined as
∞\
n=1an={ξ|ξ∈anfor every finite n.} (2.8)
to understand this definition, we note that
ξ∈aand ξ∈b⇐⇒ ξis inevery one ofaandb.
as a result, it follows that
ξ∈a1and ξ∈a2and ξ∈a3. . .⇐⇒ ξis inevery one of a1, a2, a3, . . . .
51chapter 2. probability
since the infinite intersection requires that ξis in every one of a1,a2,. . .,an, if there is a
setaithat does not contain ξ, the infinite intersection is an empty set.
consider the problem of finding the infinite intersection oft∞
n=1an, where
an=
0,1 +1
n
.
we note that the sequence of sets is [0 ,2], [0 ,1.5], [0 ,1.33], . . . . as n→ ∞ , we note that
the limit is either [0 ,1) or [0 ,1]. should the right-hand limit 1 be included in the infinite
intersection? according to the definition above, we know that 1 ∈a1, 1∈a2, . . . , 1 ∈an
for any finite n. therefore, 1 is included and so
∞\
n=1an=∞\
n=1
0,1 +1
n
= [0,1].
figure 2.7: the infinite intersection oft∞
n=1
0,1 +1
n
. no matter how large ngets, the point 1is
never included. so the infinite intersection is [0,1]
practice exercise 2.5 . find the infinite intersection of the sequences where (a)
an=
0,1 +1
n
, (b) an= 
0,1 +1
n
, (c)an=
0,1−1
n
, (d) an=
0,1−1
n
.
solution .
(a)t∞
n=1an= [0,1].
(b)t∞
n=1an= (−1,1].
(c)t∞
n=1an= [0,0) =∅.
(d)t∞
n=1an= [0,0] ={0}.
2.1.7 complement and difference
besides union and intersection, there is a third basic operation on sets known as the com-
plement .
definition 2.9 (complement ).thecomplement of a set ais the set containing all
elements that are in ωbut not in a. that is,
ac={ξ|ξ∈ωandξ̸∈a}. (2.9)
figure 2.8 graphically portrays the idea of a complement. the complement is a set that
contains everything in the universal set that is not in a. thus the complement of a set is
always relative to a specified universal set.
522.1. set theory
figure 2.8: [left] the complement of a set acontains all elements that are not in a. [right] the
difference a\bcontains elements that are in abut not in b.
example 2.13(a) . let a={1,2,3}and ω = {1,2,3,4,5,6 }. then ac={4,5,6}.
example 2.13(b) . let a={even integers }and ω = {integers }. then ac={odd
integers }.
example 2.13(c) . let a={integers }and ω = r. then ac={any real number that
is not an integer }.
example 2.13(d) . let a= [0,5) and ω = r. then ac= (−∞,0)∪[5,∞).
example 2.13(e) . let a=rand ω = r. then ac=∅.
the concept of the complement will help us understand the concept of difference .
definition 2.10 (difference ).thedifference a\bis the set containing all elements
inabut not in b.
a\b={ξ|ξ∈aandξ̸∈b}. (2.10)
figure 2.8 portrays the concept of difference graphically. note that a\b̸=b\a. the former
removes the elements in bwhereas the latter removes the elements in a.
example 2.14(a) . let a={1,3,5,6}andb={2,3,4}. then a\b={1,5,6}and
b\a={2,4}.
example 2.14(b) . let a= [0,1],b= [2,3], then a\b= [0,1], and b\a= [2,3].
this example shows that if the two sets do not overlap, there is nothing to subtract.
example 2.14(c) . let a= [0,1],b=r, then a\b=∅, and b\a= (−∞,0)∪(1,∞).
this example shows that if one of the sets is the universal set, then the difference will
either return the empty set or the complement.
53chapter 2. probability
figure 2.9: [left] aandbare overlapping. [right] aandbare disjoint.
practice exercise 2.6 . show that for any two sets aandb, the differences a\b
andb\anever overlap, i.e., ( a\b)∩(b\a) =∅.
solution . suppose, by contradiction, that the intersection is not empty so that there
exists an ξ∈(a\b)∩(b\a). then, by the definition of intersection, ξis an element
of (a\b)and(b\a). but if ξis an element of ( a\b), it cannot be an element of b.
this implies that ξcannot be an element of ( b\a) since it is a subset of b. this is a
contradiction because we just assumed that the ξcan live in both ( a\b) and ( b\a).
difference can be defined in terms of intersection and complement:
theorem 2.1. letaandbbe two sets. then
a\b=a∩bc(2.11)
proof . let x∈a\b. then x∈aandx̸∈b. since x̸∈b, we have x∈bc. therefore,
x∈aandx∈bc. by the definition of intersection, we have x∈a∩bc. this shows
that a\b⊆a∩bc. conversely, let x∈a∩bc. then, x∈aandx∈bc, which implies
that x∈aandx̸∈b. by the definition of a\b, we have that x∈a\b. this shows that
a∩bc⊆a\b.
□
2.1.8 disjoint and partition
it is important to be able to quantify situations in which two sets are not overlapping. in
this situation, we say that the sets are disjoint .
definition 2.11 (disjoint ).two sets aandbaredisjoint if
a∩b=∅. (2.12)
for a collection of sets {a1, a2, . . . , a n}, we say that the collection is disjoint if, for
any pair i̸=j,
ai∩aj=∅. (2.13)
a pictorial interpretation can be found in figure 2.9 .
542.1. set theory
example 2.15(a) . let a={x >1}andb={x <0}. then aandbare disjoint.
example 2.15(b) . let a={1,2,3}andb=∅. then aandbare disjoint.
example 2.15(c) . let a= (0,1) and b= [1,2). then aandbare disjoint.
with the definition of disjoint, we can now define the powerful concept of partition .
definition 2.12 (partition ).a collection of sets {a1, . . . , a n}is apartition of the
universal set ωif it satisfies the following conditions:
(non-overlap ){a1, . . . , a n}is disjoint:
ai∩aj=∅. (2.14)
(decompose ) union of {a1, . . . , a n}gives the universal set:
n[
i=1ai= ω. (2.15)
in plain language, a partition is a collection of non-overlapping subsets whose union is
the universal set. partition is important because it is a decomposition of ω into a smaller
subset, and since these subsets do not overlap, they can be analyzed separately. partition
is a handy tool for studying probability because it allows us to decouple complex events by
treating them as isolated sub-events.
figure 2.10: a partition of ωcontains disjoint subsets of which the union gives us ω.
example 2.16 . let ω = {1,2,3,4,5,6}. the following sets form a partition:
a1={1,2,3}, a 2={4,5}, a 3={6}
example 2.17 . let ω = {1,2,3,4,5,6}. the collection
a1={1,2,3}, a 2={4,5}, a 3={5,6}
does not form a partition, because a2∩a3={5}.
55chapter 2. probability
if{a1, a2, . . . , a n}forms a partition of the universal set ω, then for any b⊆ω, we
can decompose bintondisjoint subsets: b∩a1,b∩a2, . . .b∩an. two properties hold:
b∩aiandb∩ajare disjoint if i̸=j.
the union of b∩a1,b∩a2, . . .b∩anisb.
practice exercise 2.7 . prove the above two statements.
solution . to prove the first statement, we can pick ξ∈(b∩ai). this means that
ξ∈bandξ∈ai. since ξ∈ai, it cannot be in ajbecause aiandajare disjoint.
therefore ξcannot live in b∩aj. this completes the proof, because we just showed
that any ξ∈b∩aicannot simultaneously live in b∩aj.
to prove the second statement, we pick ξ∈sn
i=1(b∩ai). since ξlives in the
union, it has to live in at least one of the ( b∩ai) for some i. now suppose ξ∈b∩ai.
this means that ξis in both bandai, so it must live in b. therefore,sn
i=1(b∩ai)⊆
b. now, suppose we pick ξ∈b. then since it is an element in b, it must be an element
in all of the ( b∩ai)’s for any i. therefore, ξ∈sn
i=1(b∩ai), and so we showed that
b⊆sn
i=1(b∩ai). combining the two directions, we conclude thatsn
i=1(b∩ai) =b.
example 2.18 . let ω = {1,2,3,4,5,6}and let a partition of ω be a1={1,2,3},
a2={4,5},a3={6}. let b={1,3,4}. then, by the result we just proved, bcan
be decomposed into three subsets:
b∩a1={1,3}, b∩a2={4}, b∩a3=∅.
thus we can see that b∩a1,b∩a2andb∩a3are disjoint. furthermore, the union
of these three sets gives b.
2.1.9 set operations
when handling multiple sets, it would be useful to have some basic set operations. there
are four basic theorems concerning set operations that you need to know for our purposes
in this book:
theorem 2.2 (commutative ).(order does not matter)
a∩b=b∩a, and a∪b=b∪a. (2.16)
theorem 2.3 (associative ).(how to do multiple union and intersection)
a∪(b∪c) = (a∪b)∪c,
a∩(b∩c) = (a∩b)∩c. (2.17)
562.1. set theory
theorem 2.4 (distributive ).(how to mix union and intersection)
a∩(b∪c) = (a∩b)∪(a∩c),
a∪(b∩c) = (a∪b)∩(a∪c). (2.18)
theorem 2.5 (de morgan’s law ).(how to complement over intersection and union)
(a∩b)c=ac∪bc,
(a∪b)c=ac∩bc. (2.19)
example 2.19 . consider [1 ,4]∩([0,2]∪[3,5]). by the distributive property we can
simplify the set as
[1,4]∩([0,2]∪[3,5]) = ([1 ,4]∩[0,2])∪([1,4]∩[3,5])
= [1,2]∪[3,4].
example 2.20 . consider ([0 ,1]∪[2,3])c. by de morgan’s law we can rewrite the set
as
([0,2]∪[1,3])c= [0,2]c∩[1,3]c.
2.1.10 closing remarks about set theory
it should be apparent why set theory is useful: it shows us how to combine, split, and
remove sets. in figure 2.11 we depict the intersection of two sets a={even number }and
b={less than or equal to 3 }. set theory tells us how to define the intersection so that the
probability can be applied to the resulting set.
figure 2.11: when there are two events aandb, the probability of a∩bis determined by first taking
the intersection of the two sets and then evaluating its probability.
universal sets and empty sets are useful too. universal sets cover all the possible
outcomes of an experiment, so we should expect p[ω] = 1. empty sets contain nothing,
and so we should expect p[∅] = 0. these two properties are essential to define a probability
because no probability can be greater than 1, and no probability can be less than 0.
57chapter 2. probability
2.2 probability space
we now formally define probability. our discussion will be based on the slogan probability
is a measure of the size of a set . three elements constitute a probability space :
sample space ω: the set of all possible outcomes from an experiment.
event space f: the collection of all possible events. an event eis a subset in ω that
defines an outcome or a combination of outcomes.
probability law p: a mapping from an event eto a number p[e] which, ideally,
measures the size of the event.
therefore, whenever you talk about “probability,” you need to specify the triplet (ω ,f,p)
to define the probability space.
the necessity of the three elements is illustrated in figure 2.12 . the sample space
is the interface with the physical world . it is the collection of all possible states that can
result from an experiment. some outcomes are more likely to happen, and some are less
likely, but this does not matter because the sample space contains every possible outcome.
theprobability law is the interface with the data analysis . it is this law that defines the
likelihood of each of the outcomes. however, since the probability law measures the size of
a set, the probability law itself must be a function, a function whose argument is a set and
whose value is a number. an outcome in the sample space is not a set. instead, a subset in
the sample space is a set. therefore, the probability should input a subset and map it to a
number. the collection of all possible subsets is the event space .
figure 2.12: given an experiment, we define the collection of all outcomes as the sample space. a
subset in the sample space is called an event. the probability law is a mapping that maps an event to
a number that denotes the size of the event.
a perceptive reader like you may be wondering why we want to complicate things to
this degree when calculating probability is trivial, e.g., throwing a die gives us a probability
1
6per face. in a simple world where problems are that easy, you can surely ignore all these
complications and proceed to the answer1
6. however, modern data analysis is not so easy.
if we are given an image of size 64 ×64 pixels, how do we tell whether this image is of a cat
or a dog? we need to construct a probability model that tells us the likelihood of having a
582.2. probability space
particular 64 ×64 image. what should be included in this probability model? we need to
know all the possible cases ( the sample space ), all the possible events ( the event space ),
and the probability of each of the events ( the probability law ). if we know all these, then our
decision will be theoretically optimal. of course, for high-dimensional data like images, we
need approximations to such a probability model. however, we first need to understand the
theoretical foundation of the probability space to know what approximations would make
sense.
2.2.1 sample space ω
we start by defining the sample space ω. given an experiment, the sample space ω is the
set containing all possible outcomes of the experiment.
definition 2.13. asample space ωis the set of all possible outcomes from an ex-
periment. we denote ξas an element in ω.
a sample space can contain discrete outcomes or continuous outcomes, as shown in
the examples below and figure 2.13 .
example 2.21 : (discrete outcomes)
coin flip: ω = {h, t}.
throw a die: ω = {
,
,
,
,
,
}.
paper / scissor / stone: ω = {paper ,scissor ,stone}.
draw an even integer: ω = {2,4,6,8, . . .}.
example 2.22 : (continuous outcomes)
waiting time for a bus in west lafayette: ω = {t|0≤t≤30 minutes }.
phase angle of a voltage: ω = {θ|0≤θ≤2π}.
frequency of a pitch: ω = {f|0≤f≤fmax}.
figure 2.13 also shows a functional example of the sample space. in this case, the
sample space contains functions . for example,
set of all straight lines in 2d:
ω ={f|f(x) =ax+b, a, b ∈r}.
set of all cosine functions with a phase offset:
ω ={f|f(t) = cos(2 πω0t+ θ),0≤θ≤2π}.
as we see from the above examples, the sample space is nothing but a universal set.
the elements inside the sample space are the outcomes of the experiment. if you change
59chapter 2. probability
figure 2.13: the sample space can take various forms: it can contain discrete numbers, or continuous
intervals, or even functions.
the experiment, the possible outcomes will be different so that the sample space will be
different. for example, flipping a coin has different possible outcomes from throwing a die.
what if we want to describe a composite experiment where we flip a coin and throw a
die? here is the sample space:
example 2.23 : if the experiment contains flipping a coin and throwing a die, then
the sample space is

(h,
),(h,
),(h,
),(h,
),(h,
),(h,
),
(t,
),(t,
),(t,
),(t,
),(t,
),(t,
)
.
in this sample space, each element is a pair of outcomes.
practice exercise 2.8 . there are 8 processors on a computer. a computer job sched-
uler chooses one processor randomly. what is the sample space? if the computer job
scheduler can choose two processors at once, what is the sample space then?
solution . the sample space of the first case is ω = {1,2,3,4,5,6,7,8}. the sample
space of the second case is ω = {(1,2),(1,3),(1,4), . . . , (7,8)}.
practice exercise 2.9 . a cell phone tower has a circular average coverage area of
radius of 10 km. we observe the source locations of calls received by the tower. what
is the sample space of all possible source locations?
solution . assume that the center of the tower is located at ( x0, y0). the sample space
is the set
ω ={(x, y)|p
(x−x0)2+ (y−y0)2≤10}.
not every set can be a sample space. a sample space must be exhaustive andexclusive .
the term “exhaustive” means that the sample space has to cover allpossible outcomes. if
602.2. probability space
there is one possible outcome that is left out, then the set is no longer a sample space. the
term “exclusive” means that the sample space contains unique elements so that there is no
repetition of elements.
example 2.24 . (counterexamples)
the following two examples are not sample spaces.
throw a die: ω = {1,2,3}is not a sample space because it is not exhaustive .
throw a die: ω = {1,1,2,3,4,5,6}is not a sample space because it is not exclu-
sive.
therefore, a valid sample space must contain all possible outcomes, and each element
must be unique.
we summarize the concept of a sample space as follows.
what is a sample space ω?
a sample space ω is the collection of all possible outcomes.
the outcomes can be numbers, alphabets, vectors, or functions. the outcomes
can also be images, videos, eeg signals, audio speeches, etc.
ω must be exhaustive and exclusive.
2.2.2 event space f
the sample space contains all the possible outcomes. however, in many practical situations,
we are not interested in each of the individual outcomes; we are interested in the com-
binations of the outcomes. for example, when throwing a die, we may ask “what is the
probability of rolling an odd number?” or “what is the probability of rolling a number that
is less than 3?” clearly, “odd number” is not an outcome of the experiment because the
possible outcomes are {
,
,
,
,
,
}. we call “odd number” an event . an event must
be a subset in the sample space.
definition 2.14. anevent eis a subset in the sample space ω. the set of all possible
events is denoted as f.
while this definition is extremely simple, we need to keep in mind a few facts about events.
first, an outcome ξis an element in ω but an event eis a subset contained in ω, i.e.,
e⊆ω. thus, an event can contain one outcome but it can also contain many outcomes.
the following example shows a few cases of events:
example 2.25 . throw a die. let ω = {
,
,
,
,
,
}. the following are two pos-
sible events, as illustrated in figure 2.14 .
e1={even numbers }={
,
,
}.
61chapter 2. probability
e2={less than 3 }={
,
}.
figure 2.14: two examples of events: the first event contains numbers {2,4,6}, and the second
event contains numbers {1,2}.
practice exercise 2.10 . the “ping” command is used to measure round-trip times
for internet packets. what is the sample space of all possible round-trip times? what
is the event that a round-trip time is between 10 ms and 20 ms?
solution . the sample space is ω = [0 ,∞). the event is e= [10 ,20].
practice exercise 2.11 . a cell phone tower has a circular average coverage area of
radius 10 km. we observe the source locations of calls received by the tower. what is
the event when the source location of a call is between 2 km and 5 km from the tower?
solution . assume that the center of the tower is located at ( x0, y0). the event is
e={(x, y)|2≤p
(x−x0)2+ (y−y0)2≤5}.
the second point we should remember is the cardinality of ω and that of f. a sample
space containing nelements has a cardinality n. however, the event space constructed from
ω will contain 2nevents. to see why this is so, let’s consider the following example.
example 2.26 . consider an experiment with 3 outcomes ω = {♣,♡,✠}. we can list
out all the possible events: ∅,{♣},{♡},{✠},{♣,♡},{♣,✠},{♡,♣},{♣,♡,✠}. so
in total there are 23= 8 possible events. figure 2.15 depicts the situation. what is
the difference between ♣and{♣}? the former is an element, whereas the latter is a
set. thus, {♣}is an event but ♣is not an event. why is ∅an event? because we can
ask “what is the probability that we get an odd number and an even number?” the
probability is obviously zero, but the reason it is zero is that the event is an empty set.
622.2. probability space
figure 2.15: the event space contains all the possible subsets inside the sample space.
in general, if there are nelements in the sample space, then the number of events
is 2n. to see why this is true, we can assign to each element a binary value: either 0 or 1.
for example, in table 2.1 we consider throwing a die. for each of the six faces, we assign a
binary code. this will give us a binary string for each event. for example, the event {
,
}
is encoded as the binary string 100010 because only
 and
 are activated. we can count
the total number of unique strings, which is the number of strings that can be constructed
from nbits. it is easily seen that this number is 2n.
event
 binary code
∅ × × × × × × 000000
{
,
} ⃝ × × × ⃝ × 100010
{
,
,
} × × ⃝ ⃝ ⃝ × 001110
............
{
,
,
,
,
}× ⃝ ⃝ ⃝ ⃝ ⃝ 011111
{
,
,
,
,
,
}⃝ ⃝ ⃝ ⃝ ⃝ ⃝ 111111
table 2.1: an event space contains 2nevents, where nis the number of elements in the sample space.
to see this, we encode each outcome with a binary code. the resulting binary string then forms a unique
index of the event. counting the total number of events gives us the cardinality of the event space.
the box below summarizes what you need to know about event spaces.
what is an event space f?
an event space fis the set of all possible subsets. it is a set of sets.
we need fbecause the probability law pis mapping a set to a number. pdoes
not take an outcome from ω but a subset inside ω.
63chapter 2. probability
event spaces: some advanced topics
the following discussions can be skipped if it is your first time reading the book.
what else do we need to take care of in order to ensure that an event is well defined? a
few set operations seem to be necessary. for example, if e1={
}ande2={
}are events,
it is necessary that e=e1∪e2={
,
}is an event too. another example: if e1={
,
}
ande2={
,
}are events, then it is necessary that e=e1∩e2={
}is also an event.
the third example: if e1={
,
,
,
}is an event, then e=ec
1={
,
}should be
an event. as you can see, there is nothing sophisticated in these examples. they are just
some basic set operations. we want to ensure that the event space is closed under these
set operations. that is, we do not want to be surprised by finding that a set constructed
from two events is not an event. however, since all set operations can be constructed from
union, intersection and complement, ensuring that the event space is closed under these
three operations effectively ensures that it is closed to allset operations.
the formal way to guarantee these is the notion of a field. this term may seem to be
abstract, but it is indeed quite useful:
definition 2.15. for an event space fto be valid, fmust be a fieldf. it is a field
if it satisfies the following conditions
∅ ∈ f andω∈ f.
(closed under complement) if f∈ f, then also fc∈ f.
(closed under union and intersection) if f1∈ f andf2∈ f, then f1∩f2∈ f
andf1∪f2∈ f.
for a finite set, i.e., a set that contains nelements, the collection of all possible subsets
is indeed a field. this is not difficult to see if you consider rolling a die. for example,
ife={
,
,
,
}is inside f, then ec={
,
}is also inside f. this is because f
consists of 2nsubsets each being encoded by a unique binary string. so if e= 001111, then
ec= 110000, which is also in f. similar reasoning applies to intersection and union.
at this point, you may ask:
why bother constructing a field? the answer is that probability is a measure of the
size of a set, so we must input a set to a probability measure pto get a number. the
set being input to pmust be a subset inside the sample space; otherwise, it will be
undefined. if we regard pas a mapping, we need to specify the collection of all its
inputs, which is the set of all subsets, i.e., the event space. so if we do not define the
field, there is no way to define the measure p.
what if the event space is not a field? if the event space is not a field, then we can
easily construct pathological cases where we cannot assign a probability. for example,
if the event space is not a field, then it would be possible that the complement of
e={
,
,
,
}(which is ec={
,
}) is not an event. this just does not make
sense.
the concept of a field is sufficient for finite sample spaces. however, there are two
other types of sample spaces where the concept of a field is inadequate. the first type of
642.2. probability space
sets consists of the countably infinite sets, and the second type consists of the sets defined
on the real line . there are other types of sets, but these two have important practical
applications. therefore, we need to have a basic understanding of these two types.
sigma-field
the difficulty of a countably infinite set is that there are infinitely many subsets in the field
of a countably infinite set. having a finite union and a finite intersection is insufficient to
ensure the closedness of all intersections and unions. in particular, having f1∪f2∈ fdoes
not automatically give uss∞
n=1fn∈ f because the latter is an infinite union. therefore,
for countably infinite sets, their requirements to be a field are more restrictive as we need
to ensure infinite intersection and union. the resulting field is called the σ-field.
definition 2.16. a sigma-field ( σ-field )fis a field such that
fis a field, and
iff1, f2, . . .∈ f, then the unions∞
i=1fiand the intersectiont∞
i=1fiare both
inf.
when do we need a σ-field? when the sample space is countable and has infinitely
many elements. for example, if the sample space contains all integers, then the collection
of all possible subsets is a σ-field. for another, if e1={2},e2={4},e3={6}, . . . , thens∞
n=1en={2,4,6,8, . . .}={positive even numbers }. clearly, we wants∞
n=1ento live in
the sample space.
borel sigma-field
while a sigma-field allows us to consider countable sets of events, it is still insufficient for
considering events defined on the real line, e.g., time, as these events are not countable.
so how do we define an event on the real line? it turns out that we need a different way
to define the smallest unit . for finite sets and countable sets, the smallest units are the
elements themselves because we can count them. for the real line, we cannot count the
elements because any non-empty interval is uncountably infinite.
the smallest unit we use to construct a field for the real line is a semi-closed interval
(−∞, b]def={x| − ∞ < x≤b}.
theborel σ-field is defined as the sigma-field generated by the semi-closed inter-
vals.
definition 2.17. theborel σ-fieldbis aσ-field generated from semi-closed intervals:
(−∞, b]def={x| − ∞ < x≤b}.
the difference between the borel σ-fieldband a regular σ-field is how we measure the
subsets. in a σ-field, we count the elements in the subsets, whereas, in a borel σ-field, we
use the semi-closed intervals to measure the subsets.
65chapter 2. probability
being a field, the borel σ-field is closed under complement, union, and intersection. in
particular, subsets of the following forms are also in the borel σ-fieldb:
(a, b),[a, b],(a, b],[a, b),[a,∞),(a,∞),(−∞, b],{b}.
for example, ( a,∞) can be constructed from ( −∞, a]c, and ( a, b] can be constructed by
taking the intersection of ( −∞, b] and ( a,∞).
example 2.27 : waiting for a bus. let ω = {0≤t≤30}. the borel σ-field contains
all semi-closed intervals ( a, b], where 0 ≤a≤b≤30. here are two possible events:
f1={less than 10 minutes }={0≤t <10}={0} ∪({0< t≤10} ∩ {10}c).
f2={more than 20 minutes }={20< t≤30}.
further discussion of the borel σ-field can be found in leon-garcia (3rd edition,)
chapter 2.9.
this is the end of the discussion. please join us again.
2.2.3 probability law p
the third component of a probability space is the probability law p. its job is to assign a
number to an event.
definition 2.18. aprobability law is a function p:f → [0,1]of an event eto a
real number in [0,1].
the probability law is thus a function , and therefore we must specify the input and
the output. the input to pis an event e, which is a subset in ω and an element in f. the
output of pis a number between 0 and 1, which we call the probability .
the definition above does not specify how an event is being mapped to a number.
however, since probability is a measure of the size of a set, a meaningful pshould be
consistent for all events in f. this requires some rules, known as the axioms of probability ,
when we define the p. any probability law pmust satisfy these axioms; otherwise, we will
see contradictions. we will discuss the axioms in the next section. for now, let us look at
two examples to make sure we understand the functional nature of p.
example 2.28 . consider flipping a coin. the event space is f={∅,{h},{t},ω}.
we can define the probability law as
p[∅] = 0,p[{h}] =1
2,p[{t}] =1
2,p[ω] = 1 ,
as shown in figure 2.16 . this pis clearly consistent for all the events in f.
is it possible to construct an invalid p? certainly. consider the following proba-
662.2. probability space
bility law:
p[∅] = 0,p[{h}] =1
3,p[{t}] =1
3,p[ω] = 1 .
this law is invalid because the individual events are p[{h}] =1
3andp[{t}] =1
3
but the union is p[ω] = 1. to fix this problem, one possible solution is to define the
probability law as
p[∅] = 0,p[{h}] =1
3,p[{t}] =2
3,p[ω] = 1 .
then, the probabilities for all the events are well defined and consistent.
figure 2.16: a probability law is a mapping from an event to a number. a probability law cannot be
arbitrarily assigned; it must satisfy the axioms of probability.
example 2.29 . consider a sample space containing three elements ω = {♣,♡,✠}.
the event space is then f=
∅,{♣},{♡},{✠},{♣,♡},{♡,✠},{♣,✠},{♣,♡,✠}
.
one possible pwe could define would be
p[∅] = 0,p[{♣}] =p[{♡}] =p[{✠}] =1
3,
p[{♣,♡}] =p[{♣,✠}] =p[{♡,✠}] =2
3,p[{♣,♡,✠}] = 1.
what is a probability law p?
a probability law pis afunction .
it takes a subset (an element in f) and maps it to a number between 0 and 1.
pis ameasure of the size of a set.
forpto be valid, it must satisfy the axioms of probability .
67chapter 2. probability
figure 2.17: probability is a measure of the size of a set. the probability can be a counter that counts
the number of elements, a ruler that measures the length of an interval, or an integration that measures
the area of a region.
a probability law pis a measure
consider the word “measure” in our slogan: probability is a measure of the size of a set .
depending on the nature of the set, the measure can be a counter, ruler, scale, or even a
stopwatch. so far, all the examples we have seen are based on sets with a finite number of
elements. for these sets, the natural choice of the probability measure is a counter. however,
if the sets are intervals on the real line or regions in a plane, we need a different probability
law to measure their size. let’s look at the examples shown in figure 2.17 .
example 2.30 (finite set) . consider throwing a die, so that
ω ={
,
,
,
,
,
}.
then the probability measure is a counter that reports the number of elements. if
the die is fair, i.e., all the 6 faces have equal probability of happening, then an event
e={
,
}will have a probability p[e] =2
6.
example 2.31 (intervals) . suppose that the sample space is a unit interval ω = [0 ,1].
letebe an event such that e= [a, b] where a, bare numbers in [0 ,1]. then the
probability measure is a ruler that measures the length of the intervals. if all the
numbers on the real line have equal probability of appearing, then p[e] =b−a.
example 2.32 (regions) . suppose that the sample space is the square ω = [ −1,1]×
[−1,1]. let ebe a circle such that e={(x, y)|x2+y2< r2}, where r <1. then the
probability measure is an area measure that returns us the area of e. if we assume
that all coordinates in ω are equally probable, then p[e] =πr2, forr <1.
because probability is a measure of the size of a set, two sets can be compared according
to their probability measures. for example, if ω = {♣,♡,✠}, and if e1={♣} ande2=
{♣,♡}, then one possible pis to assign p[e1] =p[{♣}] =1
3andp[e2] =p[{♣,♡}] = 2/3.
682.2. probability space
in this particular case, we see that e1⊆e2and thus
p[e1]≤p[e2].
let’s now consider the term “size.” notice that the concept of the size of a set is not
limited to the number of elements. a better way to think about size is to imagine that it is
the weight of the set. this might may seem fanciful at first, but it is quite natural. consider
the following example.
example 2.33 . (discrete events with different weights ) suppose we have a sample
space ω = {♣,♡,✠}. let us assign a different probability to each outcome:
p[{♣}] =2
6,p[{♡}] =1
6,p[{✠}] =3
6.
as illustrated in figure 2.18 , since each outcome has a different weight, when de-
termining the probability of a set of outcomes we can add these weights (instead of
counting the number of outcomes). for example, when reporting p[{♣}] we find its
weight p[{♣}] =2
6, whereas when reporting p[{♡,✠}] we find the sum of their weights
p[{♡,✠}] =1
6+3
6=4
6. therefore, the notion of size does not refer to the number of
elements but to the total weight of these elements.
figure 2.18: this example shows the “weights” of three elements in a set. the weights are numbers
between 0 and 1 such that the sum is 1. when applying a probability measure to this set, we sum the
weights for the elements in the events being considered. for example, p[♡,✠] =yellow + green, and
p[♣] =purple.
example 2.34 . (continuous events with different weights ) suppose that the sample
space is an interval, say ω = [ −1,1]. on this interval we define a weighting function
f(x) where f(x0) specifies the weight for x0. because ω is an interval, events defined
on this ω must also be intervals. for example, we can consider two events e1= [a, b]
ande2= [c, d]. the probabilities of these events are p[e1] =rb
af(x)dxandp[e2] =rd
cf(x)dx, as shown in figure 2.19 .
viewing probability as a measure is not just a game for mathematicians; rather, it
has fundamental significance for several reasons. first, it eliminates any dependency on
probability as relative frequency from the frequentist point of view. relative frequency is a
69chapter 2. probability
figure 2.19: if the sample space is an interval on the real line, then the probability of an event is the
area under the curve of the weighting function.
narrowly defined concept that is largely limited to discrete events, e.g., flipping a coin. while
we can assign weights to coin-toss events to deal with those biased coins, the extension to
continuous events becomes problematic. by thinking of probability as a measure, we can
generalize the notion to apply to intervals, areas, volumes, and so on.
second, viewing probability as a measure forces us to disentangle an event from mea-
sures . an event is a subset in the sample space. it has nothing to do with the measure
(e.g., a ruler) you use to measure the event. the measure, on the other hand, specifies the
weighting function you apply to measure the event when computing the probability. for
example, let ω = [ −1,1] be an interval, and let e= [a, b] be an event. we can define two
weighting functions f(x) and g(x). correspondingly, we will have two different probability
measures fandgsuch that
f([a, b]) =z
edf=zb
af(x)dx,
g([a, b]) =z
edg=zb
ag(x)dx. (2.20)
to make sense of these notations, consider only p[[a, b]] and not f([a, b]) and g([a, b]). as you
can see, the event for both measures is e= [a, b] but the measures are different. therefore,
the values of the probability are different.
example 2.35 . (two probability laws are different if their weighting functions are
different .) consider two different weighting functions for throwing a die. the first one
assigns probability as the following:
p[{
}] =1
12,p[{
}] =2
12,p[{
}] =3
12,
p[{
}] =4
12,p[{
}] =1
12,p[{
}] =1
12,
whereas the second function assigns the probability like this:
p[{
}] =2
12,p[{
}] =2
12,p[{
}] =2
12,
p[{
}] =2
12,p[{
}] =2
12,p[{
}] =2
12.
702.2. probability space
let an event e={
,
}. letfbe the measure using the first set of probabilities, and
letgbe the measure of the second set of probabilities. then,
f(e) =f({
,
}) =1
12+2
12=3
12,
g(e) =g({
,
}) =2
12+2
12=4
12.
therefore, although the events are the same, the two different measures will give us
two different probability values.
remark . the notationr
edfin equation (2.20) is known as the lebesgue integral . you
should be aware of this notation, but the theory of lebesgue measure is beyond the scope
of this book.
2.2.4 measure zero sets
understanding the measure perspective on probability allows us to understand another
important concept of probability, namely measure zero sets . to introduce this concept, we
pose the question: what is the probability of obtaining a single point, say {0.5}, when the
sample space is ω = [0 ,1]?
the answer to this question is rooted in the compatibility between the measure and
the sample space. in other words, the measure has to be meaningful for the events in the
sample space. using ω = [0 ,1], since ω is an interval, an appropriate measure would be the
length of this interval. you may add different weighting functions to define your measure,
but ultimately, the measure must be an integral. if you use a “counter” as a measure, then
the counter and the interval are not compatible because you cannot count on the real line.
now, suppose that we define a measure for ω = [0 ,1] using a weighting function f(x).
this measure is determined by an integration. then, for e={0.5}, the measure is
p[e] =p[{0.5}] =z0.5
0.5f(x)dx= 0.
in fact, for any weighting function the integral will be zero because the length of the set
eis zero.1an event that gives us zero probability is known as an event with measure 0 .
figure 2.20 shows an example.
figure 2.20: the probability of obtaining a single point in a continuous interval is zero.
1we assume that fis continuous throughout [0 ,1]. if fis discontinuous at x= 0.5, some additional
considerations will apply.
71chapter 2. probability
what are measure zero sets?
a set e(non-empty) is called a measure zero set when p[e] = 0.
for example, {0}is a measure zero set when we use a continuous measure f.
but{0}can have a positive measure when we use a discrete measure g.
example 2.36(a) . consider a fair die with ω = {
,
,
,
,
,
}. then the set {
}
has a probability of1
6. the sample space does not have a measure zero event because
the measure we use is a counter.
example 2.36(b) . consider an interval with ω = [1 ,6]. then the set {1}has measure
0 because it is an isolated point with respect to the sample space.
example 2.36(c) . for any intervals, p[[a, b]] =p[(a, b)] because the two end points
have measure zero: p[{a}] =p[{b}] = 0.
formal definitions of measure zero sets
the following discussion of the formal definitions of measure zero sets is optional for the
first reading of this book.
we can formally define measure zero sets as follows:
definition 2.19. letωbe the sample space. a set a∈ωis said to have measure
zero if for any given ϵ >0,
there exists a countable number of subsets ansuch that a⊆ ∪∞
n=1an, and
p∞
n=1p[an]< ϵ.
you may need to read this definition carefully. suppose we have an event a. we construct
a set of neighbors a1, . . . , a ∞such that ais included in the union ∪∞
n=1an. if the sum of
the all p[an] is still less than ϵ, then the set awill have a measure zero.
to understand the difference between a measure for a continuous set and a countable
set, consider figure 2.21 . on the left side of figure 2.21 we show an interval ω in which there
is an isolated point x0. the measure for this ω is the length of the interval (relative to what-
ever weighting function you use). we define a small neighborhood a0= (x0−ϵ
2, x0+ϵ
2)
surrounding x0. the length of this interval is not more than ϵ. we then shrink ϵ. how-
ever, regardless of how small ϵis, since x0is an isolated point, it is always included in the
neighborhood. therefore, the definition is satisfied, and so {x0}has measure zero.
example 2.37 . let ω = [0 ,1]. the set {0.5} ⊂ω has measure zero, i.e., p[{0.5}] = 0.
to see this, we draw a small interval around 0.5, say [0 .5−ϵ/3,0.5 +ϵ/3]. inside this
interval, there is really nothing to measure besides the point 0.5. thus we have found
an interval such that it contains 0.5, and the probability is p[[0.5−ϵ/3,0.5 +ϵ/3]] =
722.2. probability space
2ϵ/3< ϵ. therefore, by definition, the set {0.5}has measure 0.
the situation is very different for the right-hand side of figure 2.21 . here, the measure
is not the length but a counter. so if we create a neighborhood surrounding the isolated
point x0, we can always make a count. as a result, if you shrink ϵto become a very small
number (in this case less than1
4), then p[{x0}]< ϵwill no longer be true. therefore, the
set{x0}has a non-zero measure when we use the counter as the measure.
figure 2.21: [left] for a continuous sample space, a single point event {x0}can always be surrounded
by a neighborhood a0whose size p[a0]< ϵ. [right] if you change the sample space to discrete
elements, then a single point event {x0}can still be surrounded by a neighborhood a0. however, the
sizep[a0] = 1/4is a fixed number and will not work for anyϵ.
when we make probabilistic claims without considering the measure zero sets, we say
that an event happens almost surely .
definition 2.20. an event a∈ris said to hold almost surely (a.s.) if
p[a] = 1 (2.21)
except for all measure zero sets in r.
therefore, if a set acontains measure zero subsets, we can simply ignore them because they
do not affect the probability of events. in this book, we will omit “a.s.” if the context is
clear.
example 2.38(a) . let ω = [0 ,1]. then p[(0,1)] = 1 almost surely because the points
0 and 1 have measure zero in ω.
example 2.38(b) . let ω = {x|x2≤1}and let a={x|x2<1}. then p[a] = 1
almost surely because the circumference has measure zero in ω.
practice exercise 2.12 . let ω = {f:r→[−1,1]|f(t) = cos( ω0t+θ)}, where ω0is
a fixed constant and θis random. construct a measure zero event and an almost sure
event.
solution . let
e={f:r→[−1,1]|f(t) = cos( ω0t+kπ/2)}
for any integer k. that is, econtains all the functions with a phase of π/2, 2π/2, 3π/2,
etc. then ewill have measure zero because it is a countable set of isolated functions.
the event ecwill have probability p[ec] = 1 almost surely because ehas measure
73chapter 2. probability
zero.
this is the end of the discussion. please join us again.
2.2.5 summary of the probability space
after the preceding long journey through theory, let us summarize.
first, it is extremely important to understand our slogan: probability is a measure of
the size of a set . this slogan is precise, but it needs clarification. when we say probability
is ameasure , we are thinking of it as being the probability law p. of course, in practice, we
always think of probability as the number returned by the measure. however, the difference
is not crucial. also, “size” not only means the number of elements in the set, but it also
means the relative weight of the set in the sample space. for example, if we use a weight
function to weigh the set elements, then size would refer to the overall weight of the set.
when we put all these pieces together, we can understand why a probability space
must consist of the three components
(ω,f,p), (2.22)
where ω is the sample space that defines all possible outcomes, fis the event space generated
from ω, and pis the probability law that maps an event to a number in [0 ,1]. can we drop
one or more of the three components? we cannot! if we do not specify the sample space ω,
then there is no way to define the events. if we do not have a complete event space f,
then some events will become undefined, and further, if the probability law is applied only
to outcomes, we will not be able to define the probability for events. finally, if we do not
specify the probability law, then we do not have a way to assign probabilities.
2.3 axioms of probability
we now turn to a deeper examination of the properties. our motivation is simple. while
the definition of probability law has achieved its goal of assigning a probability to an event,
there must be restrictions on how the assignment can be made. for example, if we set
p[{h}] = 1 /3, then p[{t}] must be 2 /3; otherwise, the sum of having a head and a tail
will be greater than 1. the necessary restrictions on assigning a probability to an event are
collectively known as the axioms of probability .
definition 2.21. aprobability law is a function p:f → [0,1]that maps an event
ato a real number in [0,1]. the function must satisfy the axioms of probability :
i.non-negativity :p[a]≥0, for any a⊆ω.
ii.normalization :p[ω] = 1 .
742.3. axioms of probability
iii.additivity : for any disjoint sets {a1, a2, . . .}, it must be true that
p"∞[
i=1ai#
=∞x
i=1p[ai]. (2.23)
an axiom is a proposition that serves as a premise or starting point in a logical system.
axioms are not definitions, nor are they theorems. they are believed to be true or true
within a certain context. in our case, the axioms are true within the context of bayesian
probability. the kolmogorov probability relies on another set of axioms. we will not dive
into the details of these historical issues; in this book, we will confine our discussion to the
three axioms given above.
2.3.1 why these three probability axioms?
why do we need three axioms? why not just two axioms? why these three particular
axioms? the reasons are summarized in the box below.
why these three axioms?
axiom i (non-negativity) ensures that probability is never negative.
axiom ii (normalization) ensures that probability is never greater than 1.
axiom iii (additivity) allows us to add probabilities when two events do not
overlap.
axiom i is called the non-negativity axiom. it ensures that a probability value cannot
be negative. non-negativity is a must for probability. it is meaningless to say that the
probability of getting an event is a negative number.
axiom ii is called the normalization axiom. it ensures that the probability of observing
all possible outcomes is 1. this gives the upper limit of the probability. the upper limit
does not have to be 1. it could be 10 or 100. as long as we are consistent about this upper
limit, we are good. however, for historical reasons and convenience, we choose 1 to be the
upper limit.
axiom iii is called the additivity axiom and is the most critical one among the three.
the additivity axiom defines how set operations can be translated into probability oper-
ations. in a nutshell, it says that if we have a set of disjoint events, the probabilities can
be added. from the measure perspective, axiom iii makes sense because if pmeasures the
size of an event, then two disjoint events should have their probabilities added. if two dis-
joint events do not allow their probabilities to be added, then there is no way to measure
a combined event. similarly, if the probabilities can somehow be added even for overlap-
ping events, there will be inconsistencies because there is no systematic way to handle the
overlapping regions.
thecountable additivity stated in axiom iii can be applied to both a finite number
or an infinite number of sets. the finite case states that for any two disjoint sets aandb,
we have
p[a∪b] =p[a] +p[b]. (2.24)
75chapter 2. probability
in other words, if aandbare disjoint, then the probability of observing either aorbis
the sum of the two individual probabilities. figure 2.22 illustrates this idea.
example 2.39 . let’s see why axiom iii is critical. consider throwing a fair die with
ω ={
,
,
,
,
,
}. the probability of getting {
,
}is
p[{
,
}] =p[{
} ∪ {
 }] =p[{
}] +p[{
}] =1
6+1
6=2
6.
in this equation, the second equality holds because the events {
}and{
}are disjoint.
if we do not have axiom iii, then we cannot addprobabilities.
figure 2.22: axiom iii says p[a∪b] =p[a] +p[b]ifa∩b=∅.
2.3.2 axioms through the lens of measure
axioms are “rules” we must abide by when we construct a measure. therefore, any valid
measure must be compatible with the axioms, regardless of whether we have a weighting
function or not. in the following two examples, we will see how the weighting functions are
used in the axioms.
example 2.40 . consider a sample space with ω = {♣,♡,✠}. the probability for
each outcome is
p[{♣}] =2
6,p[{♡}] =1
6,p[{✠}] =3
6.
suppose we construct two disjoint events e1={♣,♡}ande2={✠}. then axiom
iii says
p[e1∪e2] =p[e1] +p[e2] =2
6+1
6
+3
6= 1.
note that in this calculation, the measure pis still a measure p. if we endow it
with a nonuniform weight function, then papplies the corresponding weights to the
corresponding outcomes. this process is compatible with the axioms. see figure 2.23
for a pictorial illustration.
762.3. axioms of probability
example 2.41 . suppose the sample space is an interval ω = [0 ,1]. the two events
aree1= [a, b] and e2= [c, d]. assume that the measure puses a weighting function
f(x). then, by axiom iii, we know that
p[e1∪e2] =p[e1] +p[e2]
=p[[a, b]] +p[[c, d]] (by axiom 3)
=zb
af(x)dx+zd
cf(x)dx, (apply the measure) .
as you can see, there is no conflict between the axioms and the measure. figure 2.24
illustrates this example.
figure 2.23: applying weighting functions to the measures: suppose we have three elements in the set.
to compute the probability p[{♡,✠} ∪ {♣} ], we can write it as the sum of p[{♡,✠}]andp[{♣}].
figure 2.24: the axioms are compatible with the measure, even if we use a weighting function.
2.3.3 corollaries derived from the axioms
the union of aandbis equivalent to the logical operator “or”. once the logical operation
“or” is defined, all other logical operations can be defined. the following corollaries are
examples.
corollary 2.1. leta∈ f be an event. then,
(a)p[ac] = 1−p[a].
(b)p[a]≤1.
(c)p[∅] = 0.
77chapter 2. probability
proof . (a) since ω = a∪ac, by finite additivity we have p[ω] =p[a∪ac] =p[a] +p[ac].
by the normalization axiom, we have p[ω] = 1. therefore, p[ac] = 1−p[a].
(b) we prove by contradiction. assume p[a]>1. consider the complement acwhere
a∪ac= ω. since p[ac] = 1−p[a], we must have p[ac]<0 because by hypothesis p[a]>1.
butp[ac]<0 violates the non-negativity axiom. so we must have p[a]≤1.
(c) since ω = ω ∪ ∅, by the first corollary we have p[∅] = 1−p[ω] = 0.
□
corollary 2.2 (unions of two non-disjoint sets ).for any aandbinf,
p[a∪b] =p[a] +p[b]−p[a∩b]. (2.25)
this statement is different from axiom iii because aandbare not necessarily disjoint.
figure 2.25: for any aandb,p[a∪b] =p[a] +p[b]−p[a∩b].
proof . first, observe that a∪bcan be partitioned into three disjoint subsets as a∪b=
(a\b)∪(a∩b)∪(b\a). since a\b=a∩bcandb\a=b∩ac, by finite additivity we
have that
p[a∪b] =p[a\b] +p[a∩b] +p[b\a] =p[a∩bc] +p[a∩b] +p[b∩ac]
(a)=p[a∩bc] +p[a∩b] +p[b∩ac] +p[a∩b]−p[a∩b]
(b)=p[a∩(bc∪b)] +p[(ac∪a)∩b]−p[a∩b]
=p[a∩ω] +p[ω∩b]−p[a∩b] =p[a] +p[b]−p[a∩b],
where in (a) we added and subtracted a term p[a∩b], and in (b) we used finite additivity
so that p[a∩bc] +p[a∩b] =p[(a∩bc)∪(a∩b)] =p[a∩(bc∪b)].
□
example 2.42 . the corollary is easy to understand if we consider the following ex-
ample. let ω = {
,
,
,
,
,
}be the sample space of a fair die. let a={
,
,
}
andb={
,
,
}. then
p[a∪b] =p[{
,
,
,
,
}] =5
6.
782.3. axioms of probability
we can also use the corollary to obtain the same result:
p[a∪b] =p[a] +p[b]−p[a∩b]
=p[{
,
,
}] +p[{
,
,
}]−p[{
}]
=3
6+3
6−1
6=5
6.
corollary 2.3 (inequalities) .letaandbbe two events in f. then,
(a)p[a∪b]≤p[a] +p[b]. (union bound)
(b) if a⊆b, then p[a]≤p[b].
proof . (a) since p[a∪b] =p[a]+p[b]−p[a∩b] and by non-negativity axiom p[a∩b]≥0,
we must have p[a∪b]≤p[a] +p[b]. (b) if a⊆b, then there exists a set b\asuch that
b=a∪(b\a). therefore, by finite additivity we have p[b] =p[a]+p[b\a]≥p[a]. since
p[b\a]≥0, it follows that p[a] +p[b\a]≥p[a]. thus we have p[b]≥p[a].
□
union bound is a frequently used tool for analyzing probabilities when the intersection
a∩bis difficult to evaluate. part (b) is useful when considering two events of different
“sizes.” for example, in the bus-waiting example, if we let a={t≤5}, and b={t≤10},
thenp[a]≤p[b] because we have to wait for the first 5 minutes to go into the remaining
5 minutes.
practice exercise 2.13 . let the events aandbhavep[a] =x,p[b] =yand
p[a∪b] =z. find the following probabilities: p[a∩b],p[ac∪bc], and p[a∩bc].
solution .
(a) note that z=p[a∪b] =p[a] +p[b]−p[a∩b]. thus, p[a∩b] =x+y−z.
(b) we can take the complement to obtain the result:
p[ac∪bc] = 1−p[(ac∪bc)c] = 1−p[a∩b] = 1−x−y+z.
(c)p[a∩bc] =p[a]−p[a∩b] =x−(x+y−z) =z−y.
practice exercise 2.14 . consider a sample space
ω ={f:r→r|f(x) =ax,for all a∈r, x∈r}.
there are two events: a={f|f(x) =ax, a ≥0}, and b={f|f(x) =ax, a ≤0}.
so, basically, ais the set of all straight lines with positive slope, and bis the set of
straight lines with negative slope. show that the union bound is tight.
79chapter 2. probability
solution . first of all, we note that
p[a∪b] =p[a] +p[b]−p[a∩b].
the intersection is
p[a∩b] =p[{f|f(x) = 0}].
since this is a point set in the real line, it has measure zero. thus, p[a∩b] = 0 and
hence p[a∪b] =p[a] +p[b]. so the union bound is tight.
closing remark . the development of today’s probability theory is generally credited to
andrey kolmogorov’s 1933 book foundations of the theory of probability . we close this
section by citing one of the tables of the book. the table summarizes the correspondence
between set theory and random events.
theory of sets random events
aandbare disjoint, i.e., a∩b=∅events aandbare incompatible
a1∩a2··· ∩ an=∅ events a1, . . . , a nare incompatible
a1∩a2··· ∩ an=x event xis defined as the simultaneous occur-
rence of events a1, . . . , a n
a1∪a2··· ∪ an=x event xis defined as the occurrence of at least
one of the events a1, . . . , a n
acthe opposite event acconsisting of the non-
occurrence of event a
a=∅ event ais impossible
a= ω event amust occur
a1, . . . , a nform a partition of ω the experiment consists of determining which
of the events a1, . . . , a noccurs
b⊂a from the occurrence of event bfollows the
inevitable occurrence of a
table 2.2: kolmogorov’s summary of set theory results and random events.
2.4 conditional probability
in many practical data science problems, we are interested in the relationship between two
or more events. for example, an event amay cause bto happen, and bmay cause c
to happen. a legitimate question in probability is then: if ahas happened, what is the
probability that balso happens? of course, if aandbare correlated events, then knowing
one event can tell us something about the other event. if the two events have no relationship,
knowing one event will not tell us anything about the other.
in this section, we study the concept of conditional probability . there are three sub-
topics in this section. we summarize the key points below.
802.4. conditional probability
the three main messages of this section are:
section 2.4.1: conditional probability . conditional probability of agiven bis
p[a|b] =p[a∩b]
p[b].
section 2.4.2: independence . two events are independent if the occurrence of
one does not influence the occurrence of the other: p[a|b] =p[a].
section 2.4.3: bayes’ theorem and the law of total probability . bayes’ theorem
allows us to switch the order of the conditioning: p[a|b] vs.p[b|a], whereas the
law of total probability allows us to decompose an event into smaller events.
2.4.1 definition of conditional probability
we start by defining conditional probability .
definition 2.22. consider two events aandb. assume p[b]̸= 0. the conditional
probability ofagiven bis
p[a|b]def=p[a∩b]
p[b]. (2.26)
according to this definition, the conditional probability of agiven bis the ratio of
p[a∩b] top[b]. it is the probability that ahappens when we know that bhas already
happened. since bhas already happened, the event that ahas also happened is represented
bya∩b. however, since we are only interested in the relative probability of awith respect
tob, we need to normalize using b. this can be seen by comparing p[a|b] andp[a∩b]:
p[a|b] =p[a∩b]
p[b]andp[a∩b] =p[a∩b]
p[ω]. (2.27)
the difference is illustrated in figure 2.26 : the intersection p[a∩b] calculates the overlap-
ping area of the two events. we make no assumptions about the cause-effect relationship.
figure 2.26: illustration of conditional probability and its comparison with p[a∩b].
what justifies this ratio? suppose that bhas already happened. then, anything out-
sidebwill immediately become irrelevant as far as the relationship between aandbis
concerned. so when we ask: “what is the probability that ahappens given that bhas
happened?”, we are effectively asking for the probability that a∩bhappens under the
81chapter 2. probability
condition that bhas happened. note that we need to consider a∩bbecause we know
that bhas already happened. if we take aonly, then there exists a region a\bwhich
does not contain anything about b. however, since we know that bhas happened, a\bis
impossible. in other words, among the elements of a, only those that appear in a∩bare
meaningful.
example 2.43 . let
a={purdue gets big ten championship },
b={purdue wins 15 games consecutively }.
in this example,
p[a] = prob. that purdue gets the championship ,
p[b] = prob. that purdue wins 15 games consecutively ,
p[a∩b] = prob. that purdue gets the championship and wins 15 games ,
p[a|b] = prob. that purdue gets the championship given that
purdue won 15 games .
if purdue has won 15 games consecutively, then it is unlikely that purdue will get
the championship because the sample space of all possible competition results is large.
however, if we have already won 15 games consecutively, then the denominator of the
probability becomes much smaller. in this case, the conditional probability is high.
example 2.44 . consider throwing a die. let
a={getting a 3 }and b={getting an odd number }.
findp[a|b] andp[b|a].
solution . the following probabilities are easy to calculate:
p[a] =p[{
}] =1
6, and p[b] =p[{
,
,
}] =3
6.
also, the intersection is
p[a∩b] =p[{
}] =1
6.
given these values, the conditional probability of agiven bcan be calculated as
p[a|b] =p[a∩b]
p[b]=1
6
3
6=1
3.
in other words, if we know that we have an odd number, then the probability of
obtaining a 3 has to be computed over {
,
,
}, which give us a probability1
3. if we
822.4. conditional probability
do not know that we have an odd number, then the probability of obtaining a 3 has
to be computed from the sample space {
,
,
,
,
,
}, which will give us1
6.
the other conditional probability is
p[b|a] =p[a∩b]
p[a]= 1.
therefore, if we know that we have rolled a 3, then the probability for this number
being an odd number is 1.
example 2.45 . consider the situation shown in figure 2.27 . there are 12 points
with equal probabilities of happening. find the probabilities p[a|b] andp[b|a].
solution . in this example, we can first calculate the individual probabilities:
p[a] =5
12,andp[b] =6
12,andp[a∩b] =2
12.
then the conditional probabilities are
p[a|b] =p[a∩b]
p[b]=2
12
6
12=1
3,
p[b|a] =p[a∩b]
p[a]=2
12
5
12=2
5.
figure 2.27: visualization of example 2.45: [left] all the sets. [middle] p(a|b)is the ratio between
dots inside the light yellow region over those in yellow, which is2
6. [right] p[a|b]is the ratio between
dots inside the light pink region over those in pink, which is2
5.
example 2.46 . consider a tetrahedral (4-sided) die. let xbe the first roll and y
be the second roll. let bbe the event that min( x, y) = 2 and mbe the event that
max( x, y) = 3. find p[m|b].
solution . as shown in figure 2.28 , the event bis highlighted in green. (why?)
similarly, the event mis highlighted in blue. (again, why?) therefore, the probability
83chapter 2. probability
is
p[m|b] =p[m∩b]
p[b]=2
16
5
16=2
5.
figure 2.28: visualization of example 2.46. [left] event b. [middle] event m. [right] p(m|b)is the
ratio of the number of blue squares inside the green region to the total number of green squares, which
is2
5.
remark . notice that if p[b]≤p[ω], then p[a|b] is always larger than or equal to p[a∩b],
i.e.,
p[a|b]≥p[a∩b].
conditional probabilities are legitimate probabilities
conditional probabilities are legitimate probabilities. that is, given b, the probability
p[a|b] satisfies axioms i, ii, iii.
theorem 2.6. letp[b]>0. the conditional probability p[a|b]satisfies axioms i,
ii, and iii.
proof . let’s check the axioms:
axiom i: we want to show
p[a|b] =p[a∩b]
p[b]≥0.
sincep[b]>0 and axiom i requires p[a∩b]≥0, we therefore have p[a|b]≥0.
axiom ii:
p[ω|b] =p[ω∩b]
p[b]
=p[b]
p[b]= 1.
842.4. conditional probability
axiom iii: consider two disjoint sets aandc. then,
p[a∪c|b] =p[(a∪c)∩b]
p[b]
=p[(a∩b)∪(c∩b)]
p[b]
(a)=p[a∩b]
p[b]+p[c∩b]
p[b]
=p[a|b] +p[c|b],
where ( a) holds because if aandcare disjoint then ( a∩b)∩(c∩b) =∅.
□
to summarize this subsection, we highlight the essence of conditional probability.
what are conditional probabilities?
conditional probability of agiven bis the ratiop[a∩b]
p[b].
it is again a measure . it measures the relative size of ainside b.
because it is a measure, it must satisfy the three axioms.
2.4.2 independence
conditional probability deals with situations where two events aandbare related. what
if the two events are unrelated? in probability, we have a technical term for this situation:
statistical independence .
definition 2.23. two events aandbare statistically independent if
p[a∩b] =p[a]p[b]. (2.28)
why define independence in this way? recall that p[a|b] =p[a∩b]
p[b]. ifaandbare
independent, then p[a∩b] =p[a]p[b] and so
p[a|b] =p[a∩b]
p[b]=p[a]p[b]
p[b]=p[a]. (2.29)
this suggests an interpretation of independence: if the occurrence of bprovides no addi-
tional information about the occurrence of a, then aandbare independent.
therefore, we can define independence via conditional probability:
definition 2.24. letaandbbe two events such that p[a]>0andp[b]>0. then
85chapter 2. probability
aandbareindependent if
p[a|b] =p[a]orp[b|a] =p[b]. (2.30)
the two statements are equivalent as long as p[a]>0 and p[b]>0. this is because
p[a|b] =p[a∩b]/p[b]. ifp[a|b] =p[a] then p[a∩b] =p[a]p[b], which implies that
p[b|a] =p[a∩b]/p[a] =p[b].
a pictorial illustration of independence is given in figure 2.29 . the key message is that
if two events aandbare independent, then p[a|b] =p[a]. the conditional probability
p[a|b] is the ratio of p[a∩b] over p[b], which is the intersection over b(the blue set).
the probability p[a] is the yellow set over the sample space ω.
figure 2.29: independence means that the conditional probability p[a|b]is the same as p[a]. this
implies that the ratio of p[a∩b]overp[b], and the ratio of p[a∩ω]overp[ω]are the same.
disjoint versus independent
disjoint ⇎independent . (2.31)
the statement says that disjoint and independent are two completely different concepts.
ifaandbare disjoint, then a∩b=∅. this only implies that p[a∩b] = 0.
however, it says nothing about whether p[a∩b] can be factorized into p[a]p[b]. ifa
andbare independent, then we have p[a∩b] =p[a]p[b]. but this does not imply that
p[a∩b] = 0. the only condition under which disjoint ⇔independence is when p[a] = 0 or
p[b] = 0. figure 2.30 depicts the situation. when two sets are independent, the conditional
probability (which is a ratio) remains unchanged compared to unconditioned probability.
when two sets are disjoint, they simply do not overlap.
practice exercise 2.15 . throw a die twice. are aandbindependent, where
a={1st die is 3 }and b={2nd die is 4 }.
solution . we can show that
p[a∩b] =p[(3,4)] =1
36,p[a] =1
6,andp[b] =1
6.
sop[a∩b] =p[a]p[b]. thus, aandbare independent.
862.4. conditional probability
figure 2.30: independent means that the conditional probability, which is a ratio, is the same as the
unconditioned probability. disjoint means that the two sets do not overlap.
figure 2.31: the two events aandbare independent because p[a] =1
6andp[a|b] =1
6.
a pictorial illustration of this example is shown in figure 2.31 . the two events are
independent because ais one row in the 2d space, which yields a probability of1
6. the
conditional probability p[a|b] is the coordinate (3 ,4) over the event b, which is a column.
it happens that p[a|b] =1
6. thus, the two events are independent.
practice exercise 2.16 . throw a die twice. are aandbindependent?
a={1st die is 3 }and b={sum is 7 }.
solution . note that
p[a∩b] =p[(3,4)] =1
36, p[a] =1
6,
p[b] =p[(1,6),(2,5),(3,4),(4,3),(5,2),(6,1)] =1
6.
sop[a∩b] =p[a]p[b]. thus, aandbare independent.
a pictorial illustration of this example is shown in figure 2.32 . notice that whether the
two events intersect is not how we determine independence (that only determines disjoint or
87chapter 2. probability
not). the key is whether the conditional probability (which is the ratio) remains unchanged
compared to the unconditioned probability.
figure 2.32: the two events aandbare independent because p[a] =1
6andp[a∩b] =1
6.
if we let b={sum is 8 }, then the situation is different. the intersection a∩bhas a
probability1
5relative to b, and therefore p[a|b] =1
5. hence, the two events aandbare
dependent. if you like a more intuitive argument, you can imagine that bhas happened,
i.e., the sum is 8. then the probability for the first die to be 1 is 0 because there is no way
to construct 8 when the first die is 1. as a result, we have eliminated one choice for the first
die, leaving only five options. therefore, since bhas influenced the probability of a, they
are dependent.
practice exercise 2.17 . throw a die twice. let
a={max is 2 }and b={min is 2 }.
areaandbindependent?
solution . let us first list out aandb:
a={(1,2),(2,1),(2,2)},
b={(2,2),(2,3),(2,4),(2,5),(2,6),(3,2),(4,2),(5,2),(6,2)}.
therefore, the probabilities are
p[a] =3
36,p[b] =9
36,andp[a∩b] =p[(2,2)] =1
36.
clearly, p[a∩b]̸=p[a]p[b] and so aandbare dependent.
what is independence?
two events are independent when the ratiop[a∩b]/p[b]remains unchanged
compared to p[a].
independence ̸= disjoint.
882.4. conditional probability
2.4.3 bayes’ theorem and the law of total probability
theorem 2.7 (bayes’ theorem ).for any two events aandbsuch that p[a]>0
andp[b]>0,
p[a|b] =p[b|a]p[a]
p[b].
proof . by the definition of conditional probabilities, we have
p[a|b] =p[a∩b]
p[b]andp[b|a] =p[b∩a]
p[a].
rearranging the terms yields
p[a|b]p[b] =p[b|a]p[a],
which gives the desired result by dividing both sides by p[b].
□
bayes’ theorem provides two views of the intersection p[a∩b] using two different con-
ditional probabilities. we call p[b|a] the conditional probability andp[a|b] the posterior
probability . the order of aandbis arbitrary. we can also call p[a|b] the conditional
probability and p[b|a] the posterior probability. the context of the problem will make this
clear.
bayes’ theorem provides a way to switch p[a|b] andp[b|a]. the next theorem helps
us decompose an event into smaller events.
theorem 2.8 (law of total probability ).let{a1, . . . , a n}be a partition of ω, i.e.,
a1, . . . , a nare disjoint and ω =a1∪ ··· ∪ an. then, for any b⊆ω,
p[b] =nx
i=1p[b|ai]p[ai]. (2.32)
proof . we start from the right-hand side.
nx
i=1p[b|ai]p[ai](a)=nx
i=1p[b∩ai](b)=p"n[
i=1(b∩ai)#
(c)=p"
b∩ n[
i=1ai!#
(d)=p[b∩ω] =p[b],
where ( a) follows from the definition of conditional probability, ( b) is due to axiom iii, ( c)
holds because of the distributive property of sets, and ( d) results from the partition property
of{a1, a2, . . . , a n}.
□
interpretation . the law of total probability can be understood as follows. if the sample
space ω consists of disjoint subsets a1, . . . , a n, we can compute the probability p[b] by
89chapter 2. probability
summing over its portion p[b∩a1], . . . ,p[b∩an]. however, each intersection can be written
as
p[b∩ai] =p[b|ai]p[ai]. (2.33)
in other words, we write p[b∩ai] as the conditional probability p[b|ai] times the prior
probability p[ai]. when we sum all these intersections, we obtain the overall probability.
seefigure 2.33 for a graphical portrayal.
figure 2.33: the law of total probability decomposes the probability p[b]into multiple conditional
probabilities p[b|ai]. the probability of obtaining each p[b|ai]isp[ai].
corollary 2.4. let{a1, a2, . . . , a n}be a partition of ω, i.e., a1, . . . , a nare disjoint
andω =a1∪a2∪ ··· ∪ an. then, for any b⊆ω,
p[aj|b] =p[b|aj]p[aj]pn
i=1p[b|ai]p[ai]. (2.34)
proof . the result follows directly from bayes’ theorem:
p[aj|b] =p[b|aj]p[aj]
p[b]=p[b|aj]p[aj]pn
i=1p[b|ai]p[ai].
□
example 2.47 . suppose there are three types of players in a tennis tournament: a,
b, and c. fifty percent of the contestants in the tournament are aplayers, 25% are
bplayers, and 25% are cplayers. your chance of beating the contestants depends on
the class of the player, as follows:
0.3 against an aplayer
0.4 against a bplayer
0.5 against a cplayer
if you play a match in this tournament, what is the probability of your winning the
match? supposing that you have won a match, what is the probability that you played
against an aplayer?
solution . we first list all the known probabilities. we know from the percentage
902.4. conditional probability
of players that
p[a] = 0.5,p[b] = 0.25,p[c] = 0.25.
now, let wbe the event that you win the match. then the conditional probabilities
are defined as follows:
p[w|a] = 0.3,p[w|b] = 0.4,p[w|c] = 0.5.
therefore, by the law of total probability, we can show that the probability of
winning the match is
p[w] =p[w|a]p[a] +p[w|b]p[b] +p[w|c]p[c]
= (0.3)(0.5) + (0 .4)(0.25) + (0 .5)(0.25) = 0 .375.
given that you have won the match, the probability of agiven wis
p[a|w] =p[w|a]p[a]
p[w]=(0.3)(0.5)
0.375= 0.4.
example 2.48 . consider the communication channel shown below. the probability
of sending a 1 is pand the probability of sending a 0 is 1 −p. given that 1 is sent, the
probability of receiving 1 is 1 −η. given that 0 is sent, the probability of receiving 0
is 1−ε. find the probability that a 1 has been correctly received.
solution . define the events
s0= “0 is sent” ,and r0= “0 is received” .
s1= “1 is sent” ,and r1= “1 is received” .
then, the probability that 1 is received is p[r1]. however, p[r1]̸= 1−ηbecause 1 −η
91chapter 2. probability
is the conditional probability that 1 is received given that 1 is sent. it is possible that
we receive 1 as a result of an error when 0 is sent. therefore, we need to consider the
probability that both s0ands1occur. using the law of total probability we have
p[r1] =p[r1|s1]p[s1] +p[r1|s0]p[s0]
= (1−η)p+ε(1−p).
now, suppose that we have received 1. what is the probability that 1 was origi-
nally sent? this is asking for the posterior probability p[s1|r1], which can be found
using bayes’ theorem
p[s1|r1] =p[r1|s1]p[s1]
p[r1]=(1−η)p
(1−η)p+ε(1−p).
when do we need to use bayes’ theorem and the law of total probability?
bayes’ theorem switches the role of the conditioning, from p[a|b] top[b|a].
example:
p[win the game |play with a] and p[play with a |win the game] .
the law of total probability decomposes an event into smaller events.
example:
p[win] = p[win|a]p[a] +p[win|b]p[b].
2.4.4 the three prisoners problem
now that you are familiar with the concepts of conditional probabilities, we would like to
challenge you with the following problem, known as the three prisoners problem . if you
understand how this problem can be resolved, you have mastered conditional probability.
once upon a time, there were three prisoners a,b, and c. one day, the king decided
to pardon two of them and sentence the last one, as in this figure:
figure 2.34: the three prisoners problem: the king says that he will pardon two prisoners and sentence
one.
one of the prisoners, prisoner a, heard the news and wanted to ask a friendly guard
about his situation. the guard was honest. he was allowed to tell prisoner athat prisoner b
would be pardoned or that prisoner cwould be pardoned, but he could not tell awhether
he would be pardoned. prisoner athought about the problem, and he began to hesitate to
ask the guard. based on his present state of knowledge, his probability of being pardoned
922.4. conditional probability
is2
3. however, if he asks the guard, this probability will be reduced to1
2because the guard
would tell him that one of the two other prisoners would be pardoned, and would tell him
which one it would be. prisoner a reasons that his chance of being pardoned would then
drop because there are now only two prisoners left who may be pardoned, as illustrated in
figure 2.35 :
figure 2.35: the three prisoners problem: if you do not ask the guard, your chance of being released
is 2/3. if you ask the guard, the guard will tell you which one of the other prisoners will be released.
your chance of being released apparently drops to 1/2.
should prisoner aask the guard? what has gone wrong with his reasoning? this
problem is tricky in the sense that the verbal argument of prisoner aseems flawless. if
he asked the guard, indeed, the game would be reduced to two people. however, this does
not seem correct, because regardless of what the guard says, the probability for ato be
pardoned should remain unchanged. let’s see how we can solve this puzzle.
letxa,xb,xcbe the events of sentencing prisoners a,b,c, respectively. let gb
be the event that the guard says that the prisoner bis released. without doing anything,
we know that
p[xa] =1
3,p[xb] =1
3,p[xc] =1
3.
conditioned on these events, we can compute the following conditional probabilities that
the guard says bis pardoned:
p[gb|xa] =1
2,p[gb|xb] = 0,p[gb|xc] = 1.
why are these conditional probabilities? p[gb|xb] = 0 quite straightforward. if the king
decides to sentence b, the guard has no way of saying that bwill be pardoned. therefore,
p[gb|xb] must be zero. p[gb|xc] = 1 is also not difficult. if the king decides to
sentence c, then the guard has no way to tell you that bwill be pardoned because the
guard cannot say anything about prisoner a. finally, p[gb|xa] =1
2can be understood
as follows: if the king decides to sentence a, the guard can either tell you borc. in other
words, the guard flips a coin.
with these conditional probabilities ready, we can determine the probability. this is the
conditional probability p[xa|gb]. that is, supposing that the guard says bis pardoned,
what is the probability that awill be sentenced? this is the actual scenario that ais facing.
solving for this conditional probability is not difficult. by bayes’ theorem we know that
p[xa|gb] =p[gb|xa]p[xa]
p[gb],
93chapter 2. probability
andp[gb] =p[gb|xa]p[xa] +p[gb|xb]p[xb] +p[gb|xc]p[xc] according to the law of
total probability. substituting the numbers into these equations, we have that
p[gb] =p[gb|xa]p[xa] +p[gb|xb]p[xb] +p[gb|xc]p[xc]
=1
2×1
3+ 0×1
3+ 1×1
3=1
2,
p[xa|gb] =p[gb|xa]p[xa]
p[gb]=1
2×1
3
1
2=1
3.
therefore, given that the guard says bis pardoned, the probability that awill be sentenced
remains1
3. in fact, what you can show in this example is that p[xa|gb] =1
3=p[xa].
therefore, the presence or absence of the guard does not alter the probability. this is because
what the guard says is independent of whether the prisoners will be pardoned. the lesson
we learn from this problem is not to rely on verbal arguments. we need to write down the
conditional probabilities and spell out the steps.
figure 2.36: the three prisoners problem is resolved by noting that p[xa|gb] =p[xa]. therefore,
the events xaandgbare independent.
how to resolve the three prisoners problem?
the key is that ga,gb,gcdo not form a partition . see figure 2.36 .
gb̸=xb. when gbhappens, the remaining set is not xa∪xc.
the ratio p[xa∩gb]/p[gb] equals p[xa]. this is independence .
942.5. summary
2.5 summary
by now, we hope that you have become familiar with our slogan probability is a measure
of the size of a set . let us summarize:
probability = a probability law p. you can also view it as the value returned by p.
measure = a ruler, a scale, a stopwatch, or another measuring device. it is a tool that
tells you how large or small a set is. the measure has to be compatible with the set.
if a set is finite, then the measure can be a counter. if a set is a continuous interval,
then the measure can be the length of the interval.
size = the relative weight of the set for the sample space. measuring the size is done
by using a weighting function. think of a fair coin versus a biased coin. the former
has a uniform weight, whereas the latter has a nonuniform weight.
set= an event. an event is a subset in the sample space. a probability law palways
maps a setto a number. this is different from a typical function that maps a number
to another number.
if you understand what this slogan means, you will understand why probability can be
applied to discrete events, continuous events, events in n-d spaces, etc. you will also under-
stand the notion of measure zero and the notion of almost sure . these concepts lie at the
foundation of modern data science, in particular, theoretical machine learning.
the second half of this chapter discusses the concept of conditional probability . con-
ditional probability is a metaconcept that can be applied to any measure you use. the
motivation of conditional probability is to restrict the probability to a subevent happening
in the sample space. if bhas happened, the probability for atoalsohappen is p[a∩b]/p[b].
if two events are not influencing each other, then we say that aandbare independent.
according to bayes’ theorem, we can also switch the order of agiven bandbgiven a, ac-
cording to bayes’ theorem. finally, the law of total probability gives us a way to decompose
events into subevents.
we end this chapter by mentioning a few terms related to conditional probabilities
that will become useful later. let us use the tennis tournament as an example:
p[w|a] =conditional probability = given that you played with player a, what is
the probability that you will win?
p[a] =prior probability = without even entering the game, what is the chance that
you will face player a?
p[a|w] =posterior probability = after you have won the game, what is the proba-
bility that you have actually played with a?
in many practical engineering problems, the question of interest is often the last one. that
is, supposing that you have observed something, what is the most likely cause of that event?
for example, supposing we have observed this particular dataset, what is the best gaussian
model that would fit the dataset? questions like these require some analysis of conditional
probability, prior probability, and posterior probability.
95chapter 2. probability
2.6 references
introduction to probability
2-1 dimitri p. bertsekas and john n. tsitsiklis, introduction to probability , athena sci-
entific, 2nd edition, 2008. chapter 1.
2-2 mark d. ward and ellen gundlach, introduction to probability , w.h. freeman and
company, 2016. chapter 1 – chapter 6.
2-3 roy d. yates and david j. goodman, probability and stochastic processes , 3rd edi-
tion, wiley 2013, chapter 1.
2-4 john a. gubner, probability and random processes for electrical and computer en-
gineers , cambridge university press, 2006. chapter 2.
2-5 sheldon ross, a first course in probability , prentice hall, 8th edition, 2010. chapter
2 and chapter 3.
2-6 ani adhikari and jim pitman, probability for data science ,http://prob140.org/
textbook/content/readme.html . chapters 1 and 2.
2-7 alberto leon-garcia, probability, statistics, and random processes for electrical en-
gineering , prentice hall, 3rd edition, 2008. chapter 2.1 – 2.7.
2-8 athanasios papoulis and s. unnikrishna pillai, probability, random variables and
stochastic processes , mcgraw-hill, 4th edition, 2001. chapter 2.
2-9 henry stark and john woods, probability and random processes with applications
to signal processing , prentice hall, 3rd edition, 2001. chapter 1.
measure-theoretic probability
2-10 alberto leon-garcia, probability, statistics, and random processes for electrical en-
gineering , prentice hall, 3rd edition, 2008. chapter 2.8 and 2.9.
2-11 henry stark and john woods, probability and random processes with applications
to signal processing , prentice hall, 3rd edition, 2001. appendix d.
2-12 william feller, an introduction to probability theory and its applications , wiley and
sons, 3rd edition, 1950.
2-13 andrey kolmogorov, foundations of the theory of probability , 2nd english edition,
dover 2018. (translated from russian to english. originally published in 1950 by
chelsea publishing company new york.)
2-14 patrick billingsley, probability and measure , wiley, 3rd edition, 1995.
real analysis
2-15 tom m. apostol, mathematical analysis , pearson, 1974.
2-16 walter rudin, principles of mathematical analysis , mcgraw hill, 1976.
962.7. problems
2.7 problems
exercise 1.
a space sand three of its subsets are given by s={1,3,5,7,9,11},a={1,3,5},b=
{7,9,11}, and c={1,3,9,11}. find a∩b∩c,ac∩b,a−c, and ( a−b)∪b.
exercise 2.
leta= (−∞, r] and b= (−∞, s] where r≤s. find an expression for c= (r, s] in terms
ofaandb. show that b=a∪c, and a∩c=∅.
exercise 3. (video solution)
simplify the following sets.
(a) [1 ,4]∩([0,2]∪[3,5])
(b) ([0 ,1]∪[2,3])c
(c)t∞
i=1(−1/n,+1/n)
(d)s∞
i=1[5,8−(2n)−1]
exercise 4.
we will sometimes deal with the relationship between two sets. we say that aimplies b
when ais a subset of b(why?). show the following results.
(a) show that if aimplies b, and bimplies c, then aimplies c.
(b) show that if aimplies b, then bcimplies ac.
exercise 5.
show that if a∪b=aanda∩b=a, then a=b.
exercise 6.
a space sis defined as s={1,3,5,7,9,22}, and three subsets as a={1,3,5},b=
{7,9,11},c={1,3,9,11}. assume that each element has probability 1 /6. find the following
probabilities:
(a)p[a]
(b)p[b]
(c)p[c]
(d)p[a∪b]
(e)p[a∪c]
(f)p[(a\c)∪b]
97chapter 2. probability
exercise 7. (video solution)
a collection of 26 letters, a-z, is mixed in a jar. two letters are drawn at random, one after
the other. what is the probability of drawing a vowel (a,e,i,o,u) and a consonant in either
order? what is the sample space?
exercise 8.
consider an experiment consisting of rolling a die twice. the outcome of this experiment is
an ordered pair whose first element is the first value rolled and whose second element is the
second value rolled.
(a) find the sample space.
(b) find the set arepresenting the event that the value on the first roll is greater than
or equal to the value on the second roll.
(c) find the set bcorresponding to the event that the first roll is a six.
(d) let ccorrespond to the event that the first valued rolled and the second value rolled
differ by two. find a∩c.
note that a,b, and cshould be subsets of the sample space specified in part (a).
exercise 9.
a pair of dice are rolled.
(a) find the sample space ω
(b) find the probabilities of the events: (i) the sum is even, (ii) the first roll is equal to
the second, (iii) the first roll is larger than the second.
exercise 10.
leta,bandcbe events in an event space. find expressions for the following:
(a) exactly one of the three events occurs.
(b) exactly two of the events occurs.
(c) two or more of the events occur.
(d) none of the events occur.
exercise 11.
a system is composed of five components, each of which is either working or failed. consider
an experiment that consists of observing the status of each component, and let the outcomes
of the experiment be given by all vectors ( x1, x2, x3, x4, x5), where xiis 1 if component iis
working and 0 if component iis not working.
(a) how many outcomes are in the sample space of this experiment?
(b) suppose that the system will work if components 1 and 2 are both working, or if
components 3 and 4 are both working, or if components 1, 3, and 5 are all working.
letwbe the event that the system will work. specify all of the outcomes in w.
982.7. problems
(c) let abe the event that components 4 and 5 have both failed. how many outcomes
are in the event a?
(d) write out all outcomes in the event a∩w.
exercise 12. (video solution)
a number xis selected at random in the interval [ −1,2]. let the events a={x|x <0},
b={x||x−0.5|<0.5},c={x|x >0.75}. find (a) p[a|b], (b)p[b|c], (c)p[a|cc],
(d)p[b|cc].
exercise 13. (video solution)
let the events aandbhavep[a] =x,p[b] =yandp[a∪b] =z. find the following
probabilities: (a) p[a∩b], (b)p[ac∩bc], (c)p[ac∪bc], (d)p[a∩bc], (e)p[ac∪b].
exercise 14.
(a) by using the fact that p[a∪b]≤p[a]+p[b], show that p[a∪b∪c]≤p[a]+p[b]+
p[c].
(b) by using the fact that p[sn
k=1ak]≤pn
k=1p[ak], show that
p"n\
k=1ak#
≥1−nx
k=1p[ac
k].
exercise 15.
use the distributive property of set operations to prove the following generalized distributive
law:
a∪ n\
i=1bi!
=n\
i=1(a∪bi).
hint: use mathematical induction. that is, show that the above is true for n= 2 and that
it is also true for n=k+ 1 when it is true for n=k.
exercise 16.
the following result is known as the bonferroni’s inequality.
(a) prove that for any two events aandb, we have
p(a∩b)≥p(a) +p(b)−1.
(b) generalize the above to the case of nevents a1, a2, . . . , a n, by showing that
p(a1∩a2∩ ··· ∩ an)≥p(a1) +p(a2) +···+p(an)−(n−1).
hint: you may use the generalized union bound p(sn
i=1ai)≤pn
i=1p(ai).
exercise 17. (video solution)
leta,b,cbe events with probabilities p[a] = 0.5,p[b] = 0.2,p[c] = 0.4. find
99chapter 2. probability
(a)p[a∪b] ifaandbare independent.
(b)p[a∪b] ifaandbare disjoint.
(c)p[a∪b∪c] ifa,bandcare independent.
(d)p[a∪b∪c] ifa,bandcare pairwise disjoint; can this happen?
exercise 18. (video solution)
a block of information is transmitted repeated over a noisy channel until an error-free block
is received. let m≥1 be the number of blocks required for a transmission. define the
following sets.
(i)a={mis even }
(ii)b={mis a multiple of 3 }
(iii)c={mis less than or equal to 6 }
assume that the probability of requiring one additional block is half of the probability
without the additional block. that is:
p[m=k] =1
2k
, k = 1,2, . . . .
determine the following probabilities.
(a)p[a],p[b],p[c],p[cc]
(b)p[a∩b],p[a\b],p[a∩b∩c]
(c)p[a|b],p[b|a]
(d)p[a|b∩c],p[a∩b|c]
exercise 19. (video solution)
a binary communication system transmits a signal xthat is either a +2-voltage signal or
a−2-voltage signal. a malicious channel reduces the magnitude of the received signal by
the number of heads it counts in two tosses of a coin. let ybe the resulting signal. possible
values of yare listed below.
2 heads 1 head no head
x=−2y= 0 y=−1y=−2
x= +2 y= 0 y= +1 y= +2
assume that the probability of having x= +2 and x=−2 is equal.
(a) find the sample space of y, and hence the probability of each value of y.
(b) what are the probabilities p[x= +2|y= 1] and p[y= 1|x=−2]?
exercise 20. (video solution)
a block of 100 bits is transmitted over a binary communication channel with a probability
of bit error p= 10−2.
1002.7. problems
(a) if the block has 1 or fewer errors, then the receiver accepts the block. find the prob-
ability that the block is accepted.
(b) if the block has more than 1 error, then the block is retransmitted. what is the
probability that 4 blocks are transmitted?
exercise 21. (video solution)
a machine makes errors in a certain operation with probability p. there are two types of
errors. the fraction of errors that are type a is αand the fraction that are type b is 1 −α.
(a) what is the probability of kerrors in noperations?
(b) what is the probability of k1type a errors in noperations?
(c) what is the probability of k2type b errors in noperations?
(d) what is the joint probability of k1type a errors and k2type b errors in noperations?
hint: there are n
k1 n−k1
k2
possibilities of having k1type a errors and k2type b errors
innoperations. (why?)
exercise 22. (video solution)
a computer manufacturer uses chips from three sources. chips from sources a,bandc
are defective with probabilities 0.005, 0.001 and 0.01, respectively. the proportions of chips
from a,bandcare 0.5, 0.1 and 0.4 respectively. if a randomly selected chip is found to
be defective, find
(a) the probability that the chips are from a.
(b) the probability that the chips are from b.
(c) the probability that the chips are from c.
exercise 23. (video solution)
in a lot of 100 items, 50 items are defective. suppose that mitems are selected for testing.
we say that the manufacturing process is malfunctioning if the probability that one or more
items are tested to be defective. call this failure probability p. what should be the minimum
msuch that p≥0.99?
exercise 24. (video solution)
one of two coins is selected at random and tossed three times. the first coin comes up heads
with probability p1= 1/3 and the second coin with probability p2= 2/3.
(a) what is the probability that the number of heads is k= 3?
(b) repeat (a) for k= 0,1,2.
(c) find the probability that coin 1 was tossed given that kheads were observed, for
k= 0,1,2,3.
(d) in part (c), which coin is more probably when 2 heads have been observed?
101chapter 2. probability
exercise 25. (video solution)
consider the following communication channel. a source transmits a string of binary symbols
through a noisy communication channel. each symbol is 0 or 1 with probability pand
1−p, respectively, and is received incorrectly with probability ε0andε1. errors in different
symbols transmissions are independent.
denote sas the source and ras the receiver.
(a) what is the probability that a symbol is correctly received? hint: find
p[r= 1∩s= 1] and p[r= 0∩s= 0].
(b) find the probability of receiving 1011 conditioned on that 1011 was sent, i.e.,
p[r= 1011 |s= 1011] .
(c) to improve reliability, each symbol is transmitted three times, and the received
string is decoded by the majority rule. in other words, a 0 (or 1) is transmitted as
000 (or 111, respectively), and it is decoded at the receiver as a 0 (or 1) if and only if
the received three-symbol string contains at least two 0s (or 1s, respectively). what
is the probability that the symbol is correctly decoded, given that we send a 0?
(d) suppose that the scheme of part (c) is used. what is the probability that a 0 was
sent if the string 101 was received?
(e) suppose the scheme of part (c) is used and given that a 0 was sent. for what value of
ε0is there an improvement in the probability of correct decoding? assume that
ε0̸= 0.
102chapter 3
discrete random variables
when working on a data analysis problem, one of the biggest challenges is the disparity
between the theoretical tools we learn in school and the actual data our boss hands to us.
by actual data, we mean a collection of numbers, perhaps organized or perhaps not. when
we are given the dataset, the first thing we do would certainly not be to define the borel
σ-field and then define the measure. instead, we would normally compute the mean, the
standard deviation, and perhaps some scores about the skewness.
the situation is best explained by the landscape shown in figure 3.1 . on the one hand,
we have well-defined probability tools, but on the other hand, we have a set of practical
“battle skills” for processing data. often we view them as two separate entities. as long as
we can pull the statistics from the dataset, why bother about the theory? alternatively, we
have a set of theories, but we will never verify them using the actual datasets. how can we
bridge the two? what are the missing steps in the probability theory we have learned so
far? the goal of this chapter (and the next) is to fill this gap.
figure 3.1: the landscape of probability and data. often we view probability and data analysis as two
different entities. however, probability and data analysis are inseparable. the goal of this chapter is to
link the two.
three concepts to bridge the gap between theory and practice
the starting point of our discussion is a probability space (ω ,f,p). it is an abstract concept,
but we hope we have convinced you in chapter 2 of its significance. however, the probability
space is certainly not “user friendly” because no one would write a python program to
103chapter 3. discrete random variables
implement those theories. how do we make the abstract probability space more convenient
so that we can model practical scenarios?
the first step is to recognize that the sample space and the event space are all based
onstatements , for example, “getting a head when flipping a coin” or “winning the game.”
these statements are not numbers, but we (engineers) love numbers. therefore, we should
ask a very basic question: how do we convert a statement to a number? the answer is the
concept of random variables .
key concept 1: what are random variables?
random variables are mappings from events to numbers.
now, suppose that we have constructed a random variable that translates statements to
numbers. the next task is to endow the random variable with probabilities. more precisely,
we need to assign probabilities to the random variable so that we can perform computations.
this is done using the concept called probability mass function (pmf).
key concept 2: what are probability mass functions (pmfs)?
probability mass functions are the ideal histograms of random variables.
the best way to think about a pmf is a histogram, something we are familiar with.
a histogram has two axes: the x-axis denotes the set of states and the y-axis denotes
theprobability . for each of the states that the random variable possesses, the histogram
tells us the probability of getting a particular state. the pmf is the ideal histogram of a
random variable. it provides a complete characterization of the random variable. if you have
a random variable, you must specify its pmf. vice versa, if you tell us the pmf, you have
specified a random variable.
we ask the third question about pulling information from the probability mass func-
tion, such as the mean and standard deviation. how do we obtain these numbers from the
pmf? we are also interested in operations on the mean and standard deviations. for ex-
ample, if a professor offers ten bonus points to the entire class, how will it affect the mean
and standard deviation? if a store provides 20% off on all its products, what will happen to
its mean retail price and standard deviation? however, the biggest question is perhaps the
difference between the mean we obtain from a pmf and the mean we obtain from a his-
togram. understanding this difference will immediately help us build a bridge from theory
to practice.
key concept 3: what is expectation?
expectation = mean = average computed from a pmf.
organization of this chapter
the plan for this chapter is as follows. we will start with the basic concepts of random
variables in section 3.1. we will formally define the random variables and discuss their
relationship with the abstract probability space. once this linkage is built, we can put
1043.1. random variables
the abstract probability space aside and focus on the random variables. in section 3.2
we will define the probability mass function (pmf) of a random variable, which tells us
the probability of obtaining a state of the random variable. pmf is closely related to the
histogram of a dataset. we will explain the connection. in section 3.3 we take a small detour
to consider the cumulative distribution functions (cdf). then, we discuss the mean and
standard deviation in section 3.4. section 3.5 details a few commonly used random variables,
including bernoulli, binomial, geometric, and poisson variables.
3.1 random variables
3.1.1 a motivating example
consider an experiment with 4 outcomes ω = {♣,♢,♡,♠}. we want to construct the
probability space (ω ,f,p). the sample space ω is already defined. the event space fis the
set of all possible subsets in ω, which, in our case, is a set of 24subsets. for the probability
lawp, let us assume that the probability of obtaining each outcome is
p[{♣}] =1
6,p[{♢}] =2
6,p[{♡}] =2
6,p[{♠}] =1
6.
therefore, we have constructed a probability space (ω ,f,p) where everything is perfectly
defined. so, in principle, they can live together happily forever.
a lazy data scientist comes, and there is a (small) problem. the data scientist does not
want to write the symbols ♣,♢,♡,♠. there is nothing wrong with his motivation because
all of us want efficiency. how can we help him? well, the easiest solution is to encode each
symbol with a number, for example, ♣ ← 1,♢ ← 2,♡ ← 3,♠ ← 4, where the arrow means
that we assign a number to the symbol. but we can express this more formally by defining
a function x: ω→rwith
x(♣) = 1 , x(♢) = 2 , x(♡) = 3 , x(♠) = 4 .
there is nothing new here: we have merely converted the symbols to numbers, with the help
of a function x. however, with xdefined, the probabilities can be written as
p[x= 1] =1
6,p[x= 2] =2
6,p[x= 3] =2
6,p[x= 4] =1
6.
this is much more convenient, and so the data scientist is happy.
3.1.2 definition of a random variable
the story above is exactly the motivation for random variables. let us define a random
variable formally.
definition 3.1. arandom variable xis a function x: ω→rthat maps an outcome
ξ∈ωto a number x(ξ)on the real line.
105chapter 3. discrete random variables
this definition may be puzzling at first glance. why should we overcomplicate things by
defining a function and calling it a variable ?
if you recall the story above, we can map the notations of the story to the notations
of the definition as follows.
symbol meaning
ω sample space = the set containing ♣,♢,♡,♠
ξ an element in the sample space, which is one of ♣,♢,♡,♠
x a function that maps ♣to the number 1, ♢to the number 2, etc
x(ξ) a number on the real line, e.g., x(♣) = 1
this explains our informal definition of random variables:
key concept 1: what are random variables?
random variables are mappings from events to numbers.
the random variable xis afunction . the input to the function is an outcome of the sample
space, whereas the output is a number on the real line. this type of function is somewhat
different from an ordinary function that often translates a number to another number.
nevertheless, xis a function.
figure 3.2: a random variable is a mapping from the outcomes in the sample space to numbers on the
real line. we can think of a random variable xas a translator that translates a statement to a number.
why do we call this function xavariable ?xis a variable because xhas multiple
states . as we illustrate in figure 3.2 , the mapping xtranslates every outcome ξto a
number. there are multiple numbers, which are the states of x. each state has a certain
probability for xto land on. because xis not deterministic, we call it a random variable.
example 3.1 . suppose we flip a fair coin so that ω = {head,tail}. we can define the
random variable x: ω→ras
x(head) = 1 , and x(tail) = 0 .
1063.1. random variables
therefore, when we write p[x= 1] we actually mean p[{head}]. is there any difference
between p[{head}] andp[x= 1]? no, because they are describing two identical events.
note that the assignment of the value is totally up to you. you can say “head” is equal
to the value 102. this is allowed and legitimate, but it isn’t very convenient.
example 3.2 . flip a coin 2 times. the sample space ω is
ω ={(head ,head) ,(head ,tail),(tail,head) ,(tail,tail)}.
suppose that xis a random variable that maps an outcome to a number representing
the sum of “head,” i.e.,
x(·) = number of heads .
then, for the 4 ξ’s in the sample space there are only 3 distinct numbers. more precisely,
if we let ξ1= (head ,head), ξ2= (head ,tail), ξ3= (tail ,head), ξ4= (tail ,tail), then,
we have
x(ξ1) = 2 , x(ξ2) = 1 , x(ξ3) = 1 , x(ξ4) = 0 .
a pictorial illustration of this random variable is shown in figure 3.3 . this example
shows that the mapping defined by the random variable is not necessarily a one-to-one
mapping because multiple outcomes can be mapped to the same number.
figure 3.3: a random variable that maps a pair of coins to a number, where the number represents the
number of heads.
3.1.3 probability measure on random variables
by now, we hope that you understand key concept 1: a random variable is a mapping
from a statement to a number . however, we are now facing another difficulty. we knew
how to measure the size of an event using the probability law pbecause p(·) takes an event
e∈ fand sends it to a number between [0 ,1]. after the translation x, we cannot send the
output x(ξ) top(·) because p(·) “eats” a set e∈ fand not a number x(ξ)∈r. therefore,
when we write p[x= 1], how do we measure the size of the event x= 1?
107chapter 3. discrete random variables
this question appears difficult but is actually quite easy to answer. since the prob-
ability law p(·) is always applied to an event , we need to define an event for the random
variable x. if we write the sets clearly, we note that “ x=a” is equivalent to the set
e=
ξ∈ωx(ξ) =a
.
this is the set that contains all possible ξ’s such that x(ξ) =a. therefore, when we say
“find the probability of x=a,” we are effectively asking the size of the set e={ξ∈
ω|x(ξ) =a}.
how then do we measure the size of e? since eis a subset in the sample space, eis
measurable by p. all we need to do is to determine what eis for a given a. this, in turn,
requires us to find the pre-image x−1(a), which is defined as
x−1(a)def=
ξ∈ωx(ξ) =a
.
wait a minute, is this set just equal to e? yes, the event ewe are seeking is exactly the
pre-image x−1(a). as such, the probability measure of eis
p[x=a] =p[x−1(a)].
figure 3.4 illustrates a situation where two outcomes ξ1andξ2are mapped to the same
value aon the real line. the corresponding event is the set x−1(a) ={ξ1, ξ2}.
figure 3.4: when computing the probability of p[{ξ∈ω|x(ξ) =a}], we effectively take the inverse
mapping x−1(a)and compute the probability of the event p[{ξ∈x−1(a)}] =p[{ξ1, ξ2}].
example 3.3 . suppose we throw a die. the sample space is
ω ={
,
,
,
,
,
}.
there is a natural mapping xthat maps x(
) = 1, x(
) = 2 and so on. thus,
1083.1. random variables
p[x≤3](a)=p[x= 1] + p[x= 2] + p[x= 3]
(b)=p[x−1(1)] + p[x−1(2)] + p[x−1(3)]
(c)=p[{
}] +p[{
}] +p[{
}] =3
6.
in this derivation, step (a) is based on axiom iii, where the three events are disjoint.
step (b) is the pre-image due to the random variable x. step (c) is the list of ac-
tual events in the event space. note that there is no hand-waving argument in this
derivation. every step is justified by the concepts and theorems we have learned so
far.
example 3.4 . throw a die twice. the sample space is then
ω ={(
,
),(
,
), . . . , (
,
)}.
these elements can be translated to 36 outcomes:
ξ1= (
 ,
), ξ2= (
 ,
), . . . , ξ 36= (
 ,
).
let
x= sum of two numbers .
then, if we want to find the probability of getting x= 7, we can trace back and ask:
among the 36 outcomes, which of those ξi’s will give us x(ξ) = 7? or, what is the set
x−1(7)? to this end, we can write
p[x= 7] = p[{(
,
),(
,
),(
,
),(
,
),(
,
),(
,
)}]
=p[(
,
)] +p[(
,
)] +p[(
,
)]
+p[(
,
)] +p[(
,
)] +p[(
,
)]
=1
36+1
36+1
36+1
36+1
36+1
36=1
6.
again, in this example, you can see that all the steps are fully justified by the concepts
we have learned so far.
closing remark . in practice, when the problem is clearly defined, we can skip the inverse
mapping x−1(a). however, this does not mean that the probability triplet (ω ,f,p) is gone;
it is still present. the triplet is now just the background of the problem.
the set of all possible values returned by xis denoted as x(ω). since xis not
necessarily a bijection, the size of x(ω) is not necessarily the same as the size of ω. the
elements in x(ω) are often denoted as aorx. we call aorxone of the states ofx. be
careful not to confuse xandx. the variable xis the random variable; it is a function.
the variable xis a state assigned by x. a random variable xhas multiple states. when
we write p[x=x], we describe the probability of a random variable xtaking a particular
state x. it is exactly the same as p[{ξ∈ω|x(ξ) =x}].
109chapter 3. discrete random variables
3.2 probability mass function
random variables are mappings that translate events to numbers. after the translation,
we have a set of numbers denoting the states of the random variables. each state has a
different probability of occurring. the probabilities are summarized by a function known as
the probability mass function (pmf).
3.2.1 definition of probability mass function
definition 3.2. theprobability mass function (pmf) of a random variable xis a
function which specifies the probability of obtaining a number x(ξ) =x. we denote a
pmf as
px(x) =p[x=x]. (3.1)
the set of all possible states of xis denoted as x(ω).
do not get confused by the sample space ω and the set of states x(ω). the sample space ω
contains all the possible outcomes of the experiments, whereas x(ω) is the translation by
the mapping x. the event x=ais the set x−1(a)⊆ω. therefore, when we say p[x=x]
we really mean p[x−1(x)].
the probability mass function is a histogram summarizing the probability of each of
the states xtakes. since it is a histogram, a pmf can be easily drawn as a bar chart.
example 3.5 . flip a coin twice. the sample space is ω = {hh, ht, th, tt }. we
can assign a random variable x= number of heads. therefore,
x(“hh”) = 2 , x(“th”) = 1 , x(“ht”) = 1 , x(“tt”) = 0 .
so the random variable xtakes three states: 0, 1, 2. the pmf is therefore
px(0) =p[x= 0] = p[{“tt”}] =1
4,
px(1) =p[x= 1] = p[{“th” ,“ht”}] =1
2,
px(2) =p[x= 2] = p[{“hh”}] =1
4.
3.2.2 pmf and probability measure
in chapter 2, we learned that probability is a measure of the size of a set. we introduced a
weighting function that weights each of the elements in the set. the pmf is the weighing
function for discrete random variables. two random variables are different when their pmfs
are different because they are constructing two different measures.
1103.2. probability mass function
to illustrate the idea, suppose there are two dice. they each have probability masses
as follows.
p[{
}] =1
12,p[{
}] =2
12,p[{
}] =3
12,p[{
}] =4
12,p[{
}] =1
12,p[{
}] =1
12,
p[{
}] =2
12,p[{
}] =2
12,p[{
}] =2
12,p[{
}] =2
12,p[{
}] =2
12,p[{
}] =2
12,
let us define two random variables, xandy, for the two dice. then, the pmfs pxandpy
can be defined as
px(1) =1
12, px(2) =2
12, px(3) =3
12, px(4) =4
12, px(5) =1
12, px(6) =1
12,
py(1) =2
12, py(2) =2
12, py(3) =2
12, py(4) =2
12, py(5) =2
12, py(6) =2
12.
these two probability mass functions correspond to two different probability measures, let’s
sayfandg. define the event e={between 2 and 3 }. then, f(e) andg(e) will lead to
two different results:
f(e) =p[2≤x≤3] =px(2) + px(3) =1
12+2
12=3
12,
g(e) =p[2≤y≤3] =py(2) + py(3) =2
12+2
12=4
12.
note that even though for some particular events two final results could be the same (e.g.,
2≤x≤4 and 2 ≤y≤4), the underlying measures are completely different.
figure 3.5 shows another example of two different measures fandgon the same
sample space ω = {♣,♢,♡,♠}. since the pmfs of the two measures are different, even
when given the same event e, the resulting probabilities will be different.
figure 3.5: if we want to measure the size of a set e, using two different pmfs is equivalent to using
two different measures. therefore, the probabilities will be different.
does px=pyimply x=y?if two random variables xandyhave the same pmf,
does it mean that the random variables are the same? the answer is no. consider a random
variable with a symmetric pmf, e.g.,
px(−1) =1
4, p x(0) =1
2, p x(1) =1
4. (3.2)
suppose y=−x. then, py(−1) =1
4,py(0) =1
2, and py(1) =1
4, which is the same as px.
however, xandyare two different random variables. if the sample space is {♣,♢,♡}, we
can define the mappings x(·) and y(·) as
x(♣) =−1, x (♢) = 0 , x (♡) = +1 ,
y(♣) = +1 , y (♢) = 0 , y (♡) =−1.
111chapter 3. discrete random variables
therefore, when we say px(−1) =1
4, the underlying event is ♣. but when we say py(−1) =1
4,
the underlying event is ♡. the two random variables are different, although their pmfs have
exactly the same shape.
3.2.3 normalization property
here we must mention one important property of a probability mass function. this property
is known as the normalization property , which is a useful tool for a sanity check.
theorem 3.1. a pmf should satisfy the condition that
x
x∈x(ω)px(x) = 1 . (3.3)
proof . the proof follows directly from axiom ii, which states that p[ω] = 1. since xcovers
all numerical values xcan take, and since each xis distinct, by axiom iii we have
x
x∈x(ω)p[x=x] =x
x∈x(ω)p[{ξ∈ω|x(ξ) =x}]
=p
[
ξ∈ω{ξ∈ω|x(ξ) =x}
=p[ω] = 1 .
□
practice exercise 3.1 . let px(k) =c 1
2k, where k= 1,2, . . .. find c.
solution . sincep
k∈x(ω)px(k) = 1, we must have
∞x
k=11
2k
= 1.
evaluating the geometric series on the right-hand side, we can show that
∞x
k=1c1
2k
=c
2∞x
k=01
2k
=c
2·1
1−1
2
=c=⇒ c= 1.
practice exercise 3.2 . let px(k) =c·sin π
2k
, where k= 1,2, . . .. find c.
solution . the reader may might be tempted to sum px(k) over all the possible k’s:
∞x
k=1sinπ
2k
= 1 + 0 −1 + 0 + ···?= 0.
1123.2. probability mass function
however, a more careful inspection reveals that px(k) is actually negative when k=
3,7,11, . . .. this cannot happen because a probability mass function must be non-
negative. therefore, the problem is not defined, and so there is no solution.
0.06250.1250.250.5
1 2 3 4 5 6 7 8 9 10
-1-0.500.51
1 2 3 4 5 6 7 8 9 10
(a) (b)
figure 3.6: (a) the pmf of px(k) =c 1
2k, for k= 1,2, . . .. (b) the pmf of px(k) = sin π
2k
,
where k= 1,2, . . .. note that this is not a valid pmf because probability cannot have negative values.
3.2.4 pmf versus histogram
pmfs are closely related to histograms. a histogram is a plot that shows the frequency of
a state. as we see in figure 3.6 , the x-axis is a collection of states, whereas the y-axis is
the frequency. so a pmf is indeed a histogram.
viewing a pmf as a histogram can help us understand a random variable. for better
or worse, treating a random variable as a histogram could help you differentiate a random
variable from a variable. an ordinary variable only has one state, but a random variable
has multiple states. at any particular instance, we do not know which state will show up
before our observation. however, we do know the probability. for example, in the coin-flip
example, while we do not know whether we will get “hh,” we know that the chance of
getting “hh” is 1/4. of course, having a probability of 1/4 does not mean that we will get
“hh” once every four trials. it only means that if we run an infinite number of experiments,
then 1/4 of the experiments will give us “hh.”
the linkage between pmf and histogram can be quite practical. for example, while
we do not know the true underlying distribution of the 26 letters of the english alphabet, we
can collect a large number of words and plot the histogram. the example below illustrates
how we can empirically define a random variable from the data.
example . there are 26 english letters, but the frequencies of the letters in writing are
different. if we define a random variable xas a letter we randomly draw from an english
text, we can think of xas an object with 26 different states. the mapping associated with the
random variable is straightforward: x(“a”) = 1, x(“b”) = 2, etc. the probability of landing
on a particular state approximately follows a histogram shown in figure 3.7 . the histogram
provides meaningful values of the probabilities, e.g., px(1) = 0 .0847, px(2) = 0 .0149, etc.
the true probability of the states may not be exactly these values. however, when we have
enough samples, we generally expect the histogram to approach the theoretical pmf. the
matlab and python codes used to generate this histogram are shown below.
% matlab code to generate the histogram
load(‘ch3_data_english’);
bar(f/100,‘facecolor’,[0.9,0.6,0.0]);
113chapter 3. discrete random variables
a b c d e f g h i j k l m n o p q r s t u v w x y z00.020.040.060.080.10.12
figure 3.7: the frequency of the 26 english letters. data source: wikipedia.
xticklabels({‘a’,‘b’,‘c’,‘d’,‘e’,‘f’,‘g’,‘h’,‘i’,‘j’,‘k’,‘l’,...
‘m’,‘n’,‘o’,‘p’,‘q’,‘r’,‘s’,‘t’,‘u’,‘v’,‘w’,‘x’,‘y’,‘z’});
xticks(1:26);
yticks(0:0.02:0.2);
axis([1 26 0 0.13]);
# python code generate the histogram
import numpy as np
import matplotlib.pyplot as plt
f = np.loadtxt(‘./ch3_data_english.txt’)
n = np.arange(26)
plt.bar(n, f/100)
ntag = [‘a’,‘b’,‘c’,‘d’,‘e’,‘f’,‘g’,‘h’,‘i’,‘j’,‘k’,‘l’,‘m’,...
‘n’,‘o’,‘p’,‘q’,‘r’,‘s’,‘t’,‘u’,‘v’,‘w’,‘x’,‘y’,‘z’]
plt.xticks(n, ntag)
pmf = ideal histograms
if a random variable is more or less a histogram, why is the pmf such an important concept?
the answer to this question has two parts. the first part is that the histogram generated
from a dataset is always an empirical histogram, so-called because the dataset comes from
observation or experience rather than theory. thus the histograms may vary slightly every
time we collect a dataset.
as we increase the number of data points in a dataset, the histogram will eventually
converge to an ideal histogram, or a distribution . for example, counting the number of
heads in 100 coin flips will fluctuate more in percentage terms than counting the heads in 10
million coin flips. the latter will almost certainly have a histogram that is closer to a 50–50
distribution. therefore, the “histogram” generated by a random variable can be considered
the ultimate histogram or the limiting histogram of the experiment.
to help you visualize the difference between a pmf and a histogram, we show in
figure 3.8 an experiment in which a die is thrown ntimes. assuming that the die is fair,
the pmf is simply px(k) = 1 /6 for k= 1, . . . , 6, which is a uniform distribution across
the 6 states. now, we can throw the die many times. as nincreases, we observe that the
1143.2. probability mass function
1 2 3 4 5 600.050.10.150.2n = 100
1 2 3 4 5 600.050.10.150.2n = 1000
(a)n= 100 (b) n= 1000
1 2 3 4 5 600.050.10.150.2n = 10000
1 2 3 4 5 600.050.10.150.2n = 
(c)n= 10000 (d) pmf
figure 3.8: histogram and pmf, when throwing a fair die ntimes. as nincreases, the histograms are
becoming more similar to the pmf.
histogram becomes more like the pmf. you can imagine that when ngoes to infinity, the
histogram will eventually become the pmf. therefore, when given a dataset, one way to
think of it is to treat the data as random realizations drawn from a certain pmf. the more
data points you have, the closer the histogram will become to the pmf.
the matlab and python codes used to generate figure 3.8 are shown below. the
two commands we use here are randi (in matlab), which generates random integer num-
bers, and hist, which computes the heights and bin centers of a histogram. in python,
the corresponding commands are np.random.randint andplt.hist . note that because of
the different indexing schemes in matlab and python, we offset the maximum index in
np.random.randint to 7 instead of 6. also, we shift the x-axes so that the bars are centered
at the integers.
% matlab code to generate the histogram
x = [1 2 3 4 5 6];
q = randi(6,100,1);
figure;
[num,val] = hist(q,x-0.5);
bar(num/100,‘facecolor’,[0.8, 0.8,0.8]);
axis([0 7 0 0.24]);
# python code generate the histogram
import numpy as np
import matplotlib.pyplot as plt
q = np.random.randint(7,size=100)
115chapter 3. discrete random variables
plt.hist(q+0.5,bins=6)
thisgenerative perspective is illustrated in figure 3.9 . we assume that the underlying
latent random variable has some pmf that can be described by a few parameters, e.g., the
mean and variance. given the data points, if we can infer these parameters, we might retrieve
the entire pmf (up to the uncertainty level intrinsic to the dataset). we refer to this inverse
process as statistical inference.
figure 3.9: when analyzing a dataset, one can treat the data points are samples drawn according to a
latent random variable with certain a pmf. the dataset we observe is often finite, and so the histogram
we obtain is empirical. a major task in data analysis is statistical inference, which tries to retrieve the
model information from the available measurements.
returning to the question of why we need to understand the pmfs, the second part
of the answer is the difference between synthesis andanalysis . in synthesis, we start with
a known random variable and generate samples according to the pmf underlying the ran-
dom variable. for example, on a computer, we often start with a gaussian random variable
and generate random numbers according to the histogram specified by the gaussian ran-
dom variable. synthesis is useful because we can predict what will happen. we can, for
example, create millions of training samples to train a deep neural network. we can also
evaluate algorithms used to estimate statistical quantities such as mean, variance, moments,
etc., because the synthesis approach provides us with ground truth. in supervised learning
scenarios, synthesis is vital to ensuring sufficient training data.
the other direction of synthesis is analysis. the goal is to start with a dataset and
deduce the statistical properties of the dataset. for example, suppose we want to know
whether the underlying model is indeed a gaussian model. if we know that it is a gaussian
(or if we choose to use a gaussian), we want to know the parameters that define this
gaussian. the analysis direction addresses this model selection and parameter estimation
problem. moving forward, once we know the model and the parameters, we can make a
prediction or do recovery, both of which are ubiquitous in machine learning.
we summarize our discussions below, which is key concept 2 of this chapter.
key concept 2: what are probability mass functions (pmfs)?
pmfs are the ideal histograms of random variables.
1163.2. probability mass function
3.2.5 estimating histograms from real data
the following discussions about histogram estimation can be skipped if it is your first
time reading the book.
if you have a dataset, how would you plot the histogram? certainly, if you have access
to matlab or python, you can call standard functions such as hist (in matlab) or
np.histogram (in python). however, when plotting a histogram, you need to specify the
number of bins (or equivalently the width of bins). if you use larger bins, then you will have
fewer bins with many elements in each bin. conversely, if the bin width is too small, you
may not have enough samples to fill the histogram. figure 3.10 illustrates two histograms
in which the bins are respectively too large and too small.
0 2 4 6 8 1002004006008001000
k = 5
0 2 4 6 8 1001020304050
k = 200
(a) 5 bins (b) 200 bins
figure 3.10: the width of the histogram has substantial influence on the information that can be
extracted from the histogram.
the matlab and python codes used to generate figure 3.10 are shown below. note
that here we are using an exponential random variable (to be discussed in chapter 4). in
matlab, calling an exponential random variable is done using exprnd , whereas in python
the command is np.random.exponential . for this experiment, we can specify the number
of bins k, which can be set to k= 200 or k= 5. to suppress the python output of the array,
we can add a semicolon ;. a final note is that lambda is a reserved variable in python. use
something else.
% matlab code used to generate the plots
lambda = 1;
k = 1000;
x = exprnd(1/lambda,[k,1]);
[num,val] = hist(x,200);
bar(val,num,‘facecolor’,[1, 0.5,0.5]);
# python code used to generate the plots
import numpy as np
import matplotlib.pyplot as plt
lambd = 1
117chapter 3. discrete random variables
k = 1000
x = np.random.exponential(1/lambd, size=k)
plt.hist(x,bins=200);
in statistics, there are various rules to determine the bin width of a histogram. we
mention a few of them here. let kbe the number of bins and nthe number of samples.
square-root: k=√
n
sturges’ formula: k= log2n+ 1.
rice rule: k= 23√
n
scott’s normal reference rule: k=maxx−minx
h, where h=3.5√
var[x]
3√
nis the bin
width.
for the example data shown in figure 3.10 , the histograms obtained using the above rules
are given in figure 3.11 . as you can see, different rules have different suggested bin widths.
some are more conservative, e.g., using fewer bins, whereas some are less conservative. in
any case, the suggested bin widths do seem to provide better histograms than the original
ones in figure 3.10 . however, no bin width is the best for all purposes.
0 1 2 3 4 50100200300400500
square-root, k =  32
0 1 2 3 4 50100200300400500
sturges rule, k =  11
0 1 2 3 4 50100200300400500
rice rule, k =  20
0 1 2 3 4 50100200300400500
scott rule, k =  22
figure 3.11: histograms of a dataset using different bin width rules.
beyond these predefined rules, there are also algorithmic tools to determine the bin
width. one such tool is known as cross-validation . cross-validation means defining some
kind of cross-validation score that measures the statistical risk associated with the his-
togram. a histogram having a lower score has a lower risk, and thus it is a better histogram.
1183.2. probability mass function
note that the word “better” is relative to the optimality criteria associated with the cross-
validation score. if you do not agree with our cross-validation score, our optimal bin width is
not necessarily the one you want. in this case, you need to specify your optimality criteria.
theoretically, deriving a meaningful cross-validation score is beyond the scope of this
book. however, it is still possible to understand the principle. let hbe the bin width of the
histogram, kthe number of bins, and nthe number of samples. given a dataset, we follow
this procedure:
step 1: choose a bin width h.
step 2: construct a histogram from the data, using the bin width h. the histogram will
have the empirical pmf values bp1,bp2, . . . ,bpk, which are the heights of the histograms
normalized so that the sum is 1.
step 3: compute the cross-validation score (see wasserman, all of statistics , section
20.2):
j(h) =2
(n−1)h−n+ 1
(n−1)h 
bp2
1+bp2
2+···+bp2
k
(3.4)
repeat steps 1, 2, 3, until we find an hthat minimizes j(h).
note that when we use a different h, the pmf values bp1,bp2, . . . ,bpkwill change, and the
number of bins kwill also change. therefore, when changing h, we are changing not only
the terms in j(h) that explicitly contain hbut also terms that are implicitly influenced.
20 40 60 80 100 120 140 160 180 200
number of bins-3.5-3.4-3.3-3.2-3.1-3-2.9cross-validation score10-3
20 40 60 80 100 120 140 160 180 200
number of bins012345cross-validation score10-4
(a) one dataset (b) average of many datasets
figure 3.12: cross-validation score for the histogram. (a) the score of one particular dataset. (b) the
scores for many different datasets generated by the same model.
for the dataset we showed in figure 3.10 , the cross-validation score j(h) is shown in
figure 3.12 . we can see that although the curve is noisy, there is indeed a reasonably clear
minimum happening around 20 ≤k≤30, which is consistent with some of the rules.
the matlab and python codes we used to generate figure 3.12 are shown below.
the key step is to implement equation (3.4) inside a for-loop, where the loop goes through
the range of bins we are interested in. to obtain the pmf values bp1, . . . ,bpk, we call hist
in matlab and np.histogram in python. the bin width his the number of samples n
divided by the number of bins m.
119chapter 3. discrete random variables
% matlab code to perform the cross validation
lambda = 1;
n = 1000;
x = exprnd(1/lambda,[n,1]);
m = 6:200;
j = zeros(1,195);
for i=1:195
[num,binc] = hist(x,m(i));
h = n/m(i);
j(i) = 2/((n-1)*h)-((n+1)/((n-1)*h))*sum( (num/n).^2 );
end
plot(m,j,‘linewidth’,4,‘color’,[0.9,0.2,0.0]);
# python code to perform the cross validation
import numpy as np
import matplotlib.pyplot as plt
lambd = 1
n = 1000
x = np.random.exponential(1/lambd, size=n)
m = np.arange(5,200)
j = np.zeros((195))
for i in range(0,195):
hist,bins = np.histogram(x,bins=m[i])
h = n/m[i]
j[i] = 2/((n-1)*h)-((n+1)/((n-1)*h))*np.sum((hist/n)**2)
plt.plot(m,j);
infigure 3.12 (b), we show another set of curves from the same experiment. the
difference here is that we assume access to the true generative model so that we can generate
the many datasets of the same distribution. in this experiment we generated t= 1000
datasets. we compute the cross-validation score j(h) for each of the datasets, yielding t
score functions j(1)(h), . . . , j(t)(h). we subtract the minimum because different realizations
have different offsets. then we compute the average:
j(h) =1
ttx
t=1
j(t)(h)−min
h
j(t)(h)	
. (3.5)
this gives us a smooth red curve as shown in figure 3.12 (b). the minimum appears to be
atn= 25. this is the optimal n, concerning the cross-validation score, on the average of
all datasets.
all rules, including cross-validation, are based on optimizing for a certain objective.
your objective could be different from our objective, and so our optimum is not necessarily
your optimum. therefore, cross-validation may not be the best. it depends on your problem.
end of the discussion.
1203.3. cumulative distribution functions (discrete)
3.3 cumulative distribution functions (discrete)
while the probability mass function (pmf) provides a complete characterization of a dis-
crete random variable, the pmfs themselves are technically not “functions” because the
impulses in the histogram are essentially delta functions. more formally, a pmf px(k)
should actually be written as
px(x) =x
k∈x(ω)px(k)|{z}
pmf values·δ(x−k)|{z}
delta function.
this is a train of delta functions, where the height is specified by the probability mass px(k).
for example, a random variable with pmf values
px(0) =1
4, px(1) =1
2, px(2) =1
4
will be expressed as
px(x) =1
4δ(x) +1
2δ(x−1) +1
4δ(x−2).
since delta functions need to be integrated to generate values, the typical things we want to
do, e.g., integration and differentiation, are not as straightforward in the sense of riemann-
stieltjes.
the way to handle the unfriendliness of the delta functions is to consider mild modi-
fications of the pmf. this notation of “cumulative” distribution functions will allow us to
resolve the delta function problems. we will defer the technical details to the next chap-
ter. for the time being, we will briefly introduce the idea to prepare you for the technical
discussion later.
3.3.1 definition of the cumulative distribution function
definition 3.3. letxbe a discrete random variable with ω ={x1, x2, . . .}. the
cumulative distribution function (cdf) of xis
fx(xk)def=p[x≤xk] =kx
ℓ=1px(xℓ). (3.6)
ifω ={. . . ,−1,0,1,2, . . .}, then the cdf of xis
fx(k)def=p[x≤k] =kx
ℓ=−∞px(ℓ). (3.7)
a cdf is essentially the cumulative sum of a pmf from −∞tox, where the variable x′in
the sum is a dummy variable.
121chapter 3. discrete random variables
example 3.6 . consider a random variable xwith pmf px(0) =1
4,px(1) =1
2and
px(4) =1
4. the cdf of xcan be computed as
fx(0) =p[x≤0] =px(0) =1
4,
fx(1) =p[x≤1] =px(0) + px(1) =3
4,
fx(4) =p[x≤4] =px(0) + px(1) + px(4) = 1 .
as shown in figure 3.13 , the cdf of a discrete random variable is a staircase function.
0.250.50.751
0 1 4
0 1 40.250.50.751
(a) pmf px(k) (b) cdf fx(k)
figure 3.13: illustration of a pmf and a cdf.
the matlab code and the python code used to generate figure 3.13 are shown
below. the cdf is computed using the command cumsum in matlab and np.cumsum in
python.
% matlab code to generate a pmf and a cdf
p = [0.25 0.5 0.25];
x = [0 1 4];
f = cumsum(p);
figure(1);
stem(x,p,‘.’,‘linewidth’,4,‘markersize’,50);
figure(2);
stairs([-4 x 10],[0 f 1],‘.-’,‘linewidth’,4,‘markersize’,50);
% python code to generate a pmf and a cdf
import numpy as np
import matplotlib.pyplot as plt
p = np.array([0.25, 0.5, 0.25])
x = np.array([0, 1, 4])
f = np.cumsum(p)
plt.stem(x,p,use_line_collection=true); plt.show()
plt.step(x,f); plt.show()
1223.3. cumulative distribution functions (discrete)
why is cdf a better-defined function than pmf? there are technical reasons associ-
ated with whether a function is integrable. without going into the details of these discus-
sions, a short answer is that delta functions are defined through integrations; they are not
functions. a delta function is defined as a function such that δ(x) = 0 everywhere except at
x= 0, andr
ωδ(x)dx= 1. on the other hand, a staircase function is always well-defined.
the discontinuous points of a staircase can be well defined if we specify the gap between
two consecutive steps. for example, in figure 3.13 , as soon as we specify the gap 1 /4, 1/2,
and 1 /4, the staircase function is completely defined.
example .figure 3.14 shows the empirical histogram of the english letters and the corre-
sponding empirical cdf. we want to differentiate pmf versus histogram and cdf versus
empirical cdf. the empirical cdf is the cdf computed from a finite dataset.
00.020.040.060.080.10.12
a b c d e f g h i j k l m n o p q r s t u v w x y z
a b c d e f g h i j k l m n o p q r s t u v w x y z00.10.20.30.40.50.60.70.80.91
figure 3.14: pmf and a cdf of the frequency of english letters.
3.3.2 properties of the cdf
we observe from the example in figure 3.13 that a cdf has several properties. first, being
a staircase function, the cdf is non-decreasing. it can stay constant for a while, but it never
drops. second, the minimum value of a cdf is 0, whereas the maximum value is 1. it is 0
for any value that is smaller than the first state; it is 1 for any value that is larger than the
last state. third, the gap at each jump is exactly the probability mass at that state. let us
summarize these observations in the following theorem.
theorem 3.2. ifxis a discrete random variable, then the cdf of xhas the following
properties:
(i) the cdf is a sequence of increasing unit steps.
(ii) the maximum of the cdf is when x=∞:fx(+∞) = 1 .
(iii) the minimum of the cdf is when x=−∞:fx(−∞) = 0 .
(iv) the unit steps have jumps at positions where px(x)>0.
proof . statement (i) can be seen from the summation
fx(x) =x
x′≤xpx(x′).
123chapter 3. discrete random variables
since the probability mass function is non-negative, the value of fxis larger when the value
of the argument is larger. that is, x≤yimplies fx(x)≤fx(y). the second statement (ii)
is true because the summation includes all possible states. so we have
fx(+∞) =∞x
x′=−∞px(x′) = 1 .
similarly, for the third statement (iii),
fx(−∞) =x
x′≤−∞px(x′).
the summation is taken over an empty set, and so fx(−∞) = 0. statement (iv) is true
because the cumulative sum changes only when there is a non-zero mass in the pmf. □
as we can see in the proof, the basic argument of the cdf is the cumulative sum of
the pmf. by definition, a cumulative sum always adds mass. this is why the cdf is always
increasing, has 0 at −∞, and has 1 at + ∞. this last statement deserves more attention. it
implies that the unit step always has a solid dot on the left -hand side and an empty dot
on the right -hand side, because when the cdf jumps, the final value is specified by the
“≤” sign in equation (3.6). the technical term for this property is right continuous .
3.3.3 converting between pmf and cdf
theorem 3.3. ifxis a discrete random variable, then the pmf of xcan be obtained
from the cdf by
px(xk) =fx(xk)−fx(xk−1), (3.8)
where we assumed that xhas a countable set of states {x1, x2, . . .}. if the sample space
of the random variable xcontains integers from −∞ to+∞, then the pmf can be
defined as
px(k) =fx(k)−fx(k−1). (3.9)
example 3.7 . continuing with the example in figure 3.13 , if we are given the cdf
fx(0) =1
4, f x(1) =3
4, f x(4) = 1 ,
how do we find the pmf? we know that the pmf will have non-negative values only
atx= 0,1,4. for each of these x, we can show that
px(0) = fx(0)−fx(−∞) =1
4−0 =1
4,
px(1) = fx(1)−fx(0) =3
4−1
4=1
2,
px(4) = fx(4)−fx(1) = 1 −3
4=1
4.
1243.4. expectation
3.4 expectation
when analyzing data, it is often useful to extract certain key parameters such as the mean
and the standard deviation. the mean and the standard deviation can be seen from the lens
of random variables. in this section, we will formalize the idea using expectation .
3.4.1 definition of expectation
definition 3.4. theexpectation of a random variable xis
e[x] =x
x∈x(ω)x px(x). (3.10)
expectation is the mean of the random variable x. intuitively, we can think of px(x) as the
percentage of times that the random variable xattains the value x. when this percentage
is multiplied by x, we obtain the contribution of each x. summing over all possible values
ofxthen yields the mean. to see this more clearly, we can write the definition as
e[x] =x
x∈x(ω)| {z }
sum over all statesx|{z}
a state xtakespx(x)|{z }
the percentage.
figure 3.15 illustrates a pmf that contains five states x1, . . . , x 5. corresponding to each
state are px(x1), . . . , p x(x5). for this pmf to make sense, we must assume that px(x1) +
···+px(x5) = 1. to simplify notation, let us define pidef=px(xi). then the expectation
ofxis just the sum of the products: value ( xi) times height ( pi). this gives e[x] =p5
i=1xipx(xi).
figure 3.15: the expectation of a random variable is the sum of xipi.
we emphasize that the definition of the expectation is exactly the same as the usual
way we calculate the average of a dataset. when we calculate the average of a dataset
d={x(1), x(2), . . . , x(n)}, we sum up these nsamples and divide by the number of samples.
this is what we called the empirical average or the sample average:
average =1
nnx
n=1x(n). (3.11)
125chapter 3. discrete random variables
of course, in a typical dataset, these nsamples often take distinct values. but suppose
that among these nsamples there are only kdifferent values. for example, if we throw a
die a million times, every sample we record will be one of the six numbers. this situation
is illustrated in figure 3.16 , where we put the samples into the correct bin storing these
values. in this case, to calculate the average we are effectively doing a binning:
average =1
nkx
k=1value xk×number of samples with value xk. (3.12)
equation (3.12) is exactly the same as equation (3.11), as long as the samples can be grouped
intokdifferent values. with a little calculation, we can rewrite equation (3.12) as
average =kx
k=1|{z}
sum of all statesvalue xk|{z}
a state xtakes×number of samples with value xk
n| {z }
the percentage,
which is the same as the definition of expectation.
figure 3.16: if we have a dataset dcontaining nsamples, and if there are only kdistinct values, we
can effectively put these nsamples into kbins. thus, the “average” (which is the sum divided by the
number n) is exactly the same as our definition of expectation.
the difference between e[x] and the average is that e[x] is computed from the ideal
histogram, whereas average is computed from the empirical histogram. when the number of
samples napproaches infinity, we expect the average to approximate e[x]. however, when
nis small, the empirical average will have random fluctuations around e[x]. every time
we experiment, the empirical average may be slightly different. therefore, we can regard
e[x] as the true average of a certain random variable, and the empirical average as a finite-
sample average based on the particular experiment we are working with. this summarizes
key concept 3 of this chapter.
key concept 3: what is expectation?
expectation = mean = average computed from a pmf.
if we are given a dataset on a computer, computing the mean can be done by calling
the command mean in matlab and np.mean in python. the example below shows the
case of finding the mean of 10000 uniformly distributed random numbers.
1263.4. expectation
% matlab code to compute the mean of a dataset
x = rand(10000,1);
mx = mean(x);
# python code to compute the mean of a dataset
import numpy as np
x = np.random.rand(10000)
mx = np.mean(x)
example 3.8 . let xbe a random variable with pmf px(0) = 1 /4,px(1) = 1 /2 and
px(2) = 1 /4. we can show that the expectation is
e[x] = (0)1
4
|{z}
px(0)+ (1)1
2
|{z}
px(1)+ (2)1
4
|{z}
px(2)= 1.
on matlab and python, if we know the pmf then computing the expectation is
straight-forward. here is the code to compute the above example.
% matlab code to compute the expectation
p = [0.25 0.5 0.25];
x = [0 1 2];
ex = sum(p.*x);
# python code to compute the expectation
import numpy as np
p = np.array([0.25, 0.5, 0.25])
x = np.array([0, 1, 2])
ex = np.sum(p*x)
example 3.9 . flip an unfair coin, where the probability of getting a head is3
4. let
xbe a random variable such that x= 1 means getting a head. then we can show
thatpx(1) =3
4andpx(0) =1
4. the expectation of xis therefore
e[x] = (1) px(1) + (0) px(0) = (1)3
4
+ (0)1
4
=3
4.
center of mass . how would you interpret the result of this example? does it mean
that, on average, we will get 3 /4 heads (but there is not anything called 3 /4 heads!). recall
the definition of a random variable: it is a translator that translates a descriptive state
to a number on the real line. thus the expectation, which is an operation defined on the
real line, can only tell us what is happening on the real line, not in the original sample
127chapter 3. discrete random variables
figure 3.17: center of mass. if a state x2is more influential than another state x1, the center of mass
e[x]will lean towards x2.
space. on the real line, the expectation can be regarded as the center of mass , which is the
point where the “forces” between the two states are “balanced”. in figure 3.17 we depict a
random variable with two states x1andx2. the state x1has less influence (because px(x1)
is smaller) than x2. therefore the center of mass is shifted towards x2. this result shows us
that the value e[x] is not necessarily in the sample space. e[x] is a deterministic number
with nothing to do with the sample space.
example 3.10 . let xbe a random variable with pmf px(k) =1
2k, fork= 1,2,3, . . ..
the expectation is
e[x] =∞x
k=1kpx(k) =∞x
k=1k·1
2k
=1
2∞x
k=1k·1
2k−1=1
2·1
(1−1
2)2= 2.
on matlab and python, if you want to verify this answer you can use the following
code. here, we approximate the infinite sum by a finite sum of k= 1, . . . , 100.
% matlab code to compute the expectation
k = 1:100;
p = 0.5.^k;
ex = sum(p.*k);
# python code to compute the expectation
import numpy as np
k = np.arange(100)
p = np.power(0.5,k)
ex = np.sum(p*k)
example 3.11 . roll a die twice. let xbe the first roll and ybe the second roll.
letz= max( x, y). to compute the expectation e[z], we first construct the sample
space. since there are two rolls, we can construct a table listing all possible pairs of
outcomes. this will give us {(1,1),(1,2), . . . , (6,6)}. now, we calculate z, which is the
max of the two rolls. so if we have (1 ,3), then the max will be 3, whereas if we have
(5,2), then the max will be 5. we can complete a table as shown below.
1283.4. expectation
1 2 3 4 5 6
11 2 3 4 5 6
22 2 3 4 5 6
33 3 3 4 5 6
44 4 4 4 5 6
55 5 5 5 5 6
66 6 6 6 6 6
this table tell us that zhas 6 states. the pmf of zcan be determined by
counting the number of times a state shows up in the table. thus, we can show that
pz(1) =1
36, pz(2) =3
36, pz(3) =5
36,
pz(4) =7
36, pz(5) =9
36, pz(6) =11
36.
the expectation of zis therefore
e[z] = (1)1
36
+ (2)3
36
+ (3)5
36
+ (4)7
36
+ (5)9
36
+ (6)11
36
=161
36.
example 3.12 . consider a game in which we flip a coin 3 times. the reward of the
game is
• $1 if there are 2 heads
• $8 if there are 3 heads
• $0 if there are 0 or 1 head
there is a cost associated with the game. to enter the game, the player has to pay
$1.50. we want to compute the net gain, on average.
to answer this question, we first note that the sample space contains 8 elements:
hhh, hht, hth, thh, tht, tth, htt, ttt. let xbe the number of heads.
then the pmf of xis
px(0) =1
8, px(1) =3
8, px(2) =3
8, px(3) =1
8.
we then let ybe the reward. the pmf of ycan be found by “adding” the probabilities
ofx. this yields
py(0) = px(0) + px(1) =4
8, py(1) = px(2) =3
8, py(8) = px(3) =1
8.
129chapter 3. discrete random variables
the expectation of yis
e[x] = (0)4
8
+ (1)3
8
+ (8)1
8
=11
8.
since the cost of the game is12
8, the net gain (on average) is −1
8.
3.4.2 existence of expectation
does every pmf have an expectation? no, because we can construct a pmf such that the
expectation is undefined.
example 3.13 . consider a random variable xwith the following pmf:
px(k) =6
π2k2, k = 1,2, . . . .
using a result from algebra, one can show thatp∞
k=11
k2=π2
6. therefore, px(k) is a
legitimate pmf becausep∞
k=1px(k) = 1. however, the expectation diverges, because
e[x] =∞x
k=1kpx(k)
=6
π2∞x
k=11
k→ ∞ ,
where the limit is due to the harmonic seriesa: 1 +1
2+1
3+···=∞.
ahttps://en.wikipedia.org/wiki/harmonic_series_(mathematics)
a pmf has an expectation when it is absolutely summable .
definition 3.5. a discrete random variable xisabsolutely summable if
e[|x|]def=x
x∈x(ω)|x|px(x)<∞. (3.13)
this definition tells us that not all random variables have a finite expectation. this
is a very important mathematical result, but its practical implication is arguably limited.
most of the random variables we use in practice are absolutely summable. also, note that
the property of absolute summability applies to discrete random variables. for continuous
random variables, we have a parallel concept called absolute integrability , which will be
discussed in the next chapter.
3.4.3 properties of expectation
the expectation of a random variable has several useful properties. we list them below.
note that these properties apply to both discrete and continuous random variables.
1303.4. expectation
theorem 3.4. the expectation of a random variable xhas the following properties:
(i)function . for any function g,
e[g(x)] =x
x∈x(ω)g(x)px(x).
(ii)linearity . for any function gandh,
e[g(x) +h(x)] =e[g(x)] +e[h(x)].
(iii) scale . for any constant c,
e[cx] =ce[x].
(iv)dc shift . for any constant c,
e[x+c] =e[x] +c.
proof of (i) : a pictorial proof of (i) is shown in figure 3.18 . the key idea is a change of
variable.
figure 3.18: by letting g(x) =y, the pmfs are not changed. what changes are the states.
when we have a function y=g(x), the pmf of ywill have impulses moved from x
(the horizontal axis) to g(x) (the vertical axis). the pmf values (i.e., the probabilities or
the height of the stems), however, are not changed. if the mapping g(x) is many-to-one,
multiple pmf values will add to the same position. therefore, when we compute e[g(x)],
we compute the expectation along the vertical axis.
practice exercise 3.3 . prove statement (iii): for any constant c,e[cx] =ce[x].
solution . recall the definition of expectation:
e[cx] =x
x∈x(ω)(cx)px(x) =cx
x∈x(ω)xpx(x)
|{z }
=e[x]=ce[x].
statement (iii) is illustrated in figure 3.19 . here, we assume that the original pmf has 3
131chapter 3. discrete random variables
states x= 0,1,2. we multiply xby a constant c= 3. this changes xtocx= 0,3,6.
however, since the probabilities are not changed, the height of the pmf values remains.
therefore, when computing the expectation, we just multiply e[x] bycto get ce[x].
figure 3.19: pictorial representation of e[cx] =ce[x]. when we multiply xbyc, we fix the probabil-
ities but make the spacing between states wider/narrower.
practice exercise 3.4 . prove statement (ii): for any function gandh,e[g(x) +
h(x)] =e[g(x)] +e[h(x)].
solution . recall the definition of expectation:
e[g(x) +h(x)] =x
x∈x(ω)[g(x) +h(x)]px(x)
=x
x∈x(ω)g(x)px(x)
| {z }
=e[g(x)]+x
x∈x(ω)h(x)px(x)
| {z }
=e[h(x)]
=e[g(x)] +e[h(x)].
practice exercise 3.5 . prove statement (iv): for any constant c,e[x+c] =e[x]+c.
solution . recall the definition of expectation:
e[x+c] =x
x∈x(ω)(x+c)px(x)
=x
x∈x(ω)xpx(x)
|{z }
=e[x]+c·x
x∈x(ω)px(x)
|{z}
=1
=e[x] +c.
this result is illustrated in figure 3.20 . as we add a constant to the random variable,
its pmf values remain the same but their positions are shifted. therefore, when computing
the mean, the mean will be shifted accordingly.
1323.4. expectation
figure 3.20: pictorial representation of e[x+c] =e[x]+c. when we add ctox, we fix the probabilities
and shift the entire pmf to the left or to the right.
example 3.14 . let xbe a random variable with four equally probable states 0 ,1,2,3.
we want to compute the expectation e[cos(πx/2)]. to do so, we note that
e[cos(πx/2)] =x
x∈x(ω)cosπx
2
px(x)
= (cos 0)1
4
+ (cosπ
2)1
4
+ (cos2π
2)1
4
+ (cos3π
2)1
4
=1 + 0 + ( −1) + 0
4= 0.
example 3.15 . let xbe a random variable with e[x] = 1 and e[x2] = 3. we want
to find the expectation e[(ax+b)2]. to do so, we realize that
e[(ax+b)2](a)=e[a2x2+ 2abx+b2](b)=a2e[x2] + 2abe[x] +b2= 3a2+ 2ab+b2,
where ( a) is due to expansion of the square, and ( b) holds in two steps. the first step
is to apply statement (ii) for individual functions of expectations, and the second step
is to apply statement (iii) for scalar multiple of the expectations.
3.4.4 moments and variance
based on the concept of expectation, we can define a moment :
definition 3.6. thekth moment of a random variable xis
e[xk] =x
xxkpx(x). (3.14)
essentially, the kth moment is the expectation applied to xk. the definition follows from
statement (i) of the expectation’s properties. using this definition, we note that e[x] is the
first moment and e[x2] is the second moment. higher-order moments can be defined, but
in practice they are less commonly used.
133chapter 3. discrete random variables
example 3.16 . flip a coin 3 times. let xbe the number of heads. then
px(0) =1
8, px(1) =3
8, px(2) =3
8, px(3) =1
8.
the second moment e[x2] is
e[x2] = (0)21
8
+ (1)23
8
+ (2)23
8
+ (4)21
8
= 3.
example 3.17 . consider a random variable xwith pmf
px(k) =1
2k, k = 1,2, . . . .
the second moment e[x2] is
e[x2] =∞x
k=1k21
2k
=1
22∞x
k=1k(k−1 + 1)1
2k−2
=1
22∞x
k=1k(k−1)1
2k−2
+1
22∞x
k=1k1
2k−2
=1
222
(1−1
2)3
+1
21
(1−1
2)2
= 6.
using the second moment, we can define the variance of a random variable.
definition 3.7. thevariance of a random variable xis
var[x] =e[(x−µ)2], (3.15)
where µ=e[x]is the expectation of x.
we denote σ2by var[ x]. the square root of the variance, σ, is called the standard deviation
ofx. like the expectation e[x], the variance var[ x] is computed using the ideal histogram
pmf. it is the limiting object of the usual standard deviation we calculate from a dataset.
on a computer, computing the variance of a dataset is done by calling built-in com-
mands such as varin matlab and np.var in python. the standard deviation is computed
using stdandnp.std , respectively.
% matlab code to compute the variance
x = rand(10000,1);
vx = var(x);
sx = std(x);
% python code to compute the variance
import numpy as np
1343.4. expectation
x = np.random.rand(10000)
vx = np.var(x)
sx = np.std(x)
what does the variance mean? it is a measure of the deviation of the random variable
xrelative to its mean. this deviation is quantified by the squared difference ( x−µ)2. the
expectation operator takes the average of the deviation, giving us a deterministic number
e[(x−µ)2].
theorem 3.5. the variance of a random variable xhas the following properties:
(i)moment .
var[x] =e[x2]−e[x]2.
(ii)scale . for any constant c,
var[cx] =c2var[x].
(iii) dc shift . for any constant c,
var[x+c] = var[ x].
figure 3.21: pictorial representations of var[cx] =c2var[x]andvar[x+c] = var[ x].
practice exercise 3.6 . prove theorem 3.5 above.
solution . for statement (i), we show that
var[x] =e[(x−µ)2] =e[x2−2xµ+µ2] =e[x2]−µ2.
135chapter 3. discrete random variables
statement (ii) holds because e[cx] =cµand
var[cx] =e[(cx−e[cx])2]
=e[(cx−cµ)2] =c2e[(x−µ)2] =c2var[x].
statement (iii) holds because
var[x+c] =e[((x+c)−e[x+c])2] =e[(x−e[x])2] = var[ x].
the properties above are useful in various ways. the first statement provides a link connect-
ing variance and the second moment. statement (ii) implies that when xis scaled by c, the
variance should be scaled by c2because of the square in the second moment. statement (iii)
says that when xis shifted by a scalar c, the variance is unchanged. this is true because
no matter how we shift the mean, the fluctuation of the random variable remains the same.
practice exercise 3.7 . flip a coin with probability pto get a head. let xbe a
random variable denoting the outcome. the pmf of xis
px(0) = 1 −p, p x(1) = p.
finde[x],e[x2] and var[ x].
solution . the expectation of xis
e[x] = (0) px(0) + (1) px(1) = (0)(1 −p) + (1)( p) =p.
the second moment is
e[x2] = (0)2px(0) + (1)2px(1) = p.
the variance is
var[x] =e[x2]−e[x]2=p−p2=p(1−p).
3.5 common discrete random variables
in the previous sections, we have conveyed three key concepts: one about the random vari-
able, one about the pmf, and one about the mean. the next step is to introduce a few
commonly used discrete random variables so that you have something concrete in your “tool-
box.” as we have mentioned before, these predefined random variables should be studied
from a synthesis perspective (sometimes called generative ). the plan for this section is to
introduce several models, derive their theoretical properties, and discuss examples.
note that some extra effort will be required to understand the origins of the random
variables. the origins of random variables are usually overlooked, but they are more impor-
tant than the equations. for example, we will shortly discuss the poisson random variable
1363.5. common discrete random variables
figure 3.22: a bernoulli random variable has two states with probability pand1−p.
and its pmf px(k) =λke−λ
k!. why is the poisson random variable defined in this way? if
you know how the poisson pmf was originally derived, you will understand the assumptions
made during the derivation. consequently, you will know why poisson is a good model for
internet traffic, recommendation scores, and image sensors for computer vision applications.
you will also know under what situation the poisson model will fail. understanding the
physics behind the probability models is the focus of this section.
3.5.1 bernoulli random variable
we start discussing the simplest random variable, namely the bernoulli random variable .
a bernoulli random variable is a coin-flip random variable. the random variable has two
states: either 1 or 0. the probability of getting 1 is p, and the probability of getting 0 is
1−p. see figure 3.22 for an illustration. bernoulli random variables are useful for all kinds
of binary state events: coin flip (h or t), binary bit (1 or 0), true or false, yes or no, present
or absent, democrat or republican, etc.
to make these notions more precise, we define a bernoulli random variable as follows.
definition 3.8. letxbe abernoulli random variable . then, the pmf of xis
px(0) = 1 −p, p x(1) = p,
where 0< p < 1is called the bernoulli parameter. we write
x∼bernoulli( p)
to say that xis drawn from a bernoulli distribution with a parameter p.
in this definition, the parameter pcontrols the probability of obtaining 1. in a coin-flip event,
pis usually1
2, meaning that the coin is fair. however, for biased coins pis not necessarily1
2.
for other situations such as binary bits (0 or 1), the probability of obtaining 1 could be very
different from the probability of obtaining 0.
in matlab and python, generating bernoulli random variables can be done by call-
ing the binomial random number generator np.random.binomial (python) and binornd
(matlab). when the parameter nis equal to 1, the binomial random variable is equiv-
alent to a bernoulli random variable. the matlab and python codes to synthesize a
bernoulli random variable are shown below.
137chapter 3. discrete random variables
% matlab code to generate 1000 bernoulli random variables
p = 0.5;
n = 1;
x = binornd(n,p,[1000,1]);
[num, ~] = hist(x, 10);
bar(linspace(0,1,10), num,‘facecolor’,[0.4, 0.4, 0.8]);
# python code to generate 1000 bernoulli random variables
import numpy as np
import matplotlib.pyplot as plt
p = 0.5
n = 1
x = np.random.binomial(n,p,size=1000)
plt.hist(x,bins=‘auto’)
an alternative method in python is to call stats.bernoulli.rvs to generate random
bernoulli numbers.
# python code to call scipy.stats library
import numpy as np
import matplotlib.pyplot as plt
import scipy.stats as stats
p = 0.5
x = stats.bernoulli.rvs(p,size=1000)
plt.hist(x,bins=‘auto’);
properties of bernoulli random variables
let us now derive a few key statistical properties of a bernoulli random variable.
theorem 3.6. ifx∼bernoulli( p), then
e[x] =p, e[x2] =p, var[x] =p(1−p).
proof . the expectation can be computed as
e[x] = (1) px(1) + (0) px(0) = (1)( p) + (0)(1 −p) =p.
the second moment is
e[x2] = (12)(p) + (02)(1−p) =p.
therefore, the variance is
var[x] =e[x2]−µ2=p−p2=p(1−p).
□
a useful property of the python code is that we can construct an object rv. then we
can call rv’s attributes to determine its mean, variance, etc.
1383.5. common discrete random variables
# python code to generate a bernoulli rv object
import numpy as np
import matplotlib.pyplot as plt
import scipy.stats as stats
p = 0.5
rv = stats.bernoulli(p)
mean, var = rv.stats(moments=‘mv’)
print(mean, var)
in both matlab and python, we can plot the pmf of a bernoulli random variable,
such as the one shown in figure 3.23 . to do this in matlab, we call the function binopdf ,
with the evaluation points specified by x.
00.20.40.60.81
-0.2 0 0.2 0.4 0.6 0.8 1 1.2
figure 3.23: an example of a theoretical pmf (not the empirical histogram) plotted by matlab.
% matlab code to plot the pmf of a bernoulli
p = 0.3;
x = [0,1];
f = binopdf(x,1,p);
stem(x, f, ‘bo’, ‘linewidth’, 8);
in python, we construct a random variable rv. with rv, we can call its pmf rv.pmf :
# python code to plot the pmf of a bernoulli
import numpy as np
import matplotlib.pyplot as plt
import scipy.stats as stats
p = 0.3
rv = stats.bernoulli(p)
x = np.linspace(0, 1, 2)
f = rv.pmf(x)
plt.plot(x, f, ‘bo’, ms=10);
plt.vlines(x, 0, f, colors=‘b’, lw=5, alpha=0.5);
139chapter 3. discrete random variables
when will a bernoulli random variable have the maximum variance?
let us take a look at the variance of the bernoulli random variable. for any given p, the
variance is p(1−p). this is a quadratic equation. if we let v(p) =p(1−p), we can show that
the maximum is attained at p= 1/2. to see this, take the derivative of v(p) with respect
top. this will give usd
dpv(p) = 1 −2p. equating to zero yields 1 −2p= 0, so p= 1/2.
we know that p= 1/2 is a maximum and not a minimum point because the second order
derivative v′′(p) =−2, which is negative. therefore v(p) is maximized at p= 1/2. now,
since 0 ≤p≤1, we also know that v(0) = 0 and v(1) = 0. therefore, the variance is
minimized at p= 0 and p= 1.figure 3.24 shows a graph of the variance.
figure 3.24: the variance of a bernoulli reaches maximum at p= 1/2.
does this result make sense? why is the variance maximized at p= 1/2? if we think
about this problem more carefully, we realize that a bernoulli random variable represents a
coin-flip experiment. if the coin is biased such that it always gives heads, on the one hand,
it is certainly a bad coin. however, on the other hand, the variance is zero because there
is nothing to vary; you will certainly get heads. the same situation happens if the coin is
biased towards tails. however, if the coin is fair, i.e., p= 1/2, then the variance is large
because we only have a 50% chance of getting a head or a tail whenever we flip a coin.
nothing is certain in this case. therefore, the maximum variance happening at p= 1/2
matches our intuition.
rademacher random variable
a slight variation of the bernoulli random variable is the rademacher random variable ,
which has two states: +1 and −1. the probability getting +1 and −1 is 1 /2. therefore, the
pmf of a rademacher random variable is
px(−1) =1
2,and px(+1) =1
2.
practice exercise 3.8 . show that if xis a rademacher random variable then
(x+ 1)/2∼bernoulli(1 /2). also show the converse: if y∼bernoulli(1 /2) then 2 y−1
is a rademacher random variable.
solution . since xcan either be +1 or −1, we show that if x= +1 then ( x+1)/2 = 1
and if x=−1 then ( x+ 1)/2 = 0. the probabilities of getting +1 and −1 are equal.
thus, the probabilities of getting ( x+ 1)/2 = 1 and 0 are also equal. so the resulting
random variable is bernoulli(1/2). the other direction can be proved similarly.
1403.5. common discrete random variables
bernoulli in social networks: the erd˝ os-r´ enyi graph
the study of networks is a big branch of modern data science. it includes social networks,
computer networks, traffic networks, etc. the history of network science is very long, but
one of the most basic models of a network is the erd˝ os-r´ enyi graph, named after paul
erd˝ os and alfr´ ed r´ enyi. the underlying probabilistic model of the erd˝ os-r´ enyi graph is
the bernoulli random variable.
to see how a graph can be constructed from a bernoulli random variable, we first
introduce the concept of a graph . a graph contains two elements: nodes and edges. for
node iand node j, we denote the edge connecting iandjasaij. therefore, if we have n
nodes, then we can construct a matrix aof size n×n. we call this matrix the adjacency
matrix . for example, the adjacency matrix
a=
0 1 1 0
1 0 0 0
1 0 0 1
0 0 1 0

will have edges for node pairs (1 ,2), (1 ,3), and (3 ,4). note that in this example we assume
that the adjacency matrix is symmetric, meaning that the graph is undirected. the “1” in
the adjacency matrix indicates there is an edge, and “0” indicates there is no edge. so a
represents a binary graph.
the erd˝ os-r´ enyi graph model says that the probability of getting an edge is an inde-
pendent bernoulli random variable. that is
aij∼bernoulli( p),
fori < j . if we model the graph in this way, then the parameter pwill control the density
of the graph. high values of pmean that there is a higher chance for an edge to be present.
-2 0 2-3-2-1012p = 0.3
  1
  2  3
  4
  5  6  7
  8  9  10
  11  12
  13
  14  15  16  17  18  19  20
  21  22  23  24
  25  26  27
  28  29
  30  31
  32  33
  34  35
  36
  37
  38  39
  40
-2 0 2-4-3-2-10123p = 0.5
  1
  2  3  4
  5  6  7
  8
  9
  10  11
  12  13  14  15
  16  17
  18   19  20
  21
  22
  23  24  25
  26  27  28
  29  30
  31  32  33
  34
  35
  36
  37  38
  39  40
-4 -2 0 2 4-4-3-2-10123p = 0.7
  1
  2
  3  4
  5  6
  7
  8  9  10
  11  12
  13  14
  15  16  17
  18
  19  20  21
  22  23
  24
  25  26  27  28
  29  30  31
  32  33
  34  35  36
  37  38  39
  40
-4 -2 0 2 4-4-2024p = 0.9
  1
  2  3
  4  5
  6  7
  8
  9  10
  11  12  13
  14  15
  16
  17  18
  19  20
  21  22
  23  24
  25
  26  27  28
  29
  30  31  32  33  34  35
  36
  37  38
  39  40
figure 3.25: the erd˝ os-r´ enyi graph. [top] the graphs. [bottom] the adjacency matrices.
141chapter 3. discrete random variables
to illustrate the idea of an erd˝ os-r´ enyi graph, we show in figure 3.25 a graph of
40 nodes. the edges are randomly selected by flipping a bernoulli random variable with
parameter p= 0.3,0.5,0.7,0.9. as we can see in the figure, a small value of pgives a graph
with very sparse connectivity, whereas a large value of pgives a very densely connected
graph. the bottom row of figure 3.25 shows the corresponding adjacency matrices. here,
a white pixel denotes “1” in the matrix and a black pixel denotes “0” in the matrix.
while erd˝ os-r´ enyi graphs are elementary, their variations can be realistic models of
social networks. the stochastic block model is one such model. in a stochastic block model,
nodes form small communities within a large network. for example, there are many majors
in a university. students within the same major tend to have more interactions than with
students of another major. the stochastic block model achieves this goal by partitioning
the nodes into communities. within each community, the nodes can have a high degree of
connectivity. across different communities, the connectivity will be much lower. figure 3.26
illustrates a network and the corresponding adjacency matrix. in this example, the network
has three communities.
-4 -3 -2 -1 0 1 2 3 4-6-4-2024
  1  2
  3  4  5
  6  7
  8
  9  10
  11  12
  13  14
  15
  16
  17  18  19
  20  21  22   23  24  25
  26  27  28
  29  30  31  32
  33
  34  35  36  37
  38  39
  40  41   42  43
  44  45
  46  47
  48
  49  50
  51
  52
  53  54  55
  56  57  58  59  60
  61   62  63
  64  65  66  67
  68  69
  70  71  72
  73  74  75
  76  77  78  79
  80
  81  82  83  84
  85  86  87
  88  89
  90
  91  92  93
  94  95
  96
  97  98  99  100
figure 3.26: a stochastic block model containing three communities. [left] the graph. [right] the
adjacency matrix.
in network analysis, one of the biggest problems is determining the community struc-
ture and recovering the underlying probabilities. the former task is about grouping the
nodes into blocks. this is a nontrivial problem because in practice the nodes are never
arranged nicely, as shown in figure 3.26 . for example, why should alice be node 1 and
bob be node 2? since we never know the correct ordering of the nodes, partitioning the
nodes into blocks requires various estimation techniques such as clustering or iterative esti-
mation. recovering the underlying probability is also not easy. given an adjacency matrix,
why can we assume that the underlying network is a stochastic block model? even if the
model is correct, there will be imperfect grouping in the previous step. as such, estimat-
ing the underlying probability in the presence of these uncertainties would pose additional
challenges.
today, network analysis remains one of the hottest areas in data science. its importance
derives from its broad scope and impact. it can be used to analyze social networks, opinion
polls, marketing, or even genome analysis. nevertheless, the starting point of these advanced
subjects is the bernoulli random variable, the random variable of a coin flip!
1423.5. common discrete random variables
3.5.2 binomial random variable
suppose we flip the coin ntimes count the number of heads. since each coin flip is a random
variable (bernoulli), the sum is also a random variable. it turns out that this new random
variable is the binomial random variable .
definition 3.9. letxbe abinomial random variable . then, the pmf of xis
px(k) =n
k
pk(1−p)n−k, k = 0,1, . . . , n,
where 0< p < 1is the binomial parameter, and nis the total number of states. we
write
x∼binomial( n, p)
to say that xis drawn from a binomial distribution with a parameter pof size n.
to understand the meaning of a binomial random variable, consider a simple experiment
consisting of flipping a coin three times. we know that all possible cases are hhh, hht,
hth, thh, tth, tht, htt and ttt. now, suppose we define x= number of heads.
we want to write down the probability mass function. effectively, we ask: what is the
probability of getting 0 head, one head, two heads, and three heads? we can, of course,
count and get the answer right away for a fair coin. however, suppose the coin is unfair,
i.e., the probability of getting a head is pwhereas that of a tail is 1 −p. the probability of
getting each of the 8 cases is shown in figure 3.27 below.
figure 3.27: the probability of getting kheads out of n= 3coins.
here are the detailed calculations. let us start with x= 3.
px(3) =p[{hhh}]
=p[{h} ∩ {h} ∩ {h}]
(a)=p[{h}]p[{h}]p[{h}]
(b)=p3,
where ( a) holds because the three events are independent. (recall that if aandbare
independent then p[a∩b] =p[a]p[b].) (b) holds because each p[{h}] =pby definition.
with exactly the same argument, we can show that px(0) =p[{ttt}] = (1 −p)3.
143chapter 3. discrete random variables
now, let us look at px(2), i.e., 2 heads. this probability can be calculated as follows:
px(2) =p[{hht} ∪ {hth} ∪ {thh}]
(c)=p[{hht}] +p[{hth}] +p[{thh}]
(d)=p2(1−p) +p2(1−p) +p2(1−p) = 3 p2(1−p),
where ( c) holds because the three events hht, hth and thh are disjoint in the sample
space. note that we are not using the independence argument in ( c) but the disjoint argu-
ment. we should not confuse the two. the step in ( d) uses independence, because each coin
flip is independent.
the above calculation shows an interesting phenomenon: although the three events
hht, hth, and thh are different (in fact, disjoint), the number of heads in all the cases
is the same. this happens because when counting the number of heads, the ordering of the
heads and tails does not matter. so the same problem can be formulated as finding the
number of combinations of {2 heads and 1 tail }, which in our case is 3
2
= 3.
to complete the story, let us also try px(1). this probability is
px(1) =p[{tth} ∪ {htt} ∪ {tht}] = 3p(1−p)2.
again, we see that the combination 3
1
= 3 appears in front of the p(1−p)2.
in general, the way to interpret the binomial random variable is to decouple the prob-
abilities p, (1−p), and the number of combinations n
k
:
px(k) =n
k
|{z }
number of combinationspk
|{z}
prob getting kh’s(1−p)n−k
| {z }
prob getting n−kt’s.
the running index kshould go with 0 ,1, . . . , n . it starts with 0 because there could be zero
heads in the sample space. furthermore, we note that in this definition, two parameters are
driving a binomial random variable: the number of bernoulli trials nand the underlying
probability for each coin flip p. as such, the notation for a binomial random variable is
binomial( n, p), with two arguments.
the histogram of a binomial random variable is shown in figure 3.28 (a). here, we con-
sider the example where n= 10 and p= 0.5. to generate the histogram, we use 5000 samples.
in matlab and python, generating binomial random variables as in figure 3.28 (a) can
be done by calling binornd andnp.random.binomial .
% matlab code to generate 5000 binomial random variables
p = 0.5;
n = 10;
x = binornd(n,p,[5000,1]);
[num, ~] = hist(x, 10);
bar( num,‘facecolor’,[0.4, 0.4, 0.8]);
# python code to generate 5000 binomial random variables
import numpy as np
import matplotlib.pyplot as plt
1443.5. common discrete random variables
1 2 3 4 5 6 7 8 9 10020040060080010001200
00.050.10.150.20.25
0 2 4 6 8 10
(a) histogram based on 5000 samples (b) pmf
figure 3.28: an example of a binomial distribution with n= 10 ,p= 0.5.
p = 0.5
n = 10
x = np.random.binomial(n,p,size=5000)
plt.hist(x,bins=‘auto’);
generating the ideal pmf of a binomial random variable as shown in figure 3.28 (b)
can be done by calling binopdf in matlab. in python, we can define a random variable
rvthrough stats.binom , and call the pmf using rv.pmf .
% matlab code to generate a binomial pmf
p = 0.5;
n = 10;
x = 0:10;
f = binopdf(x,n,p);
stem(x, f, ’o’, ’linewidth’, 8, ’color’, [0.8, 0.4, 0.4]);
# python code to generate a binomial pmf
import numpy as np
import matplotlib.pyplot as plt
import scipy.stats as stats
p = 0.5
n = 10
rv = stats.binom(n,p)
x = np.arange(11)
f = rv.pmf(x)
plt.plot(x, f, ’bo’, ms=10);
plt.vlines(x, 0, f, colors=’b’, lw=5, alpha=0.5);
the shape of the binomial pmf is shown in figure 3.29 . in this set of figures, we vary
one of the two parameters nandpwhile keeping the other fixed. in figure 3.29 (a), we fix
n= 60 and plot three sets of p= 0.1,0.5,0.9. for small pthe pmf is skewed towards the
left, and for large pthe pmf is skewed toward the right. figure 3.29 (b) shows the pmf
145chapter 3. discrete random variables
for a fixed p= 0.5. as we increase n, the centroid of the pmf moves towards the right.
thus we should expect the mean of a binomial random variable to increase with p. another
interesting observation is that as nincreases, the shape of the pmf approaches the gaussian
function (the bell-shaped curve). we will explain the reason for this when we discuss the
central limit theorem.
00.050.10.150.2
0 10 20 30 40 50 60p = 0.1
p = 0.5
p = 0.9
00.10.20.30.4
0 10 20 30 40 50 60n = 5
n = 50
n = 100
(a)n= 60 (b) p= 0.5
figure 3.29: pmfs of a binomial random variable x∼binomial (n, p). (a) we assume that n= 60 . by
varying the probability p, we see that the pmf shifts from the left to the right, and the shape changes.
(b) we assume that p= 0.5. by varying the number of trials, the pmf shifts and the shape becomes
more “bell-shaped.”
the expectation, second moment, and variance of a binomial random variable are
summarized in theorem 3.7.
theorem 3.7. ifx∼binomial( n, p), then
e[x] =np,
e[x2] =np(np+ (1−p)),
var[x] =np(1−p).
we will prove that e[x] =npusing the first principle. for e[x2] and var[ x], we will skip
the proofs here and will introduce a “shortcut” later.
proof . let us start with the definition.
e[x] =nx
k=0k·n
k
pk(1−p)n−k
=nx
k=0k·n!
k!(n−k)!pk(1−p)n−k
= 0·n!
0!(n−0)!p0(1−p)n−0
| {z }
0+nx
k=1k·n!
k!(n−k)!pk(1−p)n−k
=nx
k=1n!
(k−1)!(n−k)!pk(1−p)n−k.
1463.5. common discrete random variables
note that we have shifted the index from k= 0 to k= 1. now let us apply a trick:
e[x] =nx
k=1n!
(k−1)!(n−k)!pk(1−p)n−k
=nx
k=1n!
(k−1)!(n−k−1 + 1)!pk(1−p)n−k.
using this trick, we can show that
nx
k=1n!
(k−1)!(n−k−1 + 1)!pk(1−p)n−k
=nx
k=1n!
(k−1)!((n−1)−(k−1))!pk(1−p)n−k
=nx
k=1n(n−1)!
(k−1)!((n−1)−(k−1))!pk(1−p)n−k
=npnx
k=1(n−1)!
(k−1)!((n−1)−(k−1))!pk−1(1−p)n−k
with a simple substitution of ℓ=k−1, the above equation can be rewritten as
e[x] =np·n−1x
ℓ=0(n−1)!
ℓ!((n−1)−ℓ)!pℓ(1−p)n−1−ℓ
=np·n−1x
ℓ=0n−1
k
pℓ(1−p)n−1−ℓ
| {z }
summing pmf of binomial( n−1,p)=np.
□
in matlab, the mean and variance of a binomial random variable can be found by
calling the command binostat(n,p) (matlab).
in python, the command is rv = stats.binom(n,p) followed by calling rv.stats .
% matlab code to compute the mean and var of a binomial rv
p = 0.5;
n = 10;
[m,v] = binostat(n, p)
# python code to compute the mean and var of a binomial rv
import scipy.stats as stats
p = 0.5
n = 10
rv = stats.binom(n,p)
m, v = rv.stats(moments=‘mv’)
print(m, v)
147chapter 3. discrete random variables
an alternative view of the binomial random variable . as we discussed, the origin of a
binomial random variable is the sum of a sequence of bernoulli random variables. because
of this intrinsic definition, we can derive some useful results by exploiting this fact. to do so,
let us define i1, . . . , i nas a sequence of bernoulli random variables with ij∼bernoulli( p)
for all i= 1, . . . , n . then the resulting variable
x=i1+i2+···+in
is a binomial random variable of size nand parameter p. using this definition, we can
compute the expectation as follows:
e[x] =e[i1+i2+···+in]
(a)=e[i1] +e[i2] +···+e[in]
=p+p+···+p
=np.
in this derivation, the step ( a) depends on a useful fact about expectation (which we have not
yet proved): for any two random variables xandy, it holds that e[x+y] =e[x]+e[y].
therefore, we can show that the expectation of xisnp. this line of argument not only
simplifies the proof but also provides a good intuition of the expectation. if each coin flip
has an expectation of e[ii] =p, then the expectation of the sum should be simply ntimes
ofp, given np.
how about the variance? again, we are going to use a very useful fact about variance:
if two random variables xandyare independent, then var[ x+y] = var[ x] + var[ y].
with this result, we can show that
var[x] = var[ i1+···+in]
= var[ i1] +···+ var[ in]
=p(1−p) +···+p(1−p)
=np(1−p).
finally, using the fact that var[ x] =e[x2]−µ2, we can show that
e[x2] = var[ x] +µ2
=np(1−p) + (np)2.
practice exercise 3.9 . show that the binomial pmf sums to 1.
solution . we use the binomial theorem to prove this result:
nx
k=0px(k) =nx
k=0n
k
pk(1−p)n−k= (p+ (1−p))n= 1.
the cdf of the binomial random variable is not very informative. it is basically the
cumulative sum of the pmf:
fx(k) =kx
ℓ=0n
ℓ
pℓ(1−p)n−ℓ.
1483.5. common discrete random variables
00.050.10.150.2
0 5 10 15 20 25 30
0 5 10 15 20 25 3000.20.40.60.81
figure 3.30: pmf and cdf of a binomial random variable x∼binomial (n, p).
the shapes of the pmf and the cdf is shown in figure 3.30 .
in matlab, plotting the cdf of a binomial can be done by calling the function
binocdf . you may also call f = binopdf(x,n,p) , and define f = cumsum(f) as the cumu-
lative sum of the pmf. in python, the corresponding command is rv = stats.binom(n,p)
followed by rv.cdf .
% matlab code to compute the mean and var of a binomial rv
x = 0:10;
p = 0.5;
n = 10;
f = binocdf(x,n,p);
figure; stairs(x,f,‘.-’,‘linewidth’,4,‘markersize’,30);
# python code to compute the mean and var of a binomial rv
import numpy as np
import matplotlib.pyplot as plt
import scipy.stats as stats
p = 0.5
n = 10
rv = stats.binom(n,p)
x = np.arange(11)
f = rv.cdf(x)
plt.plot(x, f, ’bo’, ms=10);
plt.vlines(x, 0, f, colors=’b’, lw=5, alpha=0.5);
3.5.3 geometric random variable
in some applications, we are interested in trying a binary experiment until we succeed. for
example, we may want to keep calling someone until the person picks up the call. in this
case, the random variable can be defined as the outcome of many failures followed by a final
success. this is called the geometric random variable .
definition 3.10. letxbe ageometric random variable . then, the pmf of xis
px(k) = (1 −p)k−1p, k = 1,2, . . . ,
149chapter 3. discrete random variables
where 0< p < 1is the geometric parameter. we write
x∼geometric( p)
to say that xis drawn from a geometric distribution with a parameter p.
a geometric random variable is easy to understand. we define it as bernoulli trials with
k−1 consecutive failures followed by one success. this can be seen from the definition:
px(k) = (1 −p)k−1
| {z }
k−1 failuresp|{z}
final success.
note that in geometric random variables, there is no n
k
because we must have k−1
consecutive failures before one success. there is no alternative combination of the sequence.
the histogram and pmf of a geometric random variable are illustrated in figure 3.31 .
here, we assume that p= 0.5.
0 1 2 3 4 5 6 7 8 9 10050010001500200025003000
00.10.20.30.40.5
0 2 4 6 8 10
(a) histogram based on 5000 samples (b) pmf
figure 3.31: an example of a geometric distribution with p= 0.5.
in matlab, generating geometric random variables can be done by calling the com-
mands geornd . in python, it is np.random.geometric .
% matlab code to generate 1000 geometric random variables
p = 0.5;
x = geornd(p,[5000,1]);
[num, ~] = hist(x, 0:10);
bar(0:10, num, ‘facecolor’,[0.4, 0.4, 0.8]);
# python code to generate 1000 geometric random variables
import numpy as np
import matplotlib.pyplot as plt
p = 0.5
x = np.random.geometric(p,size=1000)
plt.hist(x,bins=‘auto’);
to generate the pmf plots, in matlab we call geopdf and in python we call
rv = stats.geom followed by rv.pmf .
1503.5. common discrete random variables
% matlab code to generate geometric pmf
p = 0.5; x = 0:10;
f = geopdf(x,p);
stem(x, f, ‘o’, ‘linewidth’, 8, ‘color’, [0.8, 0.4, 0.4]);
# python code to generate 1000 geometric random variables
import numpy as np
import matplotlib.pyplot as plt
import scipy.stats as stats
x = np.arange(1,11)
rv = stats.geom(p)
f = rv.pmf(x)
plt.plot(x, f, ‘bo’, ms=8, label=‘geom pmf’)
plt.vlines(x, 0, f, colors=‘b’, lw=5, alpha=0.5)
practice exercise 3.10 . show that the geometric pmf sums to one.
solution . we can apply infinite series to show the result:
∞x
k=1px(k) =∞x
k=1(1−p)k−1p
=p·∞x
k=1(1−p)k−1, ℓ =k−1
=p·∞x
ℓ=0(1−p)ℓ
=p·1
1−(1−p)= 1.
it is interesting to compare the shape of the pmfs for various values of p. infigure 3.32
we show the pmfs. we vary the parameter p= 0.25,0.5,0.9. for small p, the pmf starts
with a low value and decays at a slow speed. the opposite happens for a large p, where the
pmf starts with a high value and decays rapidly.
furthermore, we can derive the following properties of the geometric random variable.
theorem 3.8. ifx∼geometric( p), then
e[x] =1
p,e[x2] =2
p2−1
p, (3.16)
var[x] =1−p
p2.
proof . we will prove that the mean is 1 /pand leave the second moment and variance as
151chapter 3. discrete random variables
00.20.40.60.81
0 2 4 6 8p = 0.25
00.20.40.60.81
0 2 4 6 8p = 0.5
00.20.40.60.81
0 2 4 6 8p = 0.9
figure 3.32: pmfs of a geometric random variable x∼geometric (p).
an exercise.
e[x] =∞x
k=1kp(1−p)k−1=p ∞x
k=1k(1−p)k−1!
(a)=p1
(1−(1−p))2
=1
p,
where ( a) follows from the infinite series identity in chapter 1.
□
3.5.4 poisson random variable
in many physical systems, the arrivals of events are typically modeled as a poisson ran-
dom variable, e.g., photon arrivals, electron emissions, and telephone call arrivals. in social
networks, the number of conversations per user can also be modeled as a poisson. in e-
commerce, the number of transactions per paying user is again modeled using a poisson.
definition 3.11. letxbe apoisson random variable . then, the pmf of xis
px(k) =λk
k!e−λ, k = 0,1,2, . . . ,
where λ >0is the poisson rate. we write
x∼poisson( λ)
to say that xis drawn from a poisson distribution with a parameter λ.
in this definition, the parameter λdetermines the rate of the arrival. the histogram and
pmf of a poisson random variable are illustrated in figure 3.33 . here, we assume that
λ= 1.
the matlab code and python code used to generate the histogram are shown below.
% matlab code to generate 5000 poisson numbers
lambda = 1;
x = poissrnd(lambda,[5000,1]);
1523.5. common discrete random variables
0 1 2 3 4 5 6 7 8 9 100500100015002000
00.10.20.30.4
0 2 4 6 8 10
(a) histogram based on 5000 samples (b) pmf
figure 3.33: an example of a poisson distribution with λ= 1.
[num, ~] = hist(x, 0:10);
bar(0:10, num, ‘facecolor’,[0.4, 0.4, 0.8]);
# python code to generate 5000 poisson random variables
import numpy as np
import matplotlib.pyplot as plt
lambd = 1
x = np.random.poisson(lambd,size=5000)
plt.hist(x,bins=‘auto’);
for the pmf, in matlab we can call poisspdf , and in python we can call rv.pmf
with rv = stats.poisson .
% matlab code to plot the poisson pmf
lambda = 1;
x = 0:10;
f = poisspdf(x,lambda);
stem(x, f, ‘o’, ‘linewidth’, 8, ‘color’, [0.8, 0.4, 0.4]);
# python code to plot the poisson pmf
import numpy as np
import matplotlib.pyplot as plt
import scipy.stats as stats
x = np.arange(0,11)
rv = stats.poisson(lambd)
f = rv.pmf(x)
plt.plot(x, f, ‘bo’, ms=8, label=‘geom pmf’)
plt.vlines(x, 0, f, colors=‘b’, lw=5, alpha=0.5)
the shape of the poisson pmf changes with λ. as illustrated in figure 3.34 ,px(k) is
more concentrated at lower values for smaller λand becomes spread out for larger λ. thus,
we should expect that the mean and variance of a poisson random variable will change
153chapter 3. discrete random variables
together as a function of λ. in the same figure, we show the cdf of a poisson random
variable. the cdf of a poisson is
fx(k) =p[x≤k] =kx
ℓ=0λℓ
ℓ!e−λ. (3.17)
00.10.20.30.4
0 5 10 15 20 = 1
 = 4
 = 10
0 5 10 15 2000.20.40.60.81
 = 1
 = 4
 = 10
figure 3.34: a poisson random variable using different λ’s. [left] probability mass function px(k).
[right] cumulative distribution function fx(k).
example 3.18 . let xbe a poisson random variable with parameter λ. find p[x > 4]
andp[x≤5].
solution .
p[x > 4] = 1 −p[x≤4] = 1 −4x
k=0λk
k!e−λ,
p[x≤5] =5x
k=0λk
k!e−λ.
practice exercise 3.11 . show that the poisson pmf sums to 1.
solution . we use the exponential series to prove this result:
∞x
k=0px(k) =∞x
k=0λk
k!e−λ=e−λ·∞x
k=0λk
k!
|{z}
=eλ= 1.
poisson random variables in practice
(1) computational photography . in computational photography, the poisson random vari-
able is one of the most widely used models for photon arrivals. the reason pertains to the
1543.5. common discrete random variables
origin of the poisson random variable, which we will discuss shortly. when photons are emit-
ted from the source, they travel through the medium as a sequence of independent events.
during the integration period of the camera, the photons are accumulated to generate a
voltage that is then translated to digital bits.
figure 3.35: the poisson random variable can be used to model photon arrivals.
if we assume that the photon arrival rate is α(photons per second), and suppose that
the total amount of integration time is t, then the average number of photons that the sensor
can see is αt. let xbe the number of photons seen during the integration time. then if we
follow the poisson model, we can write down the pmf of x:
p[x=k] =(αt)k
k!e−αt.
therefore, if a pixel is bright, meaning that αis large, then xwill have a higher likelihood
of landing on a large number.
(2) traffic model . the poisson random variable can be used in many other problems. for
example, we can use it to model the number of passengers on a bus or the number of spam
phone calls. the required modification to figure 3.35 is almost trivial: merely replace the
photons with your favorite cartoons, e.g., a person or a phone, as shown in figure 3.36 . in
the united states, shared-ride services such as uber and lyft need to model the vacant cars
and the passengers. as long as they have an arrival rate and certain degrees of independence
between events, the poisson random variable will be a good model.
as you can see from these examples, the poisson random variable has broad applica-
bility. before we continue our discussion of its applications, let us introduce a few concepts
related to the poisson random variable.
properties of a poisson random variable
we now derive the mean and variance of a poisson random variable.
theorem 3.9. ifx∼poisson( λ), then
e[x] =λ, e[x2] =λ+λ2, (3.18)
var[x] =λ.
155chapter 3. discrete random variables
figure 3.36: the poisson random variable can be used to model passenger arrivals and the number of
phone calls, and can be used by uber or lyft to provide shared rides.
proof . let us first prove the mean. it can be shown that
e[x] =∞x
k=0k·λk
k!e−λ=∞x
k=1λk
(k−1)!e−λ
=λe−λ∞x
k=1λk−1
(k−1)!=λe−λ∞x
ℓ=0λℓ
ℓ!=λe−λeλ=λ.
the second moment can be computed as
e[x2] =∞x
k=0k2·λk
k!e−λ
=∞x
k=0k·λk
(k−1)!e−λ
=∞x
k=0(k−1 + 1) ·λk
(k−1)!e−λ
=∞x
k=1(k−1)·λk
(k−1)!e−λ+∞x
k=1λk
(k−1)!e−λ
=λ2·∞x
k=2λk−2e−λ
(k−2)!
|{z}
=1+λ·∞x
k=1λk−1e−λ
(k−1)!
|{z}
=1.
the variance can be computed using var[ x] =e[x2]−µ2.
□
to compute the mean and variance of a poisson random variable, we can call poisstat
in matlab and rv.stats(moments=‘mv’) in python.
% matlab code to compute poisson statistics
lambda = 1;
[m,v] = poisstat(lambda);
1563.5. common discrete random variables
# python code to compute poisson statistics
import scipy.stats as stats
lambd = 1
rv = stats.poisson(lambd)
m, v = rv.stats(moments=’mv’)
the poisson random variable is special in the sense that the mean and the variance are
equal. that is, if the mean arrival number is higher, the variance is also higher. this is very
different from some other random variables, e.g., the normal random variable where the mean
and variance are independent. for certain engineering applications such as photography, this
plays an important role in defining the signal-to-noise ratio. we will come back to this point
later.
origin of the poisson random variable
we now address one of the most important questions about the poisson random variable:
where does it come from? answering this question is useful because the derivation process
will reveal the underlying assumptions that lead to the poisson pmf. when you change
the problem setting, you will know when the poisson pmf will hold and when the poisson
pmf will fail.
our approach to addressing this problem is to consider the photon arrival process.
(as we have shown, there is conceptually no difference if you replace the photons with
pedestrians, passengers, or phone calls.) our derivation follows the argument of j. goodman,
statistical optics , section 3.7.2.
to begin with, we consider a photon arrival process. the total number of photons
observed over an integration time tis defined as x(t). because x(t) is a poisson random
variable, its arguments must be integers. the probability of observing x(t) =kis therefore
p[x(t) =k].figure 3.37 illustrates the notations and concepts.
figure 3.37: notations for deriving the poisson pmf.
we propose three hypotheses with the photon arrival process:
for sufficiently small ∆ t, the probability of a small impulse occurring in the time
interval [ t, t+ ∆t] is equal to the product of ∆ tand the rate λ, i.e.,
p[x(t+ ∆t)−x(t) = 1] = λ∆t.
this is a linearity assumption, which typically holds for a short duration of time.
157chapter 3. discrete random variables
for sufficiently small ∆ t, the probability that more than one impulse falls in ∆ tis
negligible. thus, we have that p[x(t+ ∆t)−x(t) = 0] = 1 −λ∆t.
the number of impulses in non-overlapping time intervals is independent.
the significance of these three hypotheses is that if the underlying photon arrival process
violates any of these assumptions, then the poisson pmf will not hold. one example is the
presence of scattering effects, where a photon has a certain probability of going off due to
the scattering medium and a certain probability of coming back. in this case, the events will
no longer be independent.
assuming that these hypotheses hold, then at time t+∆t, the probability of observing
x(t+ ∆t) =kcan be computed as
p[x(t+ ∆t) =k]
=p[x(t) =k]· (1−λ∆t)|{z}
=p[x(t+∆t)−x(t)=0]+p[x(t) =k−1]· (λ∆t)|{z}
=p[x(t+∆t)−x(t)=1]
=p[x(t) =k]−p[x(t) =k]λ∆t+p[x(t) =k−1]λ∆t.
by rearranging the terms we show that
p[x(t+ ∆t) =k]−p[x(t) =k]
∆t=λ
p[x(t) =k−1]−p[x(t) =k]
.
setting the limit of ∆ t→0, we arrive at an ordinary differential equation
d
dtp[x(t) =k] =λ
p[x(t) =k−1]−p[x(t) =k]
. (3.19)
we claim that the poisson pmf, i.e.,
p[x(t) =k] =(λt)k
k!e−λt,
would solve this differential equation. to see this, we substitute the pmf into the equation.
the left-hand side gives us
d
dtp[x(t) =k] =d
dt(λt)k
k!e−λt
=λk(λt)k−1
k!e−λt+ (−λ)(λt)k
k!e−λt
=λ(λt)k−1
k!e−λt−λ(λt)k
k!e−λt
=λ
p[x(t) =k−1]−p[x(t) =k]
,
which is the right-hand side of the equation. to retrieve the basic form of poisson, we can
just set t= 1 in the pmf so that
p[x(1) = k] =λk
k!e−λ.
1583.5. common discrete random variables
the origin of poisson random variables
we assume independent arrivals.
probability of seeing one event is linear with the arrival rate.
time interval is short enough so that you see either one event or no event.
poisson is derived by solving a differential equation based on these assumptions.
poisson becomes invalid when these assumptions are violated, e.g., in the case
of scattering of photons due to turbid medium.
there is an alternative approach to deriving the poisson pmf. the idea is to drive
the parameter nin the binomial random variable to infinity while pushing pto zero. in this
limit, the binomial pmf will converge to the poisson pmf. we will discuss this shortly.
however, we recommend the physics approach we have just described because it has a rich
meaning and allows us to validate our assumptions.
poisson approximation to binomial
we present one additional result about the poisson random variable. the result shows that
poisson can be regarded as a limiting distribution of a binomial random variable.
theorem 3.10. (poisson approximation to binomial) . for small pand large n,
n
k
pk(1−p)n−k≈λk
k!e−λ,
where λdef=np.
before we prove the result, let us see how close the approximation can be. in figure 3.38 ,
we show a binomial distribution and a poisson approximation. the closeness of the approx-
imation can easily be seen.
in matlab, the code to approximate a binomial distribution with a poisson formula
is shown below. here, we draw 10,000 random binomial numbers and plot their histogram.
on top of the plot, we use poisspdf to compute the poisson pmf. this gives us figure 3.38 .
a similar set of commands can be called in python.
% matlab code to approximate binomial using poisson
n = 1000; p = 0.05;
x = binornd(n,p,[10000,1]);
t = 0:100;
[num,val] = hist(x,t);
lambda = n*p;
f_pois = poisspdf(t,lambda);
bar(num/10000,‘facecolor’,[0.9 0.9 0],‘barwidth’,1); hold on;
plot(f_pois, ‘linewidth’, 4);
159chapter 3. discrete random variables
00.020.040.06probability
0 20 40 60 80 100 120
kbinomial, n = 5000, p = 0.01
poisson,  = 50
figure 3.38: poisson approximation of binomial distribution.
# python code to approximate binomial using poisson
import numpy as np
import matplotlib.pyplot as plt
import scipy.stats as stats
n = 1000; p = 0.05
rv1 = stats.binom(n,p)
x = rv1.rvs(size=10000)
plt.figure(1); plt.hist(x,bins=np.arange(0,100));
rv2 = stats.poisson(n*p)
f = rv2.pmf(bin)
plt.figure(2); plt.plot(f);
proof . let λ=np. then,
n
k
pk(1−p)n−k=n!
k!(n−k)!λ
nk
1−λ
nn−k
=λk
k!n(n−1)···(n−k+ 1)
n·n···n
1−λ
nn−k
=λk
k!(1)
1−1
n
···
1−k−1
n
| {z }
→1 asn→∞
1−λ
n−k
|{z}
→1 asn→∞
1−λ
nn
=λk
k!
1−λ
nn
.
we claim that 
1−λ
nn→e−λ. this can be proved by noting that
log(1 + x)≈x, x ≪1.
it then follows that log 
1−λ
n
≈ −λ
n. hence, 
1−λ
nn≈e−λ
□
1603.5. common discrete random variables
example 3.19 . consider an optical communication system. the bit arrival rate is 109
bits/sec, and the probability of having one error bit is 10−9. suppose we want to find
the probability of having five error bits in one second.
letxbe the number of error bits. in one second there are 109bits. since we
do not know the location of these 5 bits, we have to enumerate all possibilities. this
leads to a binomial distribution. using the binomial distribution, we know that the
probability of having kerror bits is
p[x=k] =n
k
pk(1−p)n−k
=109
k
(10−9)k(1−10−9)109−k.
this quantity is difficult to calculate in floating-point arithmetic.
using the poisson to binomial approximation, we can see that the probability can
be approximated by
p[x=k]≈λk
k!e−λ,
where λ=np= 109(10−9) = 1. setting k= 5 yields p[x= 5]≈0.003.
photon arrival statistics
poisson random variables are useful in computer vision, but you may skip this discussion
if it is your first reading of the book.
the strong connection between poisson statistics and physics makes the poisson ran-
dom variable a very good fit for many physical experiments. here we demonstrate an appli-
cation in modeling photon shot noise.
an image sensor is a photon sensitive device which is used to detect incoming photons.
in the simplest setting, we can model a pixel in the object plane as xm,n, for some 2d
coordinate [ m, n]∈r2. written as an array, an m×nimage in the object plane can be
visualized as
x= object =
x1,1x1,2··· x1,n
............
xm,1xm,2···xm,n
.
without loss of generality, we assume that xm,nis normalized so that 0 ≤xm,n≤1 for
every coordinate [ m, n]. to model the brightness, we multiply xm,nby a scalar α > 0. if
a pixel αxm,nhas a large value, then it is a bright pixel; conversely, if αxm,nhas a small
value, then it is a dark pixel. at a particular pixel location [ m, n]∈r2, the observed pixel
value ym,nis a random variable following the poisson statistics. this situation is illustrated
161chapter 3. discrete random variables
infigure 3.39 , where we see that an object-plane pixel will generate an observed pixel
through the poisson pmf.1
figure 3.39: the image formation process is governed by the poisson random variable. given a pixel
in the object plane xm,n, the observed pixel ym,nis a poisson random variable with mean αxm,n.
therefore, a brighter pixel will have a higher poisson mean, whereas a darker pixel will have a lower
poisson mean.
written as an array, the image is
y= observed image = poisson
αx
=
poisson {αx1,1}poisson {αx1,2} ··· poisson {αx1,n}
poisson {αx2,1}poisson {αx2,2} ··· poisson {αx2,n}
............
poisson {αxm,1}poisson {αxm,2} ··· poisson {αxm,n}
.
here, by poisson {αxm,n}we mean that ym,nis a random integer with probability mass
p[ym,n=k] =[αxm,n]k
k!e−αxm,n.
note that this model implies that the images seen by our cameras are more or less
an array of poisson random variables. (we say “more or less” because of other sources of
uncertainties such as read noise, dark current, etc.) because the observed pixels ym,nare
random variables, they fluctuate about the mean values, and hence they are noisy. we refer
to this type of random fluctuation as the shot noise . the impact of the shot noise can be
seen in figure 3.40 . here, we vary the sensor gain level α. we see that for small αthe image
is dark and has much random fluctuation. as αincreases, the image becomes brighter and
the fluctuation becomes smaller.
in matlab, simulating the poisson photon arrival process for an image requires the
image-processing toolbox. the command to read an image is imread . depending on the data
type, the input array could be unit8 integers. to convert them to floating-point numbers
between 0 and 1, we use the command im2double . drawing poisson measurements from the
clean image is done using poissrnd . finally, we can use imshow to display the image.
% matlab code to simulate a photon arrival process
x0 = im2double(imread(’cameraman.tif’));
1the color of an image is often handled by a color filter array , which can be thought of as a wavelength
selector that allows a specific wavelength to pass through.
1623.5. common discrete random variables
 = 10
  = 100
  = 1000
figure 3.40: illustration of the poisson random variable in photographing images. here, αdenotes the
gain level of the sensor: larger αmeans that there are more photons coming to the sensor.
x = poissrnd(10*x0);
figure(1); imshow(x0, []);
figure(2); imshow(x, []);
similar commands can be found in python with the help of the cv2library. when
reading an image, we call cv2.imread . the option 0is used to read a gray-scale image;
otherwise, we will have a 3-channel color image. the division /255 ensures that the input
array ranges between 0 to 1. generating the poisson random numbers can be done using
np.random.poisson , or by calling the statistics library with stats.poisson.rvs(10*x0) .
to display the images, we call plt.imshow , with the color map option set to cmap = ’gray’ .
# python code code to simulate a photon arrival process
import numpy as np
import matplotlib.pyplot as plt
import cv2
x0 = cv2.imread(’./cameraman.tif’, 0)/255
plt.figure(1); plt.imshow(x0,cmap=’gray’);
x = np.random.poisson(10*x0)
plt.figure(2); plt.imshow(x, cmap=’gray’);
why study poisson? what is shot noise?
the poisson random variable is used to model photon arrivals.
shot noise is the random fluctuation of the photon counts at the pixels. shot
noise is present even if you have an ideal sensor.
signal-to-noise ratio of poisson
now let us answer a question we asked before. a poisson random variable has a variance
equal to the mean. thus, if the scene is brighter, the variance will be larger. how come our
simulation in figure 3.40 shows that the fluctuation becomes smaller as the scene becomes
brighter?
163chapter 3. discrete random variables
the answer to this question lies in the signal-to-noise ratio (snr) of the poisson
random variable. the snr of an image defines its quality. the higher the snr, the better
the image. the mathematical definition of snr is the ratio between the signal power and
the noise power. in our case, the snr is
snr =signal power
noise powerdef=e[y]p
var[y](a)=λ√
λ=√
λ,
where y=ym,nis one of the observed pixels and λ=αxm,nis the the corresponding object
pixel. in this equation, the step ( a) uses the properties of the poisson random variable y
where e[y] = var[ y] =λ. the result snr =√
λis very informative. it says that if the
underlying mean photon flux (which is λ) increases, the snr increases at a rate of√
λ.
so, yes, the variance becomes larger when the scene is brighter. however, the gain in signal
e[y] overrides the gain in noisep
var[y]. as a result, the big fluctuation in bright images
is compensated by the strong signal. thus, to minimize the shot noise one has to use a
longer exposure to increase the mean photon flux. when the scene is dark and the aperture
is small, shot noise is unavoidable.
poisson modeling is useful for describing the problem. however, the actual engineering
question is that, given a noise observation ym,n, how would you reconstruct the clean image
xm,n? this is a very difficult inverse problem . the typical strategy is to exploit the spatial
correlations between nearby pixels, e.g., usually smooth except along some sharp edges.
other information about the image, e.g., the likelihood of obtaining texture patterns, can
also be leveraged. modern image-processing methods are rich, ranging from classical filtering
techniques to deep neural networks. static images are easier to recover because we can often
leverage multiple measurements of the same scene to boost the snr. dynamic scenes are
substantially harder when we need to track the motion of any underlying objects. there are
also newer image sensors with better photon sensitivity. the problem of imaging in the dark
is an important research topic in computational imaging . new solutions are developed at
the intersection of optics, signal processing, and machine learning.
the end of our discussions on photon statistics.
3.6 summary
arandom variable is so called because it can take more than one state. the probability mass
function specifies the probability for it to land on a particular state. therefore, whenever
you think of a random variable you should immediately think of its pmf (or histogram
if you prefer). the pmf is a unique characterization of a random variable. two random
variables with the same pmf are effectively the same random variables. (they are not
identical because there could be measure-zero sets where the two differ.) once you have the
pmf, you can derive the cdf, expectation, moments, variance, and so on.
when your boss hands a dataset to you, which random variable (which model) should
you use? this is a very practical and deep question. we highlight three steps for you to
consider:
1643.7. references
(i)model selection : which random variable is the best fit for our problem? some-
times we know by physics that, for example, photon arrivals or internet traffic follow a
poisson random variable. however, not all datasets can be easily described by simple
models. the models we have learned in this chapter are called the parametric mod-
els because they are characterized by one or two parameters. some datasets require
nonparametric models, e.g., natural images, because they are just too complex. some
data scientists refer to deep neural networks as parametric models because the net-
work weights are essentially the parameters. some do not because when the number
of parameters is on the order of millions, sometimes even more than the number of
training samples, it seems more reasonable to call these models nonparametric. how-
ever, putting this debate aside, shortlisting a few candidate models based on prior
knowledge is essential. even if you use deep neural networks, selecting between con-
volutional structures versus long short-term memory models is still a legitimate task
that requires an understanding of your problem.
(ii)parameter estimation : suppose that you now have a candidate model; the next
task is to estimate the model parameter using the available training data. for example,
for poisson we need to determine λ, and for binomial we need to determine ( n, p). the
estimation problem is an inverse problem. often we need to use the pmf to construct
certain optimization problems. by solving the optimization problem we will find the
best parameter (for that particular candidate model). modern machine learning is
doing significantly better now than in the old days because optimization methods
have advanced greatly.
(iii)validation . when each candidate model has been optimized to best fit the data,
we still need to select the best model. this is done by running various testings. for
example, we can construct a validation set and check which model gives us the best
performance (such as classification rate or regression error). however, a model with
the best validation score is not necessarily the best model. your goal should be to seek
agood model and not the best model because determining the best requires access to
the testing data, which we do not have. everything being equal, the common wisdom
is to go with a simpler model because it is generally less susceptible to overfitting.
3.7 references
probability textbooks
3-1 dimitri p. bertsekas and john n. tsitsiklis, introduction to probability , athena sci-
entific, 2nd edition, 2008. chapter 2.
3-2 alberto leon-garcia, probability, statistics, and random processes for electrical en-
gineering , prentice hall, 3rd edition, 2008. chapter 3.
3-3 athanasios papoulis and s. unnikrishna pillai, probability, random variables and
stochastic processes , mcgraw-hill, 4th edition, 2001. chapters 3 and 4.
3-4 john a. gubner, probability and random processes for electrical and computer en-
gineers , cambridge university press, 2006. chapters 2 and3.
165chapter 3. discrete random variables
3-5 sheldon ross, a first course in probability , prentice hall, 8th edition, 2010. chap-
ter 4.
3-6 henry stark and john woods, probability and random processes with applications
to signal processing , prentice hall, 3rd edition, 2001. chapters 2 and 4.
advanced probability textbooks
3-7 william feller, an introduction to probability theory and its applications , wiley and
sons, 3rd edition, 1950.
3-8 andrey kolmogorov, foundations of the theory of probability , 2nd english edition,
dover 2018. (translated from russian to english. originally published in 1950 by
chelsea publishing company new york.)
cross-validation
3-9 larry wasserman, all of statistics , springer 2004. chapter 20.
3-10 mats rudemo, “empirical choice of histograms and kernel density estimators,”
scandinavian journal of statistics , vol. 9, no. 2 (1982), pp. 65-78.
3-11 david w. scott, multivariate density estimation: theory, practice, and visualization ,
wiley, 1992.
poisson statistics
3-12 joseph goodman, statistical optics , wiley, 2015. chapter 3.
3-13 henry stark and john woods, probability and random processes with applications
to signal processing , prentice hall, 3rd edition, 2001. section 1.10.
3.8 problems
exercise 1. (video solution)
consider an information source that produces numbers kin the set sx={1,2,3,4}. find
and plot the pmf in the following cases:
(a)pk=p1/k, fork= 1,2,3,4. hint: find p1.
(b)pk+1=pk/2 for k= 1,2,3.
(c)pk+1=pk/2kfork= 1,2,3.
(d) can the random variables in parts (a)-(c) be extended to take on values in the set
{1,2, . . .}? why or why not? hint: you may use the fact that the series 1+1
2+1
3+···
diverges.
exercise 2. (video solution)
two dice are tossed. let xbe the absolute difference in the number of dots facing up.
1663.8. problems
(a) find and plot the pmf of x.
(b) find the probability that x≤2.
(c) find e[x] and var[ x].
exercise 3. (video solution)
letxbe a random variable with pmf pk=c/2kfork= 1,2, . . ..
(a) determine the value of c.
(b) find p(x > 4) and p(6≤x≤8).
(c) find e[x] and var[ x].
exercise 4.
letxbe a random variable with pmf pk=c/2kfork=−1,0,1,2,3,4,5.
(a) determine the value of c.
(b) find p(1≤x < 3) and p(1< x≤5).
(c) find p[x3<5].
(d) find the pmf and the cdf of x.
exercise 5. (video solution)
a modem transmits a +2 voltage signal into a channel. the channel adds to this sig-
nal a noise term that is drawn from the set {0,−1,−2,−3}with respective probabilities
{4/10,3/10,2/10,1/10}.
(a) find the pmf of the output yof the channel.
(b) what is the probability that the channel’s output is equal to the input of the channel?
(c) what is the probability that the channel’s output is positive?
(d) find the expected value and variance of y.
exercise 6.
on a given day, your golf score takes values from numbers 1 through 10, with equal proba-
bility of getting each one. assume that you play golf for three days, and assume that your
three performances are independent. let x1,x2, and x3be the scores that you get, and
letxbe the minimum of these three numbers.
(a) show that for any discrete random variable x,px(k) =p(x > k −1)−p(x > k ).
(b) what is the probability p(x1> k) for k= 1, . . . , 10?
(c) use (a), determine the pmf px(k), for k= 1, . . . , 10.
167chapter 3. discrete random variables
(d) what is the average score improvement if you play just for one day compared with
playing for three days and taking the minimum?
exercise 7. (video solution)
let
g(x) =(
1,ifx > 10
0,otherwise .and h(x) =(
x−10,ifx−10>0
0, otherwise .
(a) find e[g(x)] for xas in problem 1(a) with sx={1, . . . , 15}.
(b) find e[h(x)] for xas in problem 1(b) with sx={1, . . . , 15}.
exercise 8. (video solution)
a voltage xis uniformly distributed in the set {−3, . . . , 3,4}.
(a) find the mean and variance of x.
(b) find the mean and variance of y=−2x2+ 3.
(c) find the mean and variance of w= cos( πx/8).
(d) find the mean and variance of z= cos2(πx/8).
exercise 9. (video solution)
(a) if xis poisson( λ), compute e[1/(x+ 1)].
(b) if xis bernoulli( p) and yis bernoulli( q), compute e[(x+y)3] ifxandyare
independent.
(c) let xbe a random variable with mean µand variance σ2. let ∆( θ) =e[(x−θ)2].
find θthat minimizes the error ∆( θ).
(d) suppose that x1, . . . , x nare independent uniform random variables in {0,1, . . . , 100}.
evaluate p[min( x1, . . . , x n)> ℓ] for any ℓ∈ {0,1, . . . , 100}.
exercise 10. (video solution)
(a) consider the binomial probability mass function px(k) = n
k
pk(1−p)n−k. show that
the mean is e[x] =np.
(b) consider the geometric probability mass function px(k) =p(1−p)kfork= 0,1, . . ..
show that the mean is e[x] = (1 −p)/p.
(c) consider the poisson probability mass function px(k) =λk
k!e−λ. show that the vari-
ance is var[ x] =λ.
(d) consider the uniform probability mass function px(k) =1
lfork= 1, . . . , l . show that
the variance is var[ x] =l2−1
12. hint: 1 + 2 + ···+n=n(n+1)
2and 12+ 22+···+n2=
n3
3+n2
2+n
6.
1683.8. problems
exercise 11. (video solution)
an audio player uses a low-quality hard drive. the probability that the hard drive fails after
being used for one month is 1 /12. if it fails, the manufacturer offers a free-of-charge repair
for the customer. for the cost of each repair, however, the manufacturer has to pay $20.
the initial cost of building the player is $50, and the manufacturer offers a 1-year warranty.
within one year, the customer can ask for a free repair up to 12 times.
(a) let xbe the number of months when the player fails. what is the pmf of x? hint:
p[x= 1] may not be very high because if the hard drive fails it will be fixed by the
manufacturer. once fixed, the drive can fail again in the remaining months. so saying
x= 1 is equivalent to saying that there is only one failure in the entire 12-month
period.
(b) what is the average cost per player?
exercise 12. (video solution)
a binary communication channel has a probability of bit error of p= 10−6. suppose that
transmission occurs in blocks of 10,000 bits. let nbe the number of errors introduced by
the channel in a transmission block.
(a) what is the pmf of n?
(b) find p[n= 0] and p[n≤3].
(c) for what value of pwill the probability of 1 or more errors in a block be 99%?
hint: use the poisson approximation to binomial random variables.
exercise 13. (video solution)
the number of orders waiting to be processed is given by a poisson random variable with
parameter α=λ/nµ , where λis the average number of orders that arrive in a day, µis the
number of orders that an employee can process per day, and nis the number of employees.
letλ= 5 and µ= 1. find the number of employees required so the probability that more
than four orders are waiting is less than 10%.
hint: you need to use trial and error for a few n’s.
exercise 14.
letxbe the number of photons counted by a receiver in an optical communication system.
it is known that xis a poisson random variable with a rate λ1when a signal is present and a
poisson random variable with the rate λ0< λ1when a signal is absent. the probability that
the signal is present is p. suppose that we observe x=kphotons. we want to determine a
threshold tsuch that if k≥twe claim that the signal is present, and if k < t we claim
that the signal is absent. what is the value of t?
169chapter 3. discrete random variables
170chapter 4
continuous random variables
if you are coming to this chapter from chapter 3, we invite you to take a 30-second pause
and switch your mind from discrete events to continuous events. everything is continuous
now. the sample space is continuous, the event space is continuous, and the probability
measure is continuous. continuous random variables are similar in many ways to discrete
random variables. they are characterized by the probability density functions (the continu-
ous version of the probability mass functions); they have cumulative distribution functions;
they have means, moments, and variances. the most significant difference is perhaps the use
of integration instead of summation, but this change is conceptually straightforward, aside
from the difficulties associated with integrating functions. so why do we need a separate
chapter for continuous random variables? there are several reasons.
first, how would you define the probability of a continuous event? note that we cannot
count because a continuous event is uncountable. there is also nothing called the
probability mass because there are infinitely many masses. to define the probability
of continuous events, we need to go back to our “slogan”: probability is a measure
of the size of a set . because probability is a measure, we can speak meaningfully
about the probability of continuous events so long as we have a well-defined measure
for them. defining such a measure requires some effort. we will develop the intuitions
and the formal definitions in section 4.1. in section 4.2, we will discuss the expectation
and variance of continuous random variables.
the second challenge is the unification between continuous and discrete random vari-
ables. since the two types of random variables ultimately measure the size of a set, it
is natural to ask whether we can unify them. our approach to unifying them is based
on the cumulative distribution functions (cdfs), which are well-defined functions for
discrete and continuous random variables. based on the cdf and the fundamental
theorem of calculus, we can show that the probability density functions and proba-
bility mass functions can be derived from the derivative of the cdfs. these will be
discussed in section 4.3, and in section 4.4 we will discuss some additional results
about the mode and median.
the third challenge is to understand several widely used continuous random variables.
we will discuss the uniform random variable and the exponential random variable
in section 4.5. section 4.6 deals with the important topic of the gaussian random
variable . where does a gaussian random variable come from? why does it have a bell
171chapter 4. continuous random variables
shape? why are gaussian random variables so popular in data science? what are the
useful properties of gaussian random variables? what are the relationships between
a gaussian random variable and other random variables? these important questions
will be answered in section 4.6.
the final challenge is the transformation of random variables. imagine that you have a
random variable xand a function g. what will the probability mass/density function
ofg(x) be? addressing this problem is essential because almost all practical engineer-
ing problems involve the transformation of random variables. for example, suppose
we have voltage measurements and we would like to compute the power. this requires
taking the square of the voltage. we will discuss the transformation in section 4.7,
and we will also discuss an essential application in generating random numbers in
section 4.8.
4.1 probability density function
4.1.1 some intuitions about probability density functions
let’s begin by outlining some intuitive reasoning, which is needed to define the probability
of continuous events properly. these intuitions are based on the fact that probability is a
measure . in the following discussion you will see a sequence of logical arguments for con-
structing such a measure for continuous events. some arguments are discussed in chapter 2,
but now we place them in the context of continuous random variables.
suppose we are given an event athat is a subset in the sample space ω, as illustrated
infigure 4.1 . in order to calculate the probability of a, the measure perspective suggests
that we consider the relative size of the set
p[{x∈a}] =“size” of a
“size” of ω.
the right-hand side of this equation captures everything about the probability: it is a
measure of the size of a set. it is relative to the sample space. it is a number between 0 and
1. it can be applied to discrete sets, and it can be applied to continuous sets.
figure 4.1: [left] an event ain the sample space ω. the probability that ahappens can be calculated
as the “size” of arelative to the “size” of ω. [right] a specific example on the real line. note that the
same definition of probability applies: the probability is the size of the interval arelative to that of the
sample space ω.
1724.1. probability density function
how do we measure the “size” of a continuous set? one possible way is by means of
integrating the length, area, or volume covered by the set. consider an example: suppose
that the sample space is the interval ω = [0 ,5] and the event is a= [2,3]. to measure the
“size” of a, we can integrate ato determine the length. that is,
p[{x∈[2,3]}] =“size” of a
“size” of ω=r
adxr
ωdx=r3
2dx
r5
0dx=1
5.
therefore, we have translated the “size” of a set to an integration. however, this definition
is a very special case because when we calculate the “size” of a set, we treat all the elements
in the set with equal importance. this is a strong assumption that will be relaxed later. but
if you agree with this line of reasoning, we can rewrite the probability as
p[{x∈a}] =r
adxr
ωdx=r
adx
|ω|
=z
a1
|ω||{z}
equally important over ωdx.
this equation says that under our assumption (that all elements are equiprobable), the
probability of ais calculated as the integration of ausing an integrand 1 /|ω|(note that
1/|ω|is a constant with respect to x). if we evaluate the probability of another event b, all
we need to do is to replace awith band computer
b1
|ω|dx.
what happens if we want to relax the “equiprobable” assumption? perhaps we can
adopt something similar to the probability mass function (pmf). recall that a pmf px
evaluated at a point xis the probability that the state xhappens, i.e., px(x) =p[x=x].
so,px(x) is the relative frequency of x. following the same line of thinking, we can define a
function fxsuch that fx(x) tells us something related to the “relative frequency”. to this
end, we can treat fxas a continuous histogram with infinitesimal bin width as shown in
figure 4.2 . using this fx, we can replace the constant function 1 /|ω|with the new function
fx(x). this will give us
p[{x∈a}] =z
afx(x)|{z}
replace 1 /|ω|dx. (4.1)
if we compare it with a pmf, we note that when xis discrete,
p[{x∈a}] =x
x∈apx(x).
hence, fxcan be considered a continuous version of px, although we do not recommend
this way of thinking for the following reason: px(x) is a legitimate probability, but fx(x) is
not a probability. rather, fxis the probability per unit length , meaning that we need to
integrate fx(times dx) in order to generate a probability value. if we only look at fxat
a point x, then this point is a measure-zero set because the length of this set is zero.
equation (4.1) should be familiar to you from chapter 2. the function fx(x) is pre-
cisely the weighting function we described in that chapter.
173chapter 4. continuous random variables
figure 4.2: [left] a probability mass function (pmf) tells us the relative frequency of a state when
computing the probability. in this example, the “size” of aispx(x2) +px(x3). [right] a probability
density function (pdf) is the infinitesimal version of the pmf. thus, the “size” of ais the integration
over the pdf.
what is a pdf?
a pdf is the continuous version of a pmf.
we integrate a pdf to compute the probability.
we integrate instead of sum because continuous events are not countable.
to summarize, we have learned that when measuring the size of a continuous event,
the discrete technique (counting the number of elements) does not work. generalizing to
continuous space requires us to integrate the event. however, since different elements in an
event have different relative emphases, we use the probability density function fx(x) to tell
us the relative frequency for a state xto happen. this pdf serves the role of the pmf.
4.1.2 more in-depth discussion about pdfs
a continuous random variable xis defined by its probability density function fx. this
function has to satisfy several criteria, summarized as follows.
definition 4.1. a probability density function fxof a random variable xis a map-
ping fx: ω→r, with the properties
non-negativity :fx(x)≥0for all x∈ω
unity :r
ωfx(x)dx= 1
measure of a set :p[{x∈a}] =r
afx(x)dx
if all elements of the sample space are equiprobable, then the pdf is f(x) = 1 /|ω|. you can
easily check that it satisfies all three criteria.
let us take a closer look at the three criteria:
non-negativity: the non-negativity criterion fx(x)≥0 is reminiscent of probability
axiom i. it says that no matter what xwe are looking at, the probability density
function fxevaluated at xshould never give a negative value. axiom i ensures that
we will not get a negative probability.
1744.1. probability density function
unity: the unity criterionr
ωf(x)dx= 1 is reminiscent of probability axiom ii,
which says that measuring over the entire sample space will give 1.
measure of a set: the third criterion gives us a way to measure the size of an event a.
it says that since each x∈ω has a different emphasis when calculating the size of
a, we need to scale the elements properly. this scaling is done by the pdf fx(x),
which can be regarded as a histogram with a continuous x-axis. the third criterion
is a consequence of probability axiom iii, because if there are two events aandb
that are disjoint, then p[{x∈a} ∪ {x∈b}] =r
afx(x)dx+r
bfx(x)dxbecause
fx(x)≥0 for all x.
if the random variable xtakes real numbers in 1d, then a more “user-friendly” definition
of the pdf can be given.
definition 4.2. letxbe a continuous random variable. the probability density
function (pdf) ofxis a function fx: ω→rthat, when integrated over an interval
[a, b], yields the probability of obtaining a≤x≤b:
p[a≤x≤b] =zb
afx(x)dx. (4.2)
this definition is just a rewriting of the previous definition by explicitly writing out
the definition of aas an interval [ a, b]. here are a few examples.
example 4.1 . let fx(x) = 3 x2with ω = [0 ,1]. let a= [0,0.5]. then the probability
p[{x∈a}] is
p[0≤x≤0.5] =z0.5
03x2dx=1
8.
example 4.2 . let fx(x) = 1 /|ω|with ω = [0 ,5]. let a= [3,5]. then the probability
p[{x∈a}] is
p[3≤x≤5] =z5
31
|ω|dx=z5
31
5dx=2
5.
example 4.3 . let fx(x) = 2 xwith ω = [0 ,1]. let a={0.5}. then the probability
p[{x∈a}] is
p[x= 0.5] =p[0.5≤x≤0.5] =z0.5
0.52x dx = 0.
this example shows that evaluating the probability at an isolated point for a contin-
uous random variable will yield 0.
175chapter 4. continuous random variables
practice exercise 4.1 . let xbe the phase angle of a voltage signal. without any
prior knowledge about xwe may assume that xhas an equal probability of any value
between 0 to 2 π. find the pdf of xand compute p[0≤x≤π/2].
solution . since xhas an equal probability for any value between 0 to 2 π, the pdf
ofxis
fx(x) =1
2π, for 0≤x≤2π.
therefore, the probability p[0≤x≤π/2] can be computed as
ph
0≤x≤π
2i
=zπ/2
01
2πdx=1
4.
looking at equation (4.2), you may wonder: if the pdf fxis analogous to pmf
px, why didn’t we require 0 ≤fx(x)≤1 instead of requiring only fx(x)≥0? this is
an excellent question, and it points exactly to the difference between a pmf and a pdf.
notice that fxis a mapping from the sample space ω to the real line r. it does not map
ω to [0 ,1]. on the other hand, since px(x) is the actual probability, it maps ω to [0 ,1].
thus, fx(x) can take very large values but will not explode, because we have the unity
constraintr
ωfx(x)dx= 1. even if fx(x) takes a large value, it will be compensated by the
small dx. if you recall, there is nothing like dxin the definition of a pmf. whenever there
is a probability mass, we need to sum or, putting it another way, the dxin the discrete case
is always 1. therefore, while the probability mass pmf must not exceed 1, a probability
density pdf can exceed 1.
iffx(x)≥1, then what is the meaning of fx(x)? isn’t it representing the probability
of having an element x=x? if it were a discrete random variable, then yes; px(x) is the
probability of having x=x(so the probability mass cannot go beyond 1). however, for a
continuous random variable, fx(x) isnotthe probability of having x=x. the probability
of having x=x(i.e., exactly at x) is 0 because an isolated point has zero measure in the
continuous space. thus, even though fx(x) takes a value larger than 1, the probability of
xbeing xis zero.
at this point you can see why we call pdf a density , or density function, because each
value fx(x) is the probability per unit length . if we want to calculate the probability of
x≤x≤x+δ, for example, then according to our definition, we have
p[x≤x≤x+δ] =zx+δ
xfx(x)dx≈fx(x)·δ.
therefore, the probability of p[x≤x≤x+δ] can be regarded as the “per unit length”
density fx(x) multiplied with the “length” δ. asδ→0, we can see that p[x=x] = 0. see
figure 4.3 for an illustration.
why are pdfs called a density function?
because fx(x) is the probability per unit length .
you need to integrate fx(x) to obtain a probability.
1764.1. probability density function
figure 4.3: the probability p[x≤x≤x+δ]can be approximated by the density fx(x)multiplied by
the length δ.
example 4.4 . consider a random variable xwith pdf fx(x) =1
2√xfor any
0< x≤1, and is 0 otherwise. we can show that fx(x)→ ∞ asx→0. however,
fx(x) remains a valid pdf because
z∞
−∞fx(x)dx=z1
01
2√xdx=√x1
0= 1.
remark . since isolated points have zero measure in the continuous space, the probability
of an open interval ( a, b) is the same as the probability of a closed interval:
p[[a, b]] =p[(a, b)] =p[(a, b]] =p[[a, b)].
the exception is that when the pdf of fx(x) has a delta function at aorb. in this case,
the probability measure at aorbwill be non-zero. we will discuss this when we talk about
the cdfs.
practice exercise 4.2 . let fx(x) =c(1−x2) for−1≤x≤1, and 0 otherwise. find
the constant c.
solution . sincer
ωfx(x)dx= 1, it follows that
z
ωfx(x)dx=z1
−1c(1−x2)dx=4c
3⇒c= 3/4.
practice exercise 4.3 . let fx(x) =x2for|x| ≤a, and 0 otherwise. find a.
solution . note that
z
ωfx(x)dx=za
−ax2dx=x3
3a
−a=2a3
3.
setting2a3
3= 1 yields a=3q
3
2.
177chapter 4. continuous random variables
4.1.3 connecting with the pmf
the probability density function is more general than the probability mass function. to see
this, consider a discrete random variable xwith a pmf px(x). because pxis defined on
a countable set ω, we can write it as a train of delta functions and define a corresponding
pdf:
fx(x) =x
xk∈ωpx(xk)δ(x−xk).
example 4.5 . ifxis a bernoulli random variable with pmf px(1) = pandpx(0) =
1−p, then the corresponding pdf can be written as
fx(x) =p δ(x−1) + (1 −p)δ(x−0).
example 4.6 . ifxis a binomial random variable with pmf px(k) = n
k
pk(1−p)n−k,
then the corresponding pdf can be written as
fx(x) =nx
k=0px(k)δ(x−k)
=nx
k=0n
k
pk(1−p)n−kδ(x−k).
strictly speaking, delta functions are not really functions. they are defined through
integrations. they satisfy the properties that δ(x−xk) =∞ifx=xk,δ(x−xk) = 0 if
x̸=xk, andzxk+ϵ
xk−ϵδ(x−xk)dx= 1,
for any ϵ >0. suppose we ignore the fact that delta functions are not functions and merely
treat them as ordinary functions with some interesting properties. in this case, we can
imagine that for every probability mass px(xk), there exists an interval [ a, b] such that
there is one and only one state xkthat lies in [ a, b], as shown in figure 4.4 .
figure 4.4: we can view a pmf as a train of impulses. when computing the probability x=xk, we
integrate the pmf over the interval [a, b].
1784.1. probability density function
if we want to calculate the probability of obtaining x=xk, we can show that
p[x=xk](a)=p[a≤x≤b]
=zb
afx(x)dx
(b)=zb
apx(xk)δ(x−xk)dx
(c)=px(xk)zb
aδ(x−xk)dx
| {z }
=1=px(xk).
here, step ( a) holds because within [ a, b], there is no other event besides x=xk. step ( b)
is just the definition of our fx(x) (inside the interval [ a, b]). step ( c) shows that the delta
function integrates to 1, thus leaving the probability mass px(xk) as the final result. let us
look at an example and then comment on this intuition.
example 4.7 . let xbe a discrete random variable with pmf
px(k) =1
2k, k = 1,2, . . .
the continuous representation of the pmf can be written as
fx(x) =∞x
k=1px(k)δ(x−k) =∞x
k=11
2k
δ(x−k).
suppose we want to compute the probability p[1≤x≤2]. this can be computed as
p[1≤x≤2] =z2
1fx(x)dx=z2
1∞x
k=11
2k
δ(x−k)dx
=z2
11
2δ(x−1) +1
4δ(x−2) +···
dx
=1
2z2
1δ(x−1)dx
|{z }
=1+1
4z2
1δ(x−2)dx
|{z }
=1
+1
8z2
1δ(x−3)dx
|{z }
=0+···|{z}
=0
=1
2+1
4=3
4.
however, if we want to compute the probability p[1< x≤2], then the integration
179chapter 4. continuous random variables
limit will not include the number 1 and so the delta function will remain 0. thus,
p[1< x≤2] =z2
1+fx(x)dx
=1
2z2
1+δ(x−1)dx
|{z }
=0+1
4z2
1+δ(x−2)dx
|{z }
=1=1
4.
closing remark . to summarize, we see that a pmf can be “regarded” as a pdf. we are
careful to put a quotation around “regarded” because pmf and pdf are defined for different
events. a pmf uses a discrete measure (i.e., a counter) for countable events, whereas a pdf
uses a continuous measure (i.e., integration) for continuous events. the way we link the two is
by using the delta functions. using the delta functions is valid, but the argument we provide
here is intuitive rather than rigorous. it is not rigorous because the integration we use is still
the riemann-stieltjes integration, which does not handle delta functions. therefore, while
you can treat a discrete pdf as a train of delta functions, it is important to remember the
limitations of the integrations we use.
4.2 expectation, moment, and variance
4.2.1 definition and properties
as with discrete random variables, we can define expectation for continuous random vari-
ables. the definition is analogous: just replace the summation with integration.
definition 4.3. theexpectation of a continuous random variable xis
e[x] =z
ωx fx(x)dx. (4.3)
example 4.8 . (uniform random variable ) let xbe a continuous random variable
with pdf fx(x) =1
b−afora≤x≤b, and 0 otherwise. the expectation is
e[x] =z
ωxfx(x)dx=zb
ax·1
b−adx=1
b−azb
ax dx
|{z}
=x2
2b
a
=1
b−a·b2−a2
2=a+b
2.
1804.2. expectation, moment, and variance
example 4.9 . (exponential random variable ) let xbe a continuous random variable
with pdf fx(x) =λe−λx, forx≥0. the expectation is
e[x] =z∞
0x λe−λxdx
=−z∞
0x de−λx
=−xe−λx∞
0|{z}
=0+z∞
0e−λxdx
=−1
λe−λx∞
0|{z}
=−1=1
λ,
where the colored step is due to integration by parts.
if a function gis applied to the random variable x, the expectation can be found using
the following theorem.
theorem 4.1. letg: ω→rbe a function and xbe a continuous random variable.
then
e[g(x)] =z
ωg(x)fx(x)dx. (4.4)
example 4.10 . (uniform random variable ) let xbe a continuous random variable
with fx(x) =1
b−afora≤x≤b, and 0 otherwise. if g(·) = (·)2, then
e[g(x)] =e[x2] =z
ωx2fx(x)dx
=1
b−a·zb
ax2dx
|{z}
=b3−a3
3=a2+ab+b2
3.
practice exercise 4.4 . let θ be a continuous random variable with pdf fθ(θ) =1
2π
for 0≤θ≤2πand is 0 otherwise. let y= cos( ωt+ θ). find e[y].
solution . referring to equation (4.4), the function gis
g(θ) = cos( ωt+θ).
181chapter 4. continuous random variables
therefore, the expectation e[y] is
e[y] =z2π
0cos(ωt+θ)fθ(θ)dθ
=1
2πz2π
0cos(ωt+θ)dθ= 0,
where the last equality holds because the integral of a sinusoid over one period is 0.
practice exercise 4.5 . let a⊆ω. let ia(x) be an indicator function such that
ia(x) =(
1,ifx∈a,
0,ifx̸∈a.
finde[ia(x)].
solution . the expectation is
e[ia(x)] =z
ωia(x)fx(x)dx=z
x∈afx(x)dx=p[x∈a].
so the probability of {x∈a}can be equivalently represented in terms of expectation.
practice exercise 4.6 . is it true that e[1/x] = 1/e[x]?
solution . no. this is because
e1
x
=z
ω1
xfx(x)dx̸=1r
ωxfx(x)dx=1
e[x].
all the properties of expectation we learned in the discrete case can be translated to
the continuous case. specifically, we have that
e[ax] =ae[x]: a scalar multiple of a random variable will scale the expectation.
e[x+a] =e[x]+a: constant addition of a random variable will offset the expectation.
e[ax+b] =ae[x] +b: affine transformation of a random variable will translate to
the expectation.
practice exercise 4.7 . prove the above three statements.
solution . the third statement is just the sum of the first two statements, so we just
1824.2. expectation, moment, and variance
need to show the first two:
e[ax] =z
ωaxfx(x)dx=az
ωxfx(x)dx=ae[x],
e[x+a] =z
ω(x+a)fx(x)dx=z
ωxfx(x)dx+a=e[x] +a.
4.2.2 existence of expectation
as we discussed in the discrete case, not all random variables have an expectation.
definition 4.4. a random variable xhas an expectation if it is absolutely integrable ,
i.e.,
e[|x|] =z
ω|x|fx(x)dx <∞. (4.5)
being absolutely integrable implies that the expectation is that e[|x|] is the upper
bound of e[x].
theorem 4.2. for any random variable x,
|e[x]| ≤e[|x|]. (4.6)
proof . note that fx(x)≥0. therefore,
−|x|fx(x)≤x fx(x)≤ |x|, fx(x),∀x.
thus, integrating all three terms yields
−z
ω|x|fx(x)dx≤z
ωx fx(x)dx≤z
ω|x|fx(x)dx,
which is equivalent to −e[|x|]≤e[x]≤e[|x|].
□
example 4.11 . here is a random variable whose expectation is undefined. let xbe
a random variable with pdf
fx(x) =1
π(1 +x2), x ∈r.
this random variable is called the cauchy random variable . we can show that
e[x] =z∞
−∞x·1
π(1 +x2)dx=1
πz∞
0x
(1 +x2)dx+1
πz0
−∞x
(1 +x2)dx.
183chapter 4. continuous random variables
the first integral gives
z∞
0x
(1 +x2)dx=1
2log(1 + x2)∞
0=∞,
and the second integral gives −∞. since neither integral is finite, the expectation is
undefined. we can also check the absolutely integrability criterion:
e[|x|] =z∞
−∞|x| ·1
π(1 +x2)dx
(a)= 2z∞
0x
π(1 +x2)dx≥2z∞
1x
π(1 +x2)dx
(b)
≥2z∞
1x
π(x2+x2)dx=1
πlog(x)∞
1=∞,
where in (a) we use the fact that the function being integrated is even, and in (b) we
lower-bound1
1+x2≥1
x2+x2ifx >1.
4.2.3 moment and variance
the moment and variance of a continuous random variable can be defined analogously to
the moment and variance of a discrete random variable, replacing the summations with
integrations.
definition 4.5. thekth moment of a continuous random variable xis
e[xk] =z
ωxkfx(x)dx. (4.7)
definition 4.6. thevariance of a continuous random variable xis
var[x] =e[(x−µ)2] =z
ω(x−µ)2fx(x)dx, (4.8)
where µdef=e[x].
it is not difficult to show that the variance can also be expressed as
var[x] =e[x2]−µ2,
because
var[x] =e[(x−µ)2] =e[x2]−2e[x]µ+µ2=e[x2]−µ2.
1844.3. cumulative distribution function
practice exercise 4.8 . (uniform random variable ) let xbe a continuous random
variable with pdf fx(x) =1
b−afora≤x≤b, and 0 otherwise. find var[ x].
solution . we have shown that e[x] =a+b
2ande[x2] =a2+ab+b2
3. therefore, the
variance is
var[x] =e[x2]−e[x]2
=a2+ab+b2
3−a+b
22
=(b−a)2
12.
practice exercise 4.9 . (exponential random variable ) let xbe a continuous ran-
dom variable with pdf fx(x) =λe−λxforx≥0, and 0 otherwise. find var[ x].
solution . we have shown that e[x] =1
λ. the second moment is
e[x2] =z∞
0x2λe−λxdx
=
−x2e−λx∞
0+z∞
02xe−λxdx
=2
λz∞
0xλe−λxdx
=2
λ·1
λ=2
λ2.
therefore,
var[x] =e[x2]−e[x]2
=2
λ2−1
λ2=1
λ2.
4.3 cumulative distribution function
when we discussed discrete random variables, we introduced the concept of cumulative
distribution functions (cdfs). one of the motivations was that if we view a pmf as a train
of delta functions, they are technically not well-defined functions. however, it turns out that
the cdf is always a well-defined function. in this section, we will complete the story by first
discussing the cdf for continuous random variables. then, we will come back and show
you how the cdf can be derived for discrete random variables.
185chapter 4. continuous random variables
4.3.1 cdf for continuous random variables
definition 4.7. letxbe a continuous random variable with a sample space ω =r.
thecumulative distribution function (cdf) ofxis
fx(x)def=p[x≤x] =zx
−∞fx(x′)dx′. (4.9)
the interpretation of the cdf can be seen from figure 4.5 . given a pdf fx, the cdf
fxevaluated at xis the integration of fxfrom−∞up to a point x. the integration of fx
from−∞toxis nothing but the area under the curve of fx. since fxis non-negative, the
larger value xwe use to evaluate in fx(x), the more area under the curve we are looking
at. in the extreme when x=−∞, we can see that fx(−∞) = 0, and when x= +∞we
have that fx(+∞) =r∞
−∞fx(x)dx= 1.
figure 4.5: a cdf is the integral of the pdf. thus, the height of a stem in the cdf corresponds to
the area under the curve of the pdf.
practice exercise 4.10 . (uniform random variable ) let xbe a continuous random
variable with pdf fx(x) =1
b−afora≤x≤b, and is 0 otherwise. find the cdf of x.
solution . the cdf of xis given by
fx(x) =

0, x ≤a,rx
−∞fx(x′)dx′=rx
a1
b−adx′=x−a
b−a, a < x ≤b,
1, x > b.
as you can see from this practice exercise, we explicitly break the cdf into three segments.
the first segment gives fx(x) = 0 because for any x≤a, there is nothing to integrate,
since fx(x) = 0 for any x≤a. similarly, for the last segment, fx(x) = 1 for all x > b
because once xgoes beyond b, the integration will cover all the non-zeros of fx.figure 4.6
illustrates the pdf and cdf for this example.
in matlab, we can generate the pdf and cdf using the commands pdfand cdf
respectively. for the particular example shown in figure 4.6 , the following code can be used.
a similar set of commands can be implemented in python.
1864.3. cumulative distribution function
figure 4.6: example: fx(x) = 1 /(b−a)fora≤x≤b. the cdf has three segments.
% matlab code to generate the pdf and cdf
unif = makedist(’uniform’,’lower’,-3,’upper’,4);
x = linspace(-5, 10, 1500)’;
f = pdf(unif, x);
f = cdf(unif, x);
figure(1); plot(x, f, ’linewidth’, 6);
figure(2); plot(x, f, ’linewidth’, 6);
# python code to generate the pdf and cdf
import numpy as np
import matplotlib.pyplot as plt
import scipy.stats as stats
x = np.linspace(-5,10,1500)
f = stats.uniform.pdf(x,-3,4)
f = stats.uniform.cdf(x,-3,4)
plt.plot(x,f); plt.show()
plt.plot(x,f); plt.show()
practice exercise 4.11 . (exponential random variable ) let xbe a continuous
random variable with pdf fx(x) =λe−λxforx≥0, and 0 otherwise. find the cdf
ofx.
solution . clearly, for x <0, we have fx(x) = 0. for x≥0, we can show that
fx(x) =zx
0fx(x′)dx′=zx
0λe−λx′dx′= 1−e−λx.
therefore, the complete cdf is (see figure 4.7 for illustration):
fx(x) =(
0, x < 0,
1−e−λx, x ≥0.
the matlab code and python code to generate this figure are shown below.
187chapter 4. continuous random variables
figure 4.7: example: fx(x) =λe−λxforx≥0. the cdf has two segments.
% matlab code to generate the pdf and cdf
pd = makedist(’exp’,2);
x = linspace(-5, 10, 1500)’;
f = pdf(pd, x);
f = cdf(pd, x);
figure(1); plot(x, f, ’linewidth’, 6);
figure(2); plot(x, f, ’linewidth’, 6);
# python code to generate the pdf and cdf
import numpy as np
import matplotlib.pyplot as plt
import scipy.stats as stats
x = np.linspace(-5,10,1500)
f = stats.expon.pdf(x,2)
f = stats.expon.cdf(x,2)
plt.plot(x,f); plt.show()
plt.plot(x,f); plt.show()
4.3.2 properties of cdf
let us now describe the properties of a cdf. if we compare these with those for the discrete
cases, we see that the continuous cases simply replace the summations by integrations.
therefore, we should expect to inherit most of the properties from the discrete cases.
proposition 4.1. letxbe a random variable (either continuous or discrete), then
the cdf of xhas the following properties:
(i) the cdf is nondecreasing .
(ii) the maximum of the cdf is when x=∞:fx(+∞) = 1 .
(iii) the minimum of the cdf is when x=−∞:fx(−∞) = 0 .
1884.3. cumulative distribution function
proof . for (i), we notice that fx(x) =rx
−∞fx(x′)dx′. therefore, if s≤tthen
fx(s) =zs
−∞fx(x′)dx′≤zt
−∞fx(x′)dx′=fx(t).
thus it shows that fxis nondecreasing. (it does not need to be increasing because a cdf
can have a steady state.) for (ii) and (iii), we can show that
fx(+∞) =z+∞
−∞fx(x′)dx′= 1,and fx(−∞) =z−∞
−∞fx(x′)dx′= 0.□
example 4.12 . we can show that the cdf we derived for the uniform random variable
satisfies these three properties. to see this, we note that
fx(x) =x−a
b−a, a≤x≤b.
the derivative of this function f′
x(x) =1
b−a>0 for a≤x≤b. also, note that
fx(x) = 0 for x < a andx > b , sofxis nondecreasing. the other two properties
follow because if x=b, then fx(b) = 1, and if x=athen fx(a) = 0. together with
the nondecreasing property, we show (ii) and (iii).
proposition 4.2. letxbe a continuous random variable. if the cdf fxis contin-
uous at any a≤x≤b, then
p[a≤x≤b] =fx(b)−fx(a). (4.10)
proof . the proof follows from the definition of the cdf, which states that
fx(b)−fx(a) =zb
−∞fx(x′)dx′−za
−∞fx(x′)dx′
=zb
afx(x′)dx′=p[a≤x≤b]. □
this result provides a very handy tool for calculating the probability of an event
a≤x≤busing the cdf. it says that p[a≤x≤b] is the difference between fx(b) and
fx(a). so, if we are given fx, calculating the probability of a≤x≤bjust involves
evaluating the cdf at aandb. the result also shows that for a continuous random vari-
ablex,p[x=x0] =fx(x0)−fx(x0) = 0. this is consistent with our arguments from the
measure’s point of view.
example 4.13 . (exponential random variable ) we showed that the exponential ran-
dom variable xwith a pdf fx(x) =λe−λxforx≥0 (and fx(x) = 0 for x < 0)
has a cdf given by fx(x) = 1−e−λxforx≥0. suppose we want to calculate the
189chapter 4. continuous random variables
probability p[1≤x≤3]. then the pdf approach gives us
p[1≤x≤3] =z3
1fx(x)dx=z3
1λe−λxdx=−e−λx3
1=e−3λ−e−λ.
if we take the cdf approach, we can show that
p[1≤x≤3] =fx(3)−fx(1)
= (1−e−λ)−(1−e−3λ) =e−3λ−e−λ,
which yields the same as the pdf approach.
example 4.14 . let xbe a random variable with pdf fx(x) = 2 xfor 0≤x≤1,
and is 0 otherwise. we can show that the cdf is
fx(x) =zx
0fx(t)dt=zx
02t dt=t2x
0=x2, 0≤x≤1.
therefore, to compute the probability p[1/3≤x≤1/2], we have
p1
3≤x≤1
2
=fx1
2
−fx1
3
=1
22
−1
32
=5
36.
□
a cdf can be used for both continuous and discrete random variables. however, before
we can do that, we need a tool to handle the discontinuities. the following definition is a
summary of the three types of continuity.
definition 4.8. a function fx(x)is said to be
left-continuous atx=biffx(b) =fx(b−)def= lim h→0fx(b−h);
right-continuous atx=biffx(b) =fx(b+)def= lim h→0fx(b+h);
continuous atx=bif it is both right-continuous and left-continuous at x=b.
in this case, we have
lim
h→0fx(b−h) = lim
h→0fx(b+h) =f(b).
in this definition, the step size h >0 is shrinking to zero. the point b−hstays at the left of
b, and b+hstays at the right of b. thus, if we set the limit h→0,b−hwill approach a point
b−whereas b+hwill approach a point b+. if it happens that fx(b−) =fx(b) then we say
thatfxis left-continuous at b. iffx(b+) =fx(b) then we say that fxis right-continuous
atb. these are summarized in figure 4.8 .
whenever fxhas a discontinuous point, it can be left-continuous, right-continuous, or
neither. (“neither” happens if fx(b) take a value other than fx(b+) orfx(b−). you can
1904.3. cumulative distribution function
figure 4.8: the definition of left- and right-continuous at a point b.
always create a nasty function that satisfies this condition.) for continuous functions, it is
necessary that fx(b−) =fx(b+). if this happens, there is no gap between the two points.
theorem 4.3. for any random variable x(discrete or continuous), fx(x)is always
right-continuous . that is,
fx(b) =fx(b+)def= lim
h→0fx(b+h) (4.11)
right-continuous means that if fx(x) is piecewise, it must have a solid left end and an
empty right end . figure 4.9 shows an example of a valid cdf and an invalid cdf.
figure 4.9: a cdf must be right-continuous.
the reason why fxis always right-continuous is that the inequality x≤xhas a
closed right-hand limit. imagine the following situation: a discrete random variable xhas
four states: 1 ,2,3,4. then,
lim
h→0fx(3 +h) = lim
h→0“3 + h”x
k=1px(k) =px(1) + px(2) + px(3) = fx(3).
similarly, if you have a continuous random variable xwith a pdf fx, then
lim
h→0fx(b+h) = lim
h→0zb+h
−∞fx(t)dt=zb
−∞fx(t)dt=fx(b).
191chapter 4. continuous random variables
in other words, the “ ≤” ensures that the rightmost state is included. if we defined cdf
using <, we would have gotten left-hand continuous, but this would be inconvenient because
the<requires us to deal with limits whenever we evaluate x < x .
theorem 4.4. for any random variable x(discrete or continuous), p[x=b]is
p[x=b] =(
fx(b)−fx(b−),iffxis discontinuous at x=b
0,otherwise.(4.12)
this proposition states that when fx(x) is discontinuous at x=b, then p[x=b] is
the difference between fx(b) and the limit from the left. in other words, the height of the
gap determines the probability at the discontinuity. if fx(x) is continuous at x=b, then
fx(b) = lim h→0fx(b−h) and so p[x=b] = 0.
figure 4.10: illustration of equation (4.12). since the cdf is discontinuous at a point x=b, the gap
fx(b)−fx(b−)will define the probability p[x=b].
example 4.15 . consider a random variable xwith a pdf
fx(x) =

x,0≤x≤1,
1
2, x= 3,
0,otherwise .
the cdf fx(x) will consist of a few segments. the first segment is 0 ≤x <1. we
can show that
fx(x) =zx
0fx(t)dt=zx
0t dt=t2
2x
0=x2
2,0≤x <1.
the second segment is when 1 ≤x <3. since there is no new fxto integrate, the
cdf stays at fx(x) =fx(1) =1
2for 1≤x <3. the third segment is x >3. because
this range has covered the entire sample space, we have fx(x) = 1 for x >3. how
about x= 3? we can show that
fx(3) = fx(3+) = 1 .
1924.3. cumulative distribution function
therefore, to summarize, the cdf is
fx(x) =

0, x < 0,
x2
2, 0≤x <1,
1
2, 1≤x <3,
1, x ≥3.
a graphical illustration is shown in figure 4.11 .
figure 4.11: an example of converting a pdf to a cdf.
4.3.3 retrieving pdf from cdf
thus far, we have only seen how to obtain fx(x) from fx(x). in order to go in the reverse
direction, we recall the fundamental theorem of calculus. this states that if a function fis
continuous, then
f(x) =d
dxzx
af(t)dt
for some constant a. using this result for cdf and pdf, we have the following:
theorem 4.5. theprobability density function (pdf) is the derivative of the cu-
mulative distribution function (cdf):
fx(x) =dfx(x)
dx=d
dxzx
−∞fx(x′)dx′, (4.13)
provided fxis differentiable at x. iffxis not differentiable at x=x0, then,
fx(x0) =p[x=x0]δ(x−x0).
example 4.16 . consider a cdf
fx(x) =(
0, x < 0,
1−1
4e−2x, x ≥0.
we want to find the pdf fx(x). to do so, we first show that fx(0) =3
4. this
193chapter 4. continuous random variables
corresponds to a discontinuity at x= 0, as shown in figure 4.12 .
figure 4.12: an example of converting a pdf to a cdf.
because of the discontinuity, we need to consider three cases:
fx(x) =

dfx(x)
dx, x < 0,
p[x= 0]δ(x−0), x = 0,
dfx(x)
dx, x > 0.
when x <0,fx(x) = 0, sodfx(x)
dx= 0. when x >0,fx(x) = 1−1
4e−2x, so
dfx(x)
dx=1
2e−2x.
when x= 0, the probability p[x= 0] is determined by the gap between the solid dot
and the empty dot. this yields
p[x= 0] = fx(0)−lim
h→0fx(0−h) =3
4−0 =3
4.
therefore, the overall pdf is
fx(x) =

0, x < 0,
3
4δ(x−0), x = 0,
1
2e−2x, x > 0.
figure 4.12 illustrates this example.
4.3.4 cdf: unifying discrete and continuous random variables
the cdf is always a well-defined function. it is integrable everywhere. if the underlying
random variable is continuous, the cdf is also continuous. if the underlying random variable
is discrete, the cdf is a staircase function. we have seen enough cdfs for continuous
random variables. let us (re)visit a few discrete random variables.
example 4.17 . (geometric random variable) consider a geometric random variable
with pmf px(k) = (1 −p)k−1p, fork= 1,2, . . ..
1944.3. cumulative distribution function
figure 4.13: pmf and cdf of a geometric random variable.
we can show that the cdf is
fx(k) =kx
ℓ=1px(ℓ) =kx
ℓ=1(1−p)ℓ−1p=p·1−(1−p)k
1−(1−p)= 1−(1−p)k.
for a sanity check, we can try to retrieve the pmf from the cdf:
px(k) =fx(k)−fx(k−1)
= (1−(1−p)k)−(1−(1−p)k−1)
= (1−p)k−1p.
a graphical portrayal of this example is shown in figure 4.13 .
if we treat the pmfs as delta functions in the above example, then the continuous
definition also applies. since the cdf is a piecewise constant function, the derivative is
exactly a delta function. for some problems, it is easier to start with cdf and then compute
the pmf or pdf. here is an example.
example 4.18 . let x1,x2andx3be three independent discrete random variables
with sample space ω = {1,2, . . . , 10}. define x= max {x1, x2, x3}. we want to
find the pmf of x. to tackle this problem, we first observe that the pmf for x1is
px1(k) =1
10. thus, the cdf of x1is
fx1(k) =kx
ℓ=1px1(ℓ) =k
10.
then, we can show that the cdf of xis
fx(k) =p[x≤k] =p[max{x1, x2, x3} ≤k]
(a)=p[x1≤k∩x2≤k∩x3≤k]
(b)=p[x1≤k]p[x2≤k]p[x3≤k]
=k
103
,
195chapter 4. continuous random variables
where in ( a) we use the fact that max {x1, x2, x3} ≤kif and only if all three elements
are less than k, and in ( b) we use independence. consequently, the pmf of xis
px(k) =fx(k)−fx(k−1) =k
103
−k−1
103
.
what is a cdf?
cdf is fx(x) =p[x≤x]. it is the cumulative sum of the pmf/pdf.
cdf is either a staircase function, a smooth function, or a hybrid. unlike a
pdf, which is not defined for discrete random variables, the cdf is always well
defined.
cdfd
dx−→pdf.
cdfr
←−pdf.
gap of jump in cdf = height of delta in pdf.
4.4 median, mode, and mean
there are three statistical quantities that we are frequently interested in: mean, mode, and
median. we all know how to compute these from a dataset. for example, to compute the
median of a dataset, we sort the data and pick the number that sits in the 50th percentile.
however, the median computed in this way is the empirical median , i.e., it is a value
computed from a particular dataset. if the data is generated from a random variable (with
a given pdf), how do we compute the mean, median, and mode?
4.4.1 median
imagine you have a sequence of numbers as shown below.
n 1 2 3 4 5 6 7 8 9 ··· 100
xn1.5 2.5 3.1 1.1 −0.4−4.1 0.5 2.2 −3.4··· − 1.4
how do we compute the median? we first sort the sequence (either in ascending order
or descending order), and then pick the middle one. on computer, we permute the samples
{x1′, x2′, . . . , x n′}= sort {x1, x2, . . . , x n},
such that x1′< x2′< . . . < x n′is ordered. the median is the one positioned at the middle.
there are, of course, built-in commands such as median in matlab and np.median in
python to perform the median operation.
now, how do we compute the median if we are given a random variable xwith a pdf
fx(x)? the answer is by integrating the pdf.
1964.4. median, mode, and mean
definition 4.9. letxbe a continuous random variable with pdf fx. the median
ofxis a point c∈rsuch that
zc
−∞fx(x)dx=z∞
cfx(x)dx. (4.14)
why is the median defined in this way? this is becauserc
−∞fx(x)dxis the area under
the curve on the left of c, andr∞
cfx(x)dxis the area under the curve on the right of c.
the area under the curve tells us the percentage of numbers that are less than the cutoff.
therefore, if the left area equals the right area, then cmust be the median.
how to find the median from the pdf
find a point cthat separates the pdf into two equal areas
figure 4.14: [left] the median is computed as the point such that the two areas under the curve are
equal. [right] the median is computed as the point such that fxhits 0.5.
the median can also be evaluated from the cdf as follows.
theorem 4.6. themedian of a random variable xis the point csuch that
fx(c) =1
2. (4.15)
proof . since fx(x) =rx
−∞fx(x′)dx′, we have
fx(c) =zc
−∞fx(x)dx
=z∞
cfx(x)dx= 1−fx(c).
rearranging the terms shows that fx(c) =1
2. □
197chapter 4. continuous random variables
how to find median from cdf
find a point csuch that fx(c) = 0 .5.
example 4.19 . (uniform random variable ) let xbe a continuous random variable
with pdf fx(x) =1
b−afora≤x≤b, and is 0 otherwise. we know that the cdf of
xisfx(x) =x−a
b−afora≤x≤b. therefore, the median of xis the number c∈r
such that fx(c) =1
2. substituting into the cdf yieldsc−a
b−a=1
2, which gives c=a+b
2.
example 4.20 . (exponential random variable ) let xbe a continuous random vari-
able with pdf fx(x) =λe−λxforx≥0. we know that the cdf of xisfx(x) =
1−e−λxforx≥0. the median of xis the point csuch that fx(c) =1
2. this gives
1−e−λc=1
2, which is c=log 2
λ.
4.4.2 mode
the mode is the peak of the pdf. we can see this from the definition below.
definition 4.10. letxbe a continuous random variable. the mode is the point c
such that fx(x)attains the maximum:
c=argmax
x∈ωfx(x) =argmax
x∈ωd
dxfx(x). (4.16)
the second equality holds because fx(x) =f′
x(x) =d
dxrx
−∞fx(t)dt. a pictorial illustra-
tion of mode is given in figure 4.15 . note that the mode of a random variable is not unique,
e.g., a mixture of two identical gaussians with different means has two modes.
figure 4.15: [left] the mode appears at the peak of the pdf. [right] the mode appears at the steepest
slope of the cdf.
1984.4. median, mode, and mean
how to find mode from pdf
find a point csuch that fx(c) is maximized.
how to find mode from cdf
continuous: find a point csuch that fx(c) has the steepest slope.
discrete: find a point csuch that fx(c) has the biggest gap in a jump.
example 4.21 . let xbe a continuous random variable with pdf fx(x) = 6 x(1−x)
for 0≤x≤1. the mode of xhappens at argmax
xfx(x). to find this maximum, we
take the derivative of fx. this gives
0 =d
dxfx(x) =d
dx6x(1−x) = 6(1 −2x).
setting this equal to zero yields x=1
2.
to ensure that this point is a maximum, we take the second-order derivative:
d2
dx2fx(x) =d
dx6(1−2x) =−12<0.
therefore, we conclude that x=1
2is a maximum point. hence, the mode of xis
x=1
2.
4.4.3 mean
we have defined the mean as the expectation of x. here, we show how to compute the
expectation from the cdf. to simplify the demonstration, let us first assume that x > 0.
lemma 4.1. letx > 0. then e[x]can be computed from fxas
e[x] =z∞
0(1−fx(t))dt. (4.17)
proof . the trick is to change the integration order:
z∞
0(1−fx(t))dt=z∞
0[1−p[x≤t]]dt=z∞
0p[x > t ]dt
=z∞
0z∞
tfx(x)dx dt(a)=z∞
0zx
0fx(x)dt dx
=z∞
0zx
0dtfx(x)dx=z∞
0xfx(x)dx=e[x].
here, step ( a) is due to the change of integration order. see figure 4.16 for an illustration.
□
we draw a picture to illustrate the above lemma. as shown in figure 4.17 , the mean
of a positive random variable x > 0 is equivalent to the area above the cdf.
199chapter 4. continuous random variables
figure 4.16: the double integration can be evaluated by xthent, ortthenx.
figure 4.17: the mean of a positive random variable x > 0can be calculated by integrating the cdf’s
complement.
lemma 4.2. letx < 0. then e[x]can be computed from fxas
e[x] =z0
−∞fx(t)dt. (4.18)
proof . the idea here is also to change the integration order.
z0
−∞fx(t)dt=z0
−∞p[x≤t]dt=z0
−∞zt
−∞fx(x)dx dt
=z0
−∞z0
xfx(x)dt dx =z0
−∞xfx(x)dx=e[x].
□
theorem 4.7. the mean of a random variable xcan be computed from the cdf as
e[x] =z∞
0(1−fx(t))dt−z0
−∞fx(t)dt. (4.19)
2004.5. uniform and exponential random variables
proof . for any random variable x, we can partition x=x+−x−where x+andx−are
the positive and negative parts, respectively. then, the above two lemmas will give us
e[x] =e[x+−x−] =e[x+]−e[x−]
=z∞
0(1−fx(t))dt−z0
−∞fx(t)dt.
□
as illustrated in figure 4.18 , this equation is equivalent to computing the areas above
and below the cdf and taking the difference.
figure 4.18: the mean of a random variable xcan be calculated by computing the area in the cdf.
how to find the mean from the cdf
a formula is given by equation (4.20):
e[x] =z∞
0(1−fx(t))dt−z0
−∞fx(t)dt. (4.20)
this result is not commonly used, but the proof technique of switching the inte-
gration order is important.
4.5 uniform and exponential random variables
there are many useful continuous random variables. in this section, we discuss two of them:
uniform random variables and exponential random variables. in the next section, we will
discuss the gaussian random variables. similarly to the way we discussed discrete random
variables, we take a generative / synthesis perspective when studying continuous random
variables. we assume we have access to the pdf of the random variables so we can derive
the theoretical mean and variance. the opposite direction, namely inferring the underlying
model parameters from a dataset, will be discussed later.
201chapter 4. continuous random variables
4.5.1 uniform random variables
definition 4.11. letxbe a continuous uniform random variable . the pdf of xis
fx(x) =(
1
b−a, a ≤x≤b,
0, otherwise ,(4.21)
where [a, b]is the interval on which xis defined. we write
x∼uniform( a, b)
to mean that xis drawn from a uniform distribution on an interval [a, b].
0 0.2 0.4 0.6 0.8 100.511.522.53
0 0.2 0.4 0.6 0.8 100.20.40.60.811.2
(a) pdf (b) cdf
figure 4.19: the pdf and cdf of x∼uniform (0.2,0.6).
the shape of the pdf of a uniform random variable is shown in figure 4.19 . in this
figure, we assume that the random variables x∼uniform(0 .2,0.6) are taken from the
sample space ω = [0 ,1]. note that the height of the uniform distribution is greater than 1,
since
fx(x) =(
1
0.6−0.2= 2.5, 0.2≤x≤0.6,
0, otherwise .
there is nothing wrong with this pdf, because fx(x) is the probability per unit length . if we
integrate fx(x) over any sub-interval between 0.2 and 0.6, we can show that the probability
is between 0 and 1.
the cdf of a uniform random variable can be determined by integrating fx(x):
fx(x) =zx
−∞fx(t)dt
=zx
a1
b−adt
=x−a
b−a, a ≤x≤b.
2024.5. uniform and exponential random variables
therefore, the complete cdf is
fx(x) =

0, x < a,
x−a
b−a, a ≤x≤b,
1, x > b.
the corresponding cdf for the pdf we showed in figure 4.19 (a) is shown in figure 4.19 (b).
it can be seen that although the height of the pdf exceeds 1, the cdf grows linearly and
saturates at 1.
remark . the uniform distribution can also be defined for discrete random variables. in
this case, the probability mass function is given by
px(k) =1
b−a+ 1, k =a, a+ 1, . . . , b.
the presence of “1” in the denominator of the pmf is because kruns from atob, including
the two endpoints.
in matlab and python, generating uniform random numbers can be done by calling
commands unifrnd (matlab), and stats.uniform.rvs (python). for discrete uniform
random variables, in matlab the command is unidrnd , and in python the command is
stats.randint .
% matlab code to generate 1000 uniform random numbers
a = 0; b = 1;
x = unifrnd(a,b,[1000,1]);
hist(x);
# python code to generate 1000 uniform random numbers
import scipy.stats as stats
a = 0; b = 1;
x = stats.uniform.rvs(a,b,size=1000)
plt.hist(x);
to compute the empirical average and variance of the random numbers in matlab
we can call the command mean andvar. the corresponding command in python is np.mean
andnp.var . we can also compute the median and mode, as shown below.
% matlab code to compute empirical mean, var, median, mode
x = unifrnd(a,b,[1000,1]);
m = mean(x);
v = var(x);
med = median(x);
mod = mode(x);
# python code to compute empirical mean, var, median, mode
x = stats.uniform.rvs(a,b,size=1000)
m = np.mean(x)
v = np.var(x)
203chapter 4. continuous random variables
med = np.median(x)
mod = stats.mode(x)
the mean and variance of a uniform random variable are given by the theorem below.
theorem 4.8. ifx∼uniform( a, b), then
e[x] =a+b
2and var[x] =(b−a)2
12. (4.22)
proof . we have derived these results before. here is a recap for completeness:
e[x] =z∞
−∞xfx(x)dx=zb
ax
b−adx=a+b
2,
e[x2] =z∞
−∞x2fx(x)dx=zb
ax2
b−adx=a2+ab+b2
3,
var[x] =e[x2]−e[x]2=(b−a)2
12.
□
the result should be intuitive because it says that the mean is the midpoint of the
pdf.
when will we encounter a uniform random variable? uniform random variables are one
of the most elementary continuous random variables. given a uniform random variable, we
can construct any random variable by using an appropriate transformation. we will discuss
this technique as part of our discussion about generating random numbers.
in matlab, computing the mean and variance of a uniform random variable can be
done using the command unifstat . the python coommand is stats.uniform.stats .
% matlab code to compute mean and variance
a = 0; b = 1;
[m,v] = unifstat(a,b)
# python code to compute mean and variance
import scipy.stats as stats
a = 0; b = 1;
m, v = stats.uniform.stats(a,b,moments=’mv’)
to evaluate the probability p[ℓ≤x≤u] for a uniform random variable, we can call
unifcdf in matlab and
% matlab code to compute the probability p(0.2 < x < 0.3)
a = 0; b = 1;
f = unifcdf(0.3,a,b) - unifcdf(0.2,a,b)
2044.5. uniform and exponential random variables
# python code to compute the probability p(0.2 < x < 0.3)
a = 0; b = 1;
f = stats.uniform.cdf(0.3,a,b)-stats.uniform.cdf(0.2,a,b)
an alternative is to define an object rv = stats.uniform , and call the cdf attribute:
# python code to compute the probability p(0.2 < x < 0.3)
a = 0; b = 1;
rv = stats.uniform(a,b)
f = rv.cdf(0.3)-rv.cdf(0.2)
4.5.2 exponential random variables
definition 4.12. letxbe an exponential random variable . the pdf of xis
fx(x) =(
λe−λx, x ≥0,
0, otherwise ,(4.23)
where λ >0is a parameter. we write
x∼exponential( λ)
to mean that xis drawn from an exponential distribution of parameter λ.
in this definition, the parameter λof the exponential random variable determines the rate
of decay. a large λimplies a faster decay. the pdf of an exponential random variable is
illustrated in figure 4.20 . we show two values of λ. note that the initial value fx(0) is
fx(0) = λe−λ0=λ.
therefore, as long as λ >1,fx(0) will exceed 1.
the cdf of an exponential random variable can be determined by
fx(x) =zx
−∞fx(t)dt
=zx
0λe−λtdt= 1−e−λx, x ≥0.
therefore, if we consider the entire real line, the cdf is
fx(x) =(
0, x < 0,
1−e−λx, x ≥0.
the corresponding cdfs for the pdfs shown in figure 4.20 (a) are shown in fig-
ure 4.20 (b). for larger λ, the pdf fx(x) decays faster but the cdf fx(x) increases faster.
205chapter 4. continuous random variables
0 0.2 0.4 0.6 0.8 10123456
 = 2
 = 5
0 0.2 0.4 0.6 0.8 100.20.40.60.811.2
 = 2
 = 5
(a) pdf (b) cdf
figure 4.20: (a) the pdf and (c) the cdf of x∼exponential (λ).
in matlab, the code used to generate figure 4.20 (a) is shown below. there are
multiple ways of doing this. an alternative way is to call exppdf , which will return the same
result. in python, the corresponding command is stats.expon.pdf . note that in python
the parameter λis specified in scale option.
% matlab code to plot the exponential pdf
lambda1 = 1/2; lambda2 = 1/5;
x = linspace(0,1,1000);
f1 = pdf(’exp’,x, lambda1);
f2 = pdf(’exp’,x, lambda2);
plot(x, f1, ’linewidth’, 4, ’color’, [0 0.2 0.8]); hold on;
plot(x, f2, ’linewidth’, 4, ’color’, [0.8 0.2 0]);
# python code to plot the exponential pdf
lambd1 = 1/2
lambd2 = 1/5
x = np.linspace(0,1,1000)
f1 = stats.expon.pdf(x,scale=lambd1)
f2 = stats.expon.pdf(x,scale=lambd2)
plt.plot(x, f1)
plt.plot(x, f2)
to plot the cdf, we replace pdfbycdf. similarly, in python we replace expon.pdf
byexpon.cdf .
% matlab code to plot the exponential cdf
f = cdf(’exp’,x, lambda1);
plot(x, f, ’linewidth’, 4, ’color’, [0 0.2 0.8]);
# python code to plot the exponential cdf
f = stats.expon.cdf(x,scale=lambd1)
plt.plot(x, f)
2064.5. uniform and exponential random variables
theorem 4.9. ifx∼exponential( λ), then
e[x] =1
λand var[x] =1
λ2. (4.24)
proof . we have discussed this proof before. here is a recap for completeness:
e[x] =z∞
−∞xfx(x)dx=z∞
0λxe−λxdx
=−z∞
0xde−λx
=−xe−λx∞
0+z∞
0e−λxdx=1
λ,
e[x2] =z∞
−∞x2fx(x)dx=z∞
0λx2e−λxdx
=−z∞
0x2de−λx
=−x2e−λx∞
0+z∞
02xe−λxdx
= 0 +2
λe[x] =2
λ2.
thus, var[ x] =e[x2]−e[x]2=1
λ2.
□
computing the mean and variance of an exponential random variable in matlab and
python follows the similar procedures that we described above.
4.5.3 origin of exponential random variables
exponential random variables are closely related to poisson random variables. recall that
the definition of a poisson random variable is a random variable that describes the number
of events that happen in a certain period, e.g., photon arrivals, number of pedestrians, phone
calls, etc. we summarize the origin of an exponential random variable as follows.
what is the origin of exponential random variables?
an exponential random variable is the interarrival time between two consecutive
poisson events.
that is, an exponential random variable is how much time it takes to go from n
poisson counts to n+ 1 poisson counts.
an example will clarify this concept. imagine that you are waiting for a bus, as illus-
trated in figure 4.21 . passengers arrive at the bus stop with an arrival rate λper unit time.
thus, for some time t, the average number of people that arrive is λt. let nbe a random
207chapter 4. continuous random variables
variable denoting the number of people. we assume that nis poisson with a parameter λt.
that is, for any duration t, the probability of observing npeople follows the pmf
p[n=n] =(λt)n
n!e−λt.
figure 4.21: for any fixed period of time t, the number of people nis modeled as a poisson random
variable with a parameter λt.
figure 4.22: the interarrival time tbetween two consecutive poisson events is an exponential random
variable.
lettbe the interarrival time between two people, by which we mean the time between
two consecutive arrivals, as shown in figure 4.22 . note that tis a random variable because
tdepends on n, which is itself a random variable. to find the pdf of t, we first find the
cdf of t. we note that
p[t > t ](a)=p[interarrival time > t]
(b)=p[no arrival in t](c)=p[n= 0] =(λt)0
0!e−λt=e−λt.
in this set of arguments, (a) holds because tis the interarrival time, and (b) holds be-
cause interarrival time is between two consecutive arrivals. if the interarrival time is larger
than t, there is no arrival during the period. equality (c) holds because nis the number of
passengers.
sincep[t > t ] = 1−ft(t), where ft(t) is the cdf of t, we can show that
ft(t) = 1−e−λt,
ft(t) =d
dtft(t) =λe−λt.
therefore, the interarrival time tfollows an exponential distribution.
since exponential random variables are tightly connected to poisson random variables,
we should expect them to be useful for modeling temporal events. we discuss two examples.
2084.5. uniform and exponential random variables
4.5.4 applications of exponential random variables
example 4.22 . (photon arrivals ) single-photon image sensors are designed to op-
erate in the photon-limited regime. the number-one goal of using these sensors is to
count the number of arriving photons precisely. however, for some applications not
all single-photon image sensors are used to count photons. some are used to measure
the time between two photon arrivals, such as time-of-flight systems. in this case, we
are interested in measuring the time it takes for a pulse to bounce back to the sensor.
the more time it takes for a pulse to come back, the greater the distance between the
object and the sensor. other applications utilize the time information. for example,
high-dynamic-range imaging can be achieved by recording the time between two pho-
ton arrivals because brighter regions have a higher poisson rate λand darker regions
have a lower λ.
the figure above illustrates an example of high-dynamic-range imaging. when the
scene is bright, the large λwill generate more photons. therefore, the interarrival time
between the consecutive photons will be relatively short. if we plot the histogram of
the interarrival time, we observe that most of the interarrival time will be concentrated
at small values. dark regions behave in the opposite manner. the interarrival time will
typically be much longer. in addition, because there is more variation in the photon
arrival times, the histogram will look shorter and wider. nevertheless, both cases are
modeled by the exponential random variable.
example 4.23 . (energy-efficient escalator ) many airports today have installed variable-
speed escalators. these escalators change their speeds according to the traffic. if there
are no passengers for more than a certain period (say, 60 seconds), the escalator will
switch from the full-speed mode to the low-speed mode. for moderately busy esca-
lators, the variable-speed configuration can save energy. the interesting data-science
problem is to determine, given a traffic pattern, e.g., the one shown in figure 4.23 ,
whether we can predict the amount of energy savings?
we will not dive into the details of this problem, but we can briefly discuss the
principle. consider a fixed arrival rate λ(say, the average from 07:00 to 08:00). the in-
terarrival time, according to our discussion above, follows an exponential distribution.
209chapter 4. continuous random variables
so we know that
ft(t) =λe−λt.
suppose that the escalator switches to low-speed mode when the interarrival time
exceeds τ. then we can define a new variable yto denote the amount of time that
the escalator will operate in the low-speed mode. this new variable is
y=(
t−τ, t > τ,
0, t ≤τ.
in other words, if the interarrival time tis more than τ, then the amount of time
saved y takes the value t−τ, but if the interarrival time is less than τ, then there is
no saving.
figure 4.23: the variable-speed escalator problem. [left] we model the passengers as independent
poisson arrivals. thus, the interarrival time is exponential. [right] a hypothetical passenger arrival
rate (number of people per minute), from 06:00 to 23:00.
figure 4.24: the escalator problem requires modeling the cutoff threshold τsuch that if t > τ ,
the savings are y=t−τ. ift < τ , then y= 0. the left-hand side of the figure shows how the
pdf of yis constructed.
the pdf of ycan be computed according to figure 4.24 . there are two parts
to the calculation. when y= 0, there is a probability mass such that
fy(0) =p[y= 0] =zτ
0ft(t)dt=zτ
0λe−λtdt= 1−e−λτ.
for other values of y, we can show that
fy(y) =ft(y+τ) =λe−λ(y+τ).
therefore, to summarize, we can show that the pdf of yis
fy(y) =(
(1−e−λτ)δ(y), y = 0,
λe−λ(y+τ), y > 0.
2104.6. gaussian random variables
consequently, we can compute e[y] and var[ y] and analyze how these values change
forλ(which itself changes with the time of day). furthermore, we can analyze the
amount of savings in terms of dollars. we leave these problems as an exercise.
closing remark . the photon arrival problem and the escalator problem are two of many
examples we can find in which exponential random variables are useful for modeling a
problem. we did not go into the details of the problems because each of them requires some
additional modeling to address the real practical problem. we encourage you to explore these
problems further. our message is simple: many problems can be modeled by exponential
random variables, most of which are associated with time.
4.6 gaussian random variables
we now discuss themost important continuous random variable — the gaussian random
variable (also known as the normal random variable ). we call it the most important random
variable because it is widely used in almost all scientific disciplines. many of us have used
gaussian random variables before, and perhaps its bell shape is the first lesson we learn in
statistics. however, there are many mysteries about gaussian random variables which you
may have missed, such as: where does the gaussian random variable come from? why does
it take a bell shape? what are the properties of a gaussian random variable? the objective
of this section is to explain everything you need to know about a gaussian random variable.
4.6.1 definition of a gaussian random variable
definition 4.13. agaussian random variable is a random variable xsuch that its
pdf is
fx(x) =1√
2πσ2exp
−(x−µ)2
2σ2
, (4.25)
where (µ, σ2)are parameters of the distribution. we write
x∼gaussian (µ, σ2) or x∼ n(µ, σ2)
to say that xis drawn from a gaussian distribution of parameter (µ, σ2).
gaussian random variables have two parameters ( µ, σ2). it is noteworthy that the mean
isµand the variance is σ2— these two parameters are exactly the first moment and the
second central moment of the random variable. most other random variables do not have
this property.
note that a gaussian random variable is positive from −∞ to∞. thus, fx(x) has
a non-zero value for any x, even though the value may be extremely small. a gaussian
random variable is also symmetric about µ. ifµ= 0, then fx(x) is an even function.
the shape of the gaussian is illustrated in figure 4.25 . when we fix the variance and
change the mean, the pdf of the gaussian moves left or right depending on the sign of the
mean. when we fix the mean and change the variance, the pdf of the gaussian changes
211chapter 4. continuous random variables
its width. since any pdf should integrate to unity, a wider gaussian means that the pdf
is shorter. note also that if σis very small, it is possible that fx(x)>1 although the
integration over ω will still be 1.
-10 -5 0 5 1000.10.20.30.40.5
 = -3
 = -0.3
 = 0
 = 1.2
 = 4
-10 -5 0 5 1000.10.20.30.40.5
 = 0.8
 = 1
 = 2
 = 3
 = 4
µchanges, σ= 1 µ= 0,σchanges
figure 4.25: a gaussian random variable with different µandσ.
on a computer, plotting the gaussian pdf can be done by calling the function
pdf(’norm’,x) in matlab, and stats.norm.pdf in python.
% matlab to generate a gaussian pdf
x = linspace(-10,10,1000);
mu = 0; sigma = 1;
f = pdf(’norm’,x,mu,sigma);
plot(x, f);
# python to generate a gaussian pdf
import numpy as np
import matplotlib.pyplot as plt
import scipy.stats as stats
x = np.linspace(-10,10,1000)
mu = 0; sigma = 1;
f = stats.norm.pdf(x,mu,sigma)
plt.plot(x,f)
our next result concerns the mean and variance of a gaussian random variable. you
may wonder why we need this theorem when we already know that µis the mean and σ2is
the variance. the answer is that we have not proven these two facts.
theorem 4.10. ifx∼gaussian (µ, σ2), then
e[x] =µ,and var[x] =σ2. (4.26)
2124.6. gaussian random variables
proof . the expectation can be derived via substitution:
e[x] =1√
2πσ2z∞
−∞xe−(x−µ)2
2σ2dx
(a)=1√
2πσ2z∞
−∞(y+µ)e−y2
2σ2dy
=1√
2πσ2z∞
−∞ye−y2
2σ2dy+1√
2πσ2z∞
−∞µe−y2
2σ2dy
(b)= 0 + µ1√
2πσ2z∞
−∞e−y2
2σ2dy
(c)=µ,
where in (a) we substitute y=x−µ, in (b) we use the fact that the first integrand is odd
so that the integration is 0, and in (c) we observe that integration over the entire sample
space of the pdf yields 1.
the variance is also derived by substitution.
var[x] =1√
2πσ2z∞
−∞(x−µ)2e−(x−µ)2
2σ2dx
(a)=σ2
√
2πz∞
−∞y2e−y2
2dy
=σ2
√
2π
−ye−y2
2∞
−∞
+σ2
√
2πz∞
−∞e−y2
2dy
= 0 + σ21√
2πz∞
−∞e−y2
2dy
=σ2,
where in (a) we substitute y= (x−µ)/σ.
4.6.2 standard gaussian
we need to evaluate the probability p[a≤x≤b] of a gaussian random variable xin many
practical situations. this involves the integration of the gaussian pdf, i.e., determining the
cdf. unfortunately, there is no closed-form expression of p[a≤x≤b] in terms of ( µ, σ2).
this leads to what we call the standard gaussian.
definition 4.14. thestandard gaussian (or standard normal) random variable x
has a pdf
fx(x) =1√
2πe−x2
2. (4.27)
that is, x∼ n(0,1)is a gaussian with µ= 0andσ2= 1.
the cdf of the standard gaussian can be determined by integrating the pdf. we have a
special notation for this cdf. figure 4.26 illustrates the idea.
213chapter 4. continuous random variables
definition 4.15. thecdf of the standard gaussian is defined as the φ(·)function
φ(x)def=fx(x) =1√
2πzx
−∞e−t2
2dt. (4.28)
figure 4.26: definition of the cdf of the standard gaussian φ(x).
% matlab code to generate standard gaussian pdf and cdf
x = linspace(-5,5,1000);
f = normpdf(x,0,1);
f = normcdf(x,0,1);
figure; plot(x, f);
figure; plot(x, f);
# python code to generate standard gaussian pdf and cdf
import numpy as np
import matplotlib.pyplot as plt
import scipy.stats as stats
x = np.linspace(-10,10,1000)
f = stats.norm.pdf(x)
f = stats.norm.cdf(x)
plt.plot(x,f); plt.show()
plt.plot(x,f); plt.show()
the standard gaussian’s cdf is related to a so-called error function defined as
erf(x) =2√πzx
0e−t2dt. (4.29)
it is easy to link φ( x) with erf( x):
φ(x) =1
2
1 + erfx√
2
, and erf( x) = 2φ( x√
2)−1.
with the standard gaussian cdf, we can define the cdf of an arbitrary gaussian.
2144.6. gaussian random variables
theorem 4.11 (cdf of an arbitrary gaussian ).letx∼ n(µ, σ2). then
fx(x) = φx−µ
σ
. (4.30)
proof . we start by expressing fx(x):
fx(x) =p[x≤x]
=zx
−∞1√
2πσ2e−(t−µ)2
2σ2dt.
substituting y=t−µ
σ, and using the definition of standard gaussian, we have
zx
−∞1√
2πσ2e−(t−µ)2
2σ2dt=zx−µ
σ
−∞1√
2πe−y2
2dy
= φx−µ
σ
.□
if you would like to verify this on a computer, you can try the following code.
% matlab code to verify standardized gaussian
x = linspace(-5,5,1000);
mu = 3; sigma = 2;
f1 = normpdf((x-mu)/sigma,0,1); % standardized
f2 = normpdf(x, mu, sigma); % raw
# python code to verify standardized gaussian
import numpy as np
import matplotlib.pyplot as plt
import scipy.stats as stats
x = np.linspace(-5,5,1000)
mu = 3; sigma = 2;
f1 = stats.norm.pdf((x-mu)/sigma,0,1) # standardized
f2 = stats.norm.cdf(x,mu,sigma) # raw
an immediate consequence of this result is that
p[a < x ≤b] = φb−µ
σ
−φa−µ
σ
. (4.31)
to see this, note that
p[a < x ≤b] =p[x≤b]−p[x≤a]
= φb−µ
σ
−φa−µ
σ
.
the inequality signs of the two end points are not important. that is, the statement also
holds for p[a≤x≤b] orp[a < x < b ], because xis a continuous random variable at
every x. thus, p[x=a] =p[x=b] = 0 for any aandb. besides this, φ has several
properties of interest. see if you can prove these:
215chapter 4. continuous random variables
corollary 4.1. letx∼ n(µ, σ2). then the following results hold:
φ(y) = 1−φ(−y).
p[x≥b] = 1−φ
b−µ
σ
.
p[|x| ≥b] = 1−φ
b−µ
σ
+ φ
−b−µ
σ
.
4.6.3 skewness and kurtosis
in modern data analysis we are sometimes interested in high-order moments. here we con-
sider two useful quantities: skewness andkurtosis .
definition 4.16. for a random variable xwith pdf fx(x), define the following
central moments as
mean =e[x]def=µ,
variance =eh
(x−µ)2idef=σ2,
skewness =e"x−µ
σ3#
def=γ,
kurtosis =e"x−µ
σ4#
def=κ, excess kurtosisdef=κ−3.
as you can see from the definitions above, skewness is the third central moment,
whereas kurtosis is the fourth central moment. both skewness and kurtosis can be regarded
as “deviations” from a standard gaussian —not in terms of mean and variance but in terms
of shape.
skewness measures the asymmetry of the distribution. figure 4.27 shows three differ-
ent distributions: one with left skewness, one with right skewness, and one symmetric. the
skewness of a curve is
skewed towards left: positive
skewed towards right: negative
symmetric: zero
what is skewness?
e
x−µ
σ3
.
measures the asymmetry of the distribution.
gaussian has skewness 0.
2164.6. gaussian random variables
0 5 10 15 2000.10.20.30.4
positive skewness
symmetric
negative skewness
figure 4.27: skewness of a distribution measures the asymmetry of the distribution. in this example
the skewnesses are: orange = 0.8943, black = 0, blue = -1.414.
kurtosis measures how heavy-tailed the distribution is. there are two forms of kurtosis:
one is the standard kurtosis, which is the fourth central moment, and the other is the excess
kurtosis, which is κexcess =κ−3. the constant 3 comes from the kurtosis of a standard
gaussian. excess kurtosis is more widely used in data analysis. the interpretation of kurtosis
is the comparison to a gaussian. if the kurtosis is positive, the distribution has a tail that
decays faster than a gaussian. if the kurtosis is negative, the distribution has a tail that
decays more slowly than a gaussian. figure 4.28 illustrates the (excess) kurtosis of three
different distributions.
-5 -4 -3 -2 -1 0 1 2 3 4 500.20.40.60.81
kurtosis > 0
kurtosis = 0
kurtosis < 0
figure 4.28: kurtosis of a distribution measures how heavy-tailed the distribution is. in this example,
the (excess) kurtoses are: orange = 2.8567, black = 0, blue = −0.1242.
what is kurtosis?
κ=e
x−µ
σ4
.
measures how heavy-tailed the distribution is. gaussian has kurtosis 3.
some statisticians prefer excess kurtosis κ−3, so that gaussian has excess
kurtosis 0.
217chapter 4. continuous random variables
random variable mean variance skewness excess kurtosis
µ σ2γ κ −3
bernoulli p p(1−p)1−2p√
p(1−p)1
1−p+1
p−6
binomial np np (1−p)1−2p√
np(1−p)6p2−6p+1
np(1−p)
geometric1
p1−p
p22−p√1−pp2−6p+6
1−p
poisson λ λ1√
λ1
λ
uniforma+b
2(b−a)2
120 −6
5
exponential1
λ1
λ2 2 6
gaussian µ σ20 0
table 4.1: the first few moments of commonly used random variables.
on a computer, computing the empirical skewness and kurtosis is done by built-in
commands. their implementations are based on the finite-sample calculations
γ≈1
nnx
n=1xn−µ
σ3
,
κ≈1
nnx
n=1xn−µ
σ4
.
the matlab and python built-in commands are shown below, using a gamma distribution
as an example.
% matlab code to compute skewness and kurtosis
x = random(’gamma’,3,5,[10000,1]);
s = skewness(x);
k = kurtosis(x);
# python code to compute skewness and kurtosis
import scipy.stats as stats
x = stats.gamma.rvs(3,5,size=10000)
s = stats.skew(x)
k = stats.kurtosis(x)
example 4.24 . to further illustrate the behavior of skewness and kurtosis, we consider
an example using the gamma random variable x. the pdf of xis given by the
equation
fx(x) =1
γ(k)θkxk−1e−x
θ, (4.32)
where γ( ·) is known as the gamma function. if kis an integer, the gamma function is
2184.6. gaussian random variables
just the factorial: γ( k) = (k−1)!. a gamma random variable is parametrized by two
parameters ( k, θ). as kincreases or decreases, the shape of the pdf will change. for
example, when k= 1, the distribution is simplified to an exponential distribution.
without going through the (tedious) integration, we can show that the skewness
and the (excess) kurtosis of gamma( k, θ) are
skewness =2√
k,
(excess) kurtosis =6
k.
as we can see from these results, the skewness and kurtosis diminish as kgrows. this
can be confirmed from the pdf of gamma( k, θ) as shown in figure 4.29 .
0 5 10 15 20 25 3000.10.20.30.4
k = 2
k = 5
k = 10
k = 15
k = 20
figure 4.29: the pdf of a gamma distribution gamma (k, θ), where θ= 1. the skewness and
the kurtosis are decaying to zero.
example 4.25 . let us look at a real example. on april 15, 1912, rms titanic sank
after hitting an iceberg. the disaster killed 1502 out of 2224 passengers and crew. a
hundred years later, we want to analyze the data. at https://www.kaggle.com/c/
titanic/ there is a dataset collecting the identities, age, gender, etc., of the passengers.
we partition the dataset into two: one for those who died and the other one for those
who survived. we plot the histograms of the ages of the two groups and compute
several statistics of the dataset. figure 4.30 shows the two datasets.
0 20 40 60 80
age010203040
0 20 40 60 80
age010203040
group 1 (died) group 2 (survived)
219chapter 4. continuous random variables
figure 4.30: the titanic dataset https://www.kaggle.com/c/titanic/ .
statistics group 1 (died) group 2 (survived)
mean 30.6262 28.3437
standard deviation 14.1721 14.9510
skewness 0.5835 0.1795
excess kurtosis 0.2652 −0.0772
note that the two groups of people have very similar means and standard devia-
tions. in other words, if we only compare the mean and standard deviation, it is nearly
impossible to differentiate the two groups. however, the skewness and kurtosis provide
more information related to the shape of the histograms. for example, group 1 has
more positive skewness, whereas group 2 is almost symmetrical. one interpretation is
that more young people offered lifeboats to children and older people. the kurtosis of
group 1 is slightly positive, whereas that of group 2 is slightly negative. therefore,
high-order moments can sometimes be useful for data analysis.
4.6.4 origin of gaussian random variables
the gaussian random variable has a long history. here, we provide one perspective on why
gaussian random variables are so useful. we give some intuitive arguments but leave the
formal mathematical treatment for later when we introduce the central limit theorem.
let’s begin with a numerical experiment. consider throwing a fair die. we know that
this will give us a (discrete) uniform random variable x. if we repeat the experiment many
times we can plot the histogram, and it will return us a plot of 6 impulses with equal height,
as shown in figure 4.31 (a).
now, suppose we throw two dice. call them x1andx2, and let z=x1+x2, i.e.,
the sum of two dice. we want to find the distribution of z. to do so, we first list out all
the possible outcomes in the sample space; this gives us {(1,1),(1,2), . . . , (6,6)}. we then
sum the numbers, which gives us a list of states of z:{2,3,4, . . . , 12}. the probability of
getting these states is shown in figure 4.31 (b), which has a triangular shape. the triangular
shape makes sense because to get the state “2”, we must have the pair (1 ,1), which is quite
unlikely. however, if we want to get the state 7, it would be much easier to get a pair, e.g.,
(6,1),(5,2),(4,3),(3,4),(2,5),(1,6) would all do the job.
now, what will happen if we throw 5 dice and consider z=x1+x2+···+x5? it turns
out that the distribution will continue to evolve and give something like figure 4.31 (c).
this is starting to approximate a bell shape. finally, if we throw 100 dice and consider
z=x1+x2+···+x100, the distribution will look like figure 4.31 (d). the shape is
becoming a gaussian! this numerical example demonstrates a fascinating phenomenon: as
we sum more random variables, the distribution of the sum will eventually converge to a
gaussian.
if you are curious about how we plot the above figures, the following matlab and
python code can be useful.
% matlab code to show the histogram of z = x1+x2+x3
n = 10000;
x1 = randi(6,1,n);
x2 = randi(6,1,n);
2204.6. gaussian random variables
(a)x1 (b)x1+x2 (c)x1+···+x5 (d)x1+···+x100
figure 4.31: when adding uniform random variables, the overall distribution approaches a gaussian as
the number of summed variables increase.
x3 = randi(6,1,n);
z = x1 + x2 + x3;
histogram(z, 2.5:18.5);
# python code to show the histogram of z = x1+x2+x3
import numpy as np
import matplotlib.pyplot as plt
n = 10000
x1 = np.random.randint(1,6,size=n)
x2 = np.random.randint(1,6,size=n)
x3 = np.random.randint(1,6,size=n)
z = x1 + x2 + x3
plt.hist(z,bins=np.arange(2.5,18.5))
can we provide a more formal description of this? yes, but we need some new mathe-
matical tools that we have not yet developed. so, for the time being, we will outline the flow
of the arguments and leave the technical details to a later chapter. suppose we have two
independent random variables with identical distributions, e.g., x1andx2, where both are
uniform. this gives us pdfs fx1(x) and fx2(x) that are two identical rectangular functions.
by what operation can we combine these two rectangular functions and create a triangle
function? the key lies in the concept of convolution . if you convolve two rectangle functions,
you will get a triangle function. here we define the convolution of fxas
(fx∗fx)(x) =z∞
−∞fx(τ)fx(x−τ)dτ.
in fact, for any pair of random variables x1andx2(not necessarily uniform random vari-
ables), the sum z=x1+x2will have a pdf given by the convolution of the two pdfs. we
have not yet proven this, but if you trust what we are saying, we can effectively generalize
this argument to many random variables. if we have nrandom variables, then the sum
z=x1+x2+···+xnwill have a pdf that is the result of nconvolutions of all the
individual pdfs.
what is the pdf of x+y?
summing x+yis equivalent to convolving the pdfs fx∗fy.
221chapter 4. continuous random variables
if you sum many random variables, you convolve all their pdfs.
how do we analyze these convolutions? we need a second set of tools related to fourier
transforms. the fourier transform of a pdf is known as the characteristic function , which
we will discuss later, but the name is not important now. what matters is the important
property of the fourier transform, that a convolution in the original space is multiplication
in the fourier space. that is,
f {(fx∗fx∗ ··· ∗ fx)}=f{fx} · f{ fx} · ··· · f{ fx}.
multiplication in the fourier space is much easier to analyze. in particular, for independent
and identically distributed random variables, the multiplication will easily translate to ad-
dition in the exponent. then, by truncating the exponent to the second order, we can show
that the limiting object in the fourier space is approaching a gaussian. finally, since the
inverse fourier transform of a gaussian remains a gaussian, we have shown that the infinite
convolution will give us a gaussian.
here is some numerical evidence for what we have just described. recall that the
fourier transform of a rectangle function is the sinc function. therefore, if we have an
infinite convolution of rectangular functions, equivalently, we have an infinite product of sinc
functions in the fourier space. multiplying sinc functions is reasonably easy. see figure 4.32
for the first three sincs. it is evident that with just three sinc functions, the shape closely
approximates a gaussian.
-10 -8 -6 -4 -2 0 2 4 6 8 10-0.5-0.2500.250.50.7511.25
(sin x)/x
(sin x)2/x2
(sin x)3/x3
figure 4.32: convolving the pdf of a uniform distribution is equivalent to multiplying their fourier
transforms in the fourier space. as the number of convolutions grows, the product is gradually becoming
gaussian.
how about distributions that are not rectangular? we invite you to numerically visu-
alize the effect when you convolve the function many times. you will see that as the number
of convolutions grows, the resulting function will become more and more like a gaussian.
regardless of what the input random variables are, as long as you add them, the sum will
have a distribution that looks like a gaussian:
x1+x2+···+xn⇝gaussian .
we use the notation ⇝to emphasize that the convergence is not the usual form of conver-
gence. we will make this precise later.
2224.7. functions of random variables
the implication of this line of discussion is important. regardless of the underlying
true physical process, if we are only interested in the sum (or average), the distribution
will be more or less gaussian. in most engineering problems, we are looking at the sum
or average. for example, when generating an image using an image sensor, the sensor will
add a certain amount of read noise. read noise is caused by the random fluctuation of the
electrons in the transistors due to thermal distortions. for high-photon-flux situations, we
are typically interested in the average read noise rather than the electron-level read noise.
thus gaussian random variables become a reasonable model for that. in other applications,
such as imaging through a turbulent medium, the random phase distortions (which alter
the phase of the wavefront) can also be modeled as a gaussian random variable. here is the
summary of the origin of a gaussian random variable:
what is the origin of gaussian?
when we sum many independent random variables, the resulting random vari-
able is a gaussian.
this is known as the central limit theorem . the theorem applies to anyran-
dom variable.
summing random variables is equivalent to convolving the pdfs. convolving
pdfs infinitely many times yields the bell shape.
4.7 functions of random variables
one common question we encounter in practice is the transformation of random variables.
the question can be summarized as follows: given a random variable xwith pdf fx(x)
and cdf fx(x), and supposing that y=g(x) for some function g, what are fy(y) and
fy(y)? this is a prevalent question. for example, we measure the voltage v, and we want
to analyze the power p=v2/r. this involves taking the square of a random variable.
another example: we know the distribution of the phase θ, but we want to analyze the
signal cos( ωt+ θ). this involves a cosine transformation. how do we convert one variable
to another? answering this question is the goal of this section.
4.7.1 general principle
we will first outline the general principle for tackling this type of problem. in the following
subsection, we will give a few concrete examples.
suppose we are given a random variable xwith pdf fx(x) and cdf fx(x). let y=
g(x) for some known and fixed function g. for simplicity, we assume that gis monotonically
223chapter 4. continuous random variables
increasing. in this case, the cdf of ycan be determined as follows.
fy(y)(a)=p[y≤y](b)=p[g(x)≤y]
(c)=p[x≤g−1(y)]
(d)=fx(g−1(y)).
this sequence of steps is not difficult to understand. step (a) is the definition of cdf. step
(b) substitutes g(x) for y. step (c) uses the fact that since gis invertible, we can apply
the inverse of gto both sides of g(x)≤yto yield x≤g−1(y). step (d) is the definition of
the cdf, but this time applied to p[x≤ ♣] =fx(♣), for some ♣.
it will be useful to visualize the situation in figure 4.33 . here, we consider a uniformly
distributed xso that the cdf fx(x) is a straight line. according to fx, any samples
drawn according to fxare equally likely, as illustrated by the yellow dots on the x-axis.
as we transform the x’s through y=g(x), we increase/decrease the spacing between
two samples. therefore, some samples become more concentrated while some become less
concentrated. the distribution of these transformed samples (the yellow dots on the y-axis)
forms a new cdf fy(y). the result fy(y) =fx(g−1(y)) holds when we look at y. the
samples are traveling with g−1in order to go back to fx. therefore, we need g−1in the
formula.
figure 4.33: when transforming a random variable xtoy=g(x), the distributions are defined
according to the spacing between samples. in this figure, a uniformly distributed xwill become squeezed
by some parts of gand widened in other parts of g.
why should we use the cdf and not the pdf in figure 4.33 ? the advantage of the
cdf is that it is an increasing function. therefore, no matter what the function gis, the
input and the output functions will still be increasing. if we use the pdf, then the non-
monotonic behavior of the pdf will interact with another nonlinear function g. it becomes
much harder to decouple the two.
we can carry out the integrations to determine fx(g−1(y)). it can be shown that
fx(g−1(y)) =zg−1(y)
−∞fx(x′)dx′, (4.33)
2244.7. functions of random variables
and hence, by the fundamental theorem of calculus, we have
fy(y) =d
dyfy(y) =d
dyfx(g−1(y)) =d
dyzg−1(y)
−∞fx(x′)dx′
=d g−1(y)
dy
·fx(g−1(y)), (4.34)
where the last step is due to the chain rule. based on this line of reasoning we can summarize
a “recipe” for this problem.
how to find the pdf of y=g(x)
step 1: find the cdf fy(y), which is fy(y) =fx(g−1(y)).
step 2: find the pdf fy(y), which is fy(y) =
d g−1(y)
dy
·fx(g−1(y)).
this recipe works when gis a one-to-one mapping. if gis not one-to-one, e.g., g(x) =x2
implies g−1(y) =±√y, then we will have some issues with the above two steps. when this
happens, then instead of writing x≤g−1(y) we need to determine the set {x|g(x)≤y}.
4.7.2 examples
example 4.26 . (linear transform) let xbe a random variable with pdf fx(x) and
cdf fx(x). let y= 2x+ 3. find fy(y) and fy(y). express the answers in terms of
fx(x) and fx(x).
solution . we first note that
fy(y) =p[y≤y]
=p[2x+ 3≤y]
=p
x≤y−3
2
=fxy−3
2
.
therefore, the pdf is
fy(y) =d
dyfy(y)
=d
dyfxy−3
2
=f′
xy−3
2d
dyy−3
2
=1
2fxy−3
2
.
follow-up . (linear transformation of a gaussian random variable).suppose xis a gaus-
sian random variable with zero mean and unit variance, and let y=ax+b. then the cdf
225chapter 4. continuous random variables
and pdf of yare respectively
fy(y) =fxy−b
a
= φy−b
a
,
fy(y) =1
afxy−b
a
=1√
2πae−(y−b)2
2a2.
follow-up . (linear transformation of an exponential random variable). suppose xis an
exponential random variable with parameter λ, and let y=ax+b. then the cdf and
pdf of yare respectively
fy(y) =fxy−b
a
= 1−e−λ
a(y−b), y ≥b,
fy(y) =1
afxy−b
a
=λ
ae−λ
a(y−b), y ≥b.
example 4.27 . let xbe a random variable with pdf fx(x) and cdf fx(x). sup-
posing that y=x2, find fy(y) and fy(y). express the answers in terms of fx(x)
andfx(x).
solution . we note that
fy(y) =p[y≤y] =p[x2≤y] =p[−√y≤x≤√y]
=fx(√y)−fx(−√y).
therefore, the pdf is
fy(y) =d
dyfy(y)
=d
dy(fx(√y)−fx(−√y))
=f′
x(√y)d
dy√y−f′
x(−√y)d
dy(−√y)
=1
2√y(fx(√y) +fx(−√y)).
2264.7. functions of random variables
figure 4.34: when transforming a random variable xtoy=x2, the cdf becomes fy(y) =√y−a
b−aand the pdf becomes fy(y) =1√y(b−a).
follow up . (square of a uniform random variable) suppose xis a uniform random variable
in [a, b] (assume a >0), and let y=x2. then the cdf and pdf of yare respectively
fy(y) =√y−a
b−a, a2≤y≤b2,
fy(y) =1√y(b−a), a2≤y≤b2.
example 4.28 . let x∼uniform(0 ,2π). suppose y= cos x. find fy(y) and fy(y).
solution . first, we need to find the cdf of x. this can be done by noting that
fx(x) =zx
−∞fx(x′)dx′=zx
01
2πdx′=x
2π.
thus, the cdf of yis
fy(y) =p[y≤y] =p[cosx≤y]
=p[cos−1y≤x≤2π−cos−1y]
=fx(2π−cos−1y)−fx(cos−1y)
= 1−cos−1y
π.
the pdf of yis
fy(y) =d
dyfy(y) =d
dy
1−cos−1y
π
=1
πp
1−y2,
227chapter 4. continuous random variables
where we used the fact thatd
dycos−1y=−1√
1−y2.
example 4.29 . let xbe a random variable with pdf
fx(x) =aexe−aex.
lety=ex, and find fy(y).
solution . we first note that
fy(y) =p[y≤y] =p[ex≤y]
=p[x≤logy] =zlogy
−∞aexe−aexdx.
to find the pdf, we recall the fundamental theorem of calculus. this gives us
fy(y) =d
dyzlogy
−∞aexe−aexdx
=d
dylogy 
d
dlogyzlogy
−∞aexe−aexdx!
=1
yaelogye−aelogy=ae−ay.
closing remark . the transformation of random variables is a fundamental technique in
data science. the approach we have presented is the most rudimentary yet the most intuitive.
the key is to visualize the transformation and how the random samples are allocated after
the transformation. note that the density of the random samples is related to the slope of
the cdf. therefore, if the transformation maps many samples to similar values, the slope
of the cdf will be steep. once you understand this picture, the transformation will be a
lot easier to understand.
is it possible to replace the paper-and-pencil derivation of a transformation with a
computer? if the objective is to transform random realizations, then the answer is yes
because your goal is to transform numbers to numbers, which can be done on a computer.
for example, transforming a sample x1to√x1is straightforward on a computer. however,
if the objective is to derive the theoretical expression of the pdf, then the answer is no.
why might we want to derive the theoretical pdf? we might want to analyze the mean,
variance, or other statistical properties. we may also want to reverse-engineer and determine
a transformation that can yield a specific pdf. this would require a paper-and-pencil
derivation. in what follows, we will discuss a handy application of the transformations.
what are the rules of thumb for transformation of random variables?
always find the cdf fy(y) =p[g(x)≤y]. ask yourself: what are the values
ofxsuch that g(x)≤y? think of the cosine example.
2284.8. generating random numbers
sometimes you do not need to solve for fy(y) explicitly. the fundamental the-
orem of calculus can help you find fy(y).
draw pictures. ask yourself whether you need to squeeze or stretch the samples.
4.8 generating random numbers
most scientific computing software nowadays has built-in random number generators. for
common types of random variables, e.g., gaussian or exponential, these random number
generators can easily generate numbers according to the chosen distribution. however, if we
are given an arbitrary pdf (or pmf) that is not among the list of predefined distributions,
how can we generate random numbers according to the pdf or pmf we want?
4.8.1 general principle
generating random numbers according to the desired distribution can be formulated as
an inverse problem. suppose that we can generate uniformly random numbers according
to uniform(0,1). this is a fragile assumption, and this process can be done on almost all
computers today. let us call this random variable uand its realization u. suppose that we
also have a desired distribution fx(x) (and its cdf fx(x)). we can put the two random
variables uandxon the two axes of figure 4.35 , yielding an input-output relationship.
the inverse problem is: by using what transformation g, such that x=g(u), can we make
sure that xis distributed according to fx(x) (or fx(x))?
figure 4.35: generating random numbers according to a known cdf. the idea is to first generate a
uniform(0,1) random variable, then do an inverse mapping f−1
x.
theorem 4.12. the transformation gthat can turn a uniform random variable into
229chapter 4. continuous random variables
a random variable following a distribution fx(x)is given by
g(u) =f−1
x(u). (4.35)
that is, if g=f−1
x, then g(u)will be distributed according to fx(orfx).
proof . first, we know that if u∼uniform(0 ,1), then fu(u) = 1 for 0 ≤u≤1, so
fu(u) =zu
−∞fu(u)du=u,
for 0≤u≤1. let g=f−1
xand define y=g(u). then the cdf of yis
fy(y) =p[y≤y] =p[g(u)≤y]
=p[f−1
x(u)≤y]
=p[u≤fx(y)] =fx(y).
therefore, we have shown that the cdf of yis the cdf of x. □
the theorem above states that if we want a distribution fx, then the transformation
should be g=f−1
x. this suggests a two-step process for generating random numbers.
how do we generate random numbers from an arbitrary distribution fx?
step 1: generate a random number u∼uniform(0 ,1).
step 2: let
y=f−1
x(u). (4.36)
then the distribution of yisfx.
4.8.2 examples
example 4.30 . how can we generate gaussian random numbers with mean µand
variance σ2from uniform random numbers?
first, we generate u∼uniform(0 ,1). the cdf of the ideal distribution is
fx(x) = φx−µ
σ
.
therefore, the transformation gis
g(u) =f−1
x(u) =σφ−1(u) +µ.
infigure 4.36 , we plot the cdf of fxand the transformation g.
2304.8. generating random numbers
-10 -8 -6 -4 -2 0 2 4 6 8 1000.10.20.30.40.50.60.70.80.91
0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1-3-2-1012345678910-4
(a)fx(·) (b) g(·)
figure 4.36: to generate random numbers according to gaussian (0,1), we plot its cdf in (a)
and the transformation gin (b).
to visualize the random variables before and after the transformation, we plot
the histograms in figure 4.37 .
0 0.2 0.4 0.6 0.8 10100200300400
-5 0 5 10020040060080010001200
(a) pdf of u (b) pdf of g(u)
figure 4.37: (a) pdf of the uniform random variable. (b) the pdf of the transformed random
variable.
the matlab and python codes used to generate the histograms above are shown
below.
% matlab code to generate gaussian from uniform
mu = 3;
sigma = 2;
u = rand(10000,1);
gu = sigma*icdf(’norm’,u,0,1)+mu;
figure; hist(u);
figure; hist(gu);
# python code to generate gaussian from uniform
import numpy as np
import matplotlib.pyplot as plt
import scipy.stats as stats
231chapter 4. continuous random variables
mu = 3
sigma = 2
u = stats.uniform.rvs(0,1,size=10000)
gu = sigma*stats.norm.ppf(u)+mu
plt.hist(u); plt.show()
plt.hist(gu); plt.show()
example 4.31 . how can we generate exponential random numbers with parameter λ
from uniform random numbers?
first, we generate u∼uniform(0 ,1). the cdf of the ideal distribution is
fx(x) = 1−e−λx.
therefore, the transformation gis
g(u) =f−1
x(u) =−1
λlog(1−u).
the cdf of the exponential random variable and the transformation gare shown
infigure 4.38 .
0 1 2 3 4 500.10.20.30.40.50.60.70.80.91
0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 156701234
(a)fx(·) (b) g(·)
figure 4.38: to generate random numbers according to exponential (1), we plot its cdf in (a)
and the transformation gin (b).
the pdf of the uniform random variable uand the pdf of the transformed
variable g(u) are shown in figure 4.39 .
2324.8. generating random numbers
0 0.2 0.4 0.6 0.8 10100200300400
0 2 4 6 8 10050010001500200025003000
(a) pdf of u (b) pdf of g(u)
figure 4.39: (a) pdf of the uniform random variable. (b) the pdf of the transformed random
variable.
the matlab and python codes for this transformation are shown below.
% matlab code to generate exponential random variables
lambda = 1;
u = rand(10000,1);
gu = -(1/lambda)*log(1-u);
# python code to generate exponential random variables
import numpy as np
import scipy.stats as stats
lambd = 1;
u = stats.uniform.rvs(0,1,size=10000)
gu = -(1/lambd)*np.log(1-u)
example 4.32 . how can we generate the 4 integers 1 ,2,3,4, according to the his-
togram [0 .1 0.5 0.3 0.1], from uniform random numbers?
first, we generate u∼uniform(0 ,1). the cdf of the ideal distribution is
fx(x) =

0.1, x = 1,
0.1 + 0 .5 = 0 .6, x = 2,
0.1 + 0 .5 + 0 .3 = 0 .9, x = 3,
0.1 + 0 .5 + 0 .3 + 0 .1 = 1 .0, x = 4.
this cdf is not invertible. however, we can still define the “inverse” mapping
233chapter 4. continuous random variables
as
g(u) =f−1
x(u)
=

1, 0.0≤u≤0.1,
2, 0.1< u≤0.6,
3, 0.6< u≤0.9,
4, 0.9< u≤1.0.
for example, if 0 .1< u≤0.6, then on the black curve shown in figure 4.40 (a), we
are looking at the second vertical line from the left. this will go to “2” on the x-axis.
therefore, the inversely mapped value is 2 for 0 .1< u≤0.6.
0 1 2 3 4 50.10.60.91
0 0.1 0.6 0.9 101234
(a)fx(·) (b) g(·)
figure 4.40: to generate random numbers according to a predefined histogram, we first define
the cdf in (a) and the corresponding transformation in (b).
the pdfs of the transformed variables, before and after, are shown in fig-
ure 4.41 .
0 0.2 0.4 0.6 0.8 10100200300400
0 1 2 3 4 50100020003000400050006000
(a) pdf of u (b) pdf of g(u)
figure 4.41: (a) pdf of the uniform random variable. (b) the pdf of the transformed random
variable.
in matlab, the above pdfs can be plotted using the commands below. in python,
we need to use the logical comparison np.logical_and to identify the indices. an alternative
is to use gu[((u<=0.5)*(u>=0.0)).astype(np.bool)]=1 .
2344.9. summary
% matlab code to generate the desired random variables
u = rand(10000,1);
gu = zeros(10000,1);
gu((u>=0) & (u<=0.1)) = 1;
gu((u>0.1) & (u<=0.6)) = 2;
gu((u>0.6) & (u<=0.9)) = 3;
gu((u>0.9) & (u<=1)) = 4;
# python code to generate the desired random variables
import numpy as np
import scipy.stats as stats
u = stats.uniform.rvs(0,1,size=10000)
gu = np.zeros(10000)
gu[np.logical_and(u >= 0.0, u <= 0.1)] = 1
gu[np.logical_and(u > 0.1, u <= 0.6)] = 2
gu[np.logical_and(u > 0.6, u <= 0.9)] = 3
gu[np.logical_and(u > 0.9, u <= 1)] = 4
4.9 summary
let us summarize this chapter by revisiting the four bullet points from the beginning of the
chapter.
definition of a continuous random variable . continuous random variables are mea-
sured by lengths, areas, and volumes, which are all defined by integrations. this makes
them different from discrete random variables, which are measured by counts (and
summations). because of the different measures being used to define random variables,
we consequently have different ways of defining expectation, variance, moments, etc.,
all in terms of integrations.
unification of discrete and continuous random variables . the unification is done by
the cdf. the cdf of a discrete random variable can be written as a train of step
functions. after taking the derivative, we will obtain the pdf, which is a train of
impulses.
origin of gaussian random variables . the origin of the gaussian random variable lies
in the fact that many observable events in engineering are sums of independent events.
the summation of independent random variables is equivalent to taking convolutions
of the pdfs. at the limit, they will converge to a bell-shaped function, which is the
gaussian. gaussians are everywhere because we observe sums more often than we
observe individual states.
transformation of random variables . transformation of random variables is done
in the cdf space. the transformation can be used to generate random numbers
235chapter 4. continuous random variables
according to a predefined distribution. specifically, if we want to generate random
numbers according to fx, then the transformation is g=f−1
x.
4.10 reference
pdf, cdf, expectation
4-1 dimitri p. bertsekas and john n. tsitsiklis, introduction to probability , athena sci-
entific, 2nd edition, 2008. chapter 3.1, 3.2.
4-2 alberto leon-garcia, probability, statistics, and random processes for electrical en-
gineering , prentice hall, 3rd edition, 2008. chapter 4.1 - 4.3.
4-3 athanasios papoulis and s. unnikrishna pillai, probability, random variables and
stochastic processes , mcgraw-hill, 4th edition, 2001. chapter 4.
4-4 john a. gubner, probability and random processes for electrical and computer en-
gineers , cambridge university press, 2006. chapter 4.1, 4.2, 5.1, 5.3, 5.5.
4-5 sheldon ross, a first course in probability , prentice hall, 8th edition, 2010. chapter
4.10, 5.1, 5.2, 5.3.
4-6 henry stark and john woods, probability and random processes with applications
to signal processing , prentice hall, 3rd edition, 2001. chapter 2.4, 2.5, 4.1, 4.4.
gaussian random variables
4-7 dimitri p. bertsekas and john n. tsitsiklis, introduction to probability , athena sci-
entific, 2nd edition, 2008. chapter 3.3.
4-8 alberto leon-garcia, probability, statistics, and random processes for electrical en-
gineering , prentice hall, 3rd edition, 2008. chapter 4.4.
4-9 sheldon ross, a first course in probability , prentice hall, 8th edition, 2010. chapter
5.4.
4-10 mark d. ward and ellen gundlach, introduction to probability , w.h. freeman and
company, 2016. chapter 35.
transformation of random variables
4-11 dimitri p. bertsekas and john n. tsitsiklis, introduction to probability , athena sci-
entific, 2nd edition, 2008. chapter 4.1.
4-12 alberto leon-garcia, probability, statistics, and random processes for electrical en-
gineering , prentice hall, 3rd edition, 2008. chapter 4.5.
4-13 athanasios papoulis and s. unnikrishna pillai, probability, random variables and
stochastic processes , mcgraw-hill, 4th edition, 2001. chapter 5.
4-14 john a. gubner, probability and random processes for electrical and computer en-
gineers , cambridge university press, 2006. chapter 5.4.
2364.11. problems
4-15 sheldon ross, a first course in probability , prentice hall, 8th edition, 2010. chapter
5.7.
4-16 henry stark and john woods, probability and random processes with applications
to signal processing , prentice hall, 3rd edition, 2001. chapter 3.1, 3.2.
advanced probability textbooks
4-17 william feller, an introduction to probability theory and its applications , wiley and
sons, 3rd edition, 1950.
4-18 andrey kolmogorov, foundations of the theory of probability , 2nd english edition,
dover 2018. (translated from russian to english. originally published in 1950 by
chelsea publishing company new york.)
4.11 problems
exercise 1. (video solution)
letxbe a gaussian random variable with µ= 5 and σ2= 16.
(a) find p[x > 4] and p[2≤x≤7].
(b) if p[x < a ] = 0.8869, find a.
(c) ifp[x > b ] = 0.1131, find b.
(d) if p[13< x≤c] = 0.0011, find c.
exercise 2. (video solution)
compute e[y] ande[y2] for the following random variables:
(a)y=acos(ωt+θ), where a∼ n(µ, σ2).
(b)y=acos(ωt+ θ), where θ ∼uniform(0 ,2π).
(c)y=acos(ωt+θ), where t∼uniform 
−π
ω,π
ω
.
exercise 3. (video solution)
consider a cdf
fx(x) =

0, ifx <−1,
0.5, if−1≤x <0,
(1 +x)/2,if 0≤x <1,
1, otherwise .
(a) find p[x <−1],p[−0.5< x < 0.5] and p[x > 0.5].
(b) find fx(x).
237chapter 4. continuous random variables
exercise 4. (video solution)
a random variable xhas cdf:
fx(x) =(
0, ifx <0,
1−1
4e−2x, ifx≥0.
(a) find p[x≤2],p[x= 0],p[x < 0],p[2< x < 6] and p[x > 10].
(b) find fx(x).
exercise 5. (video solution)
a random variable xhas pdf
fx(x) =(
cx(1−x2), 0≤x≤1,
0, otherwise .
find c,fx(x), and e[x].
exercise 6. (video solution)
a continuous random variable xhas a cumulative distribution
fx(x) =

0, x < 0,
0.5 +csin2(πx/2), 0≤x≤1,
1, x > 1.
(a) what values can cassume?
(b) find fx(x).
exercise 7. (video solution)
a continuous random variable xis uniformly distributed in [ −2,2].
(a) let y= sin( πx/8). find fy(y).
(b) let z=−2x2+ 3. find fz(z).
hint: compute fy(y) from fx(x), and used
dysin−1y=1√
1−y2.
exercise 8.
lety=ex.
(a) find the cdf and pdf of yin terms of the cdf and pdf of x.
(b) find the pdf of ywhen xis a gaussian random variable. in this case, yis said to
be a lognormal random variable.
exercise 9.
the random variable xhas the pdf
fx(x) =(
1
2√x, 0≤x≤1,
0, otherwise .
2384.11. problems
letybe a new random variable
y=

0, x < 0,√
x, 0≤x≤1,
1, x > 1.
find fy(y) and fy(y), for−∞< y < ∞.
exercise 10.
a random variable xhas the pdf
fx(x) =(
2xe−x2, x ≥0,
0, x < 0.
let
y=g(x) =(
1−e−x2, x ≥0,
0, x < 0.
find the pdf of y.
exercise 11.
a random variable xhas the pdf
fx(x) =1
2e−|x|,−∞< x < ∞.
lety=g(x) =e−x. find the pdf of y.
exercise 12.
a random variable xhas the pdf
fx(x) =1√
2πσ2e−x2
2σ2,−∞< x < ∞.
find the pdf of ywhere
y=g(x) =(
x, |x|> k,
−x, |x|< k.
exercise 13.
a random variable xhas the pdf
fx(x) =1
x2√
2πe−x2
2,−∞< x < ∞.
lety=g(x) =1
x. find the pdf of y.
exercise 14.
a random variable xhas the cdf
fx(x) =

0, x < 0,
xα, 0≤x≤1,
1, x > 1,
239chapter 4. continuous random variables
with α >0. find the cdf of yif
y=g(x) =−logx.
exercise 15.
energy efficiency is an important aspect of designing electrical systems. in some modern
buildings (e.g., airports), traditional escalators are being replaced by a new type of “smart”
escalator which can automatically switch between a normal operating mode and a standby
mode depending on the flow of pedestrians.
(a) the arrival of pedestrians can be modeled as a poisson random variable. let nbe the
number of arrivals, and let λbe the arrival rate (people per minute). for a period of
tminutes, show that the probability that there are narrivals is
p(n=n) =(λt)n
n!e−λt.
(b) let tbe a random variable denoting the interarrival time (i.e., the time between two
consecutive arrivals). show that
p(t > t ) =e−λt.
also, determine ft(t) and ft(t). sketch ft(t).
(hint: note that p(t > t ) =p(no arrival in tminutes).)
(c) suppose that the escalator will go into standby mode if there are no pedestrians for
t0= 30 seconds. let ybe a random variable denoting the amount of time that the
escalator is in standby mode. that is, let
y=(
0, ift≤t0,
t−t0, ift > t 0.
finde[y].
240chapter 5
joint distributions
when you go to a concert hall, sometimes you may want to see a solo violin concert, but other
times you may want to see a symphony. symphonies are appealing because many instruments
are playing together. random variables are similar. while single random variables are useful
for modeling simple events, we use multiple random variables to describe complex events.
the multiple random variables can be either independent or correlated. when many random
variables are present in the problem, we enter the subject of joint distribution .
what are joint distributions?
in the simplest sense, joint distributions are extensions of the pdfs and pmfs we studied
in the previous chapters. we summarize them as follows.
joint distributions are high-dimensional pdfs (or pmfs or cdfs).
what do we mean by a high-dimensional pdf? we know that a single random variable is
characterized by a 1-dimensional pdf fx(x). if we have a pair of random variables, then
we use a 2-dimensional function fx,y(x, y), and if we have a triplet of random variables,
we use a 3-dimensional function fx,y,z (x, y, z ). in general, the dimensionality of the pdf
grows as the number of variables:
fx(x)|{z}
one variable=⇒fx1,x2(x1, x2)|{z }
two variables=⇒ ··· =⇒fx1,...,x n(x1, . . . , x n)| {z }
nvariables.
for busy engineers like us, fx1,...,x n(x1, . . . , x n) is not a friendly notation. a more con-
cise way to write fx1,...,x n(x1, . . . , x n) is to define a vector of random variables x=
[x1, x2, . . . , x n]twith a vector of states x= [x1, x2, . . . , x n]t, and to define the pdf as
fx(x) =fx1,...,x n(x1, . . . , x n).
under what circumstance will we encounter creatures like fx(x)? believe it or not,
these high-dimensional pdfs are everywhere . in 2010, computer-vision scientists created
the imagenet dataset, containing 14 million images with ground-truth class labels. this
enormous dataset has enabled a great blossoming of machine learning over the past several
241chapter 5. joint distributions
figure 5.1: joint distributions are ubiquitous in modern data analysis. for example, an image from a
dataset can be represented by a high-dimensional vector x. each vector has a certain probability of
being present. this probability is described by the high-dimensional joint pdf fx(x). the goal of this
chapter is to understand the properties of this fx.
0
543 50.05
2 4 1 3
y2 0 1
x-10.1
0 -2 -1-2 -3-3 -4 -4 -5 -5
-5 -4 -3 -2 -1 0 1 2 3 4 5
x00.10.20.30.40.5
-5 -4 -3 -2 -1 0 1 2 3 4 5
y00.10.20.30.40.5
figure 5.2: a 2-dimensional pdf fx,y(x, y)of a pair of random variables (x, y)and their respective
1d pdfs fx(x)andfy(y).
decades, in which many advances in deep learning have been made. fundamentally, the
imagenet dataset provides a large collection of samples drawn from a latent distribution
that is high-dimensional. each sample in the imagenet dataset is a 224 ×224×3 image (the
three numbers stand for the image’s height, width, and color). if we convert this image into
a vector, then the sample will have a dimension of 224 ×224×3 = 150,528. in other words,
the sample is a vector x∈r150528 ×1. the probability of obtaining a particular sample x
is determined by probability density function fx(x). for example, it is more likely to get
an image containing trees than one containing a ferrari. the manifold generated by fx(x)
can be extremely complex, as illustrated in figure 5.1 .
the story of imagenet is just one of the many instances for which we use a joint
distribution fx(x). joint distributions are ubiquitous. if you do data science, you must
understand joint distributions. however, extending a 1-dimensional function fx(x) to a
2-dimensional function fx,y(x, y) and then to a n-dimensional function fx(x) is not trivial.
the goal of this chapter is to guide you through these important steps.
plan of part 1 of this chapter: two variables
this chapter is broadly divided into two halves. in the first half, we will look at a pair of
random variables .
definition of fx,y(x, y). the first thing we need to learn is the definition of a joint
distribution with two variables. since we have two variables, the joint probability
density function (or probability mass function) is a 2-dimensional function. a point
242on this 2d function is the probability density evaluated by a pair of variables x=x
andy=y, as illustrated in figure 5.2 . however, how do we formally define this 2d
function? how is it related to the probability measure? is there a way we can retrieve
fx(x) and fy(y) from fx,y(x, y), as illustrated on the right-hand sides of figure 5.2 ?
these questions will be answered in section 5.1.
joint expectation e[xy]. when we have a pair of random variables, how should we
define the expectation? in section 5.2, we will show that the most natural way to define
the joint expectation is in terms of e[xy], i.e., the expectation of the product. there
is a surprising and beautiful connection between this “expectation of the product” and
the cosine angle between two vectors, thereby showing that e[xy] is the correlation
between xandy.
the reason for studying a pair of random variables is to spell out the cause-effect
relationship between the variables. this cannot be done without conditional distri-
butions; this will be explained in section 5.3. conditional distributions provide an
extremely important computational tool for decoupling complex events into simpler
events. such decomposition allows us to solve difficult joint expectation problems via
simple conditional expectations ; this subject will be covered in section 5.4.
if you recall our discussions about the origin of a gaussian random variable, we claimed
that the pdf of x+yis the convolution between fxandfy. why is this so? we
will answer this question in terms of joint distributions in section 5.5.
plan of part 2 of this chapter: nvariables
the second half of the chapter focuses on the general case of nrandom variables. this
requires the definitions of a random vector x= [x1, . . . , x n]t, a joint distribution fx(x),
and the corresponding expectations e[x]. to make our discussions concrete, we will focus
on the case of high-dimensional gaussian random variables and discuss the following topics.
covariance matrices/correlation matrices . if a pair of random variables can define
the correlation through the expectation of the product e[x1x2], then for a vector of
random variables we can consider a matrix of correlations in the form
r=
e[x1x1]e[x1x2]···e[x1xn]
e[x2x1]e[x2x2]···e[x2xn]
............
e[xnx1]e[xnx2]···e[xnxn]
.
what are the properties of the matrix? how does it affect the shape of the high-
dimensional gaussian? if we have a dataset of vectors, how do we estimate this matrix
from the data? we will answer these questions in section 5.6 and section 5.7.
principal-component analysis . given the covariance matrix, we can perform some
very useful data analyses, such as the principal-component analysis in section 5.8.
the question we will ask is: among the many components, which one is the principal
component? if we can find the principal component(s), we can effectively perform
dimensionality reduction by projecting a high-dimensional vector into low-dimensional
representations. we will introduce an application for face detection.
243chapter 5. joint distributions
figure 5.3: when there is a pair of random variables, we can regard the sample space as a set of
coordinates. the random variables are 2d mappings from a coordinate ωinωx×ωyto another
coordinate x(ω)inr2.
5.1 joint pmf and joint pdf
probability is a measure of the size of a set. this principle applies to discrete random vari-
ables, continuous random variables, single random variables, and multiple random variables.
in situations with a pair of random variables, the measure should be applied to the coordi-
nate ( x, y) represented by the random variables xandy. consequently, when measuring
the probability, we either count these coordinates or integrate the area covered by these
coordinates. in this section, we formalize this notion of measuring 2d events.
5.1.1 probability measure in 2d
consider two random variables xandy. let the sample space of xandybe ω xand
ωy, respectively. define the cartesian product of ω xand ω yas ω x×ωy={(x, y)|x∈
ωxandy∈ωy}. that is, ω x×ωycontains all possible pairs ( x, y).
example 5.1 . if ω x={1,2}and ω y={4,5}, then ω x×ωy={(1,4),(1,5),
(2,4),(2,5)}.
2445.1. joint pmf and joint pdf
example 5.2 . if ω x= [3,4] and ω y= [1,2], then ω x×ωy= a rectangle with two
diagonal vertices as (3 ,1) and (4 ,2).
random variables are mappings from the sample space to the real line. if ω∈ωxis
mapped to x(ω)∈r, and ξ∈ωyis mapped to y(ξ)∈r, then a coordinate ω= (ω, ξ) in
the sample space ω x×ωyshould be mapped to a coordinate ( x(ω), y(ξ)) in the 2d plane.
ωdef=ω
ξ
7−→x(ω)
y(ξ)
def=x(ω).
we denote such a vector-to-vector mapping as x(·) : ω x×ωy→r×r, as illustrated in
figure 5.3 .
therefore, if we have an event a ∈r2, the probability that ahappens is
p[a] =p[{ω|x(ω)∈ a} ]
=pω
ξx(ω)
y(ξ)
∈ a
=pω
ξ
∈x−1(a)
=p[ω∈x−1(a)].
in other words, we take the coordinate x(ω) and find its inverse image x−1(a). the size
of this inverse image x−1(a) in the sample space ω x×ωyis then the probability. we
summarize this general principle as follows.
how to measure probability in 2d
for a pair of random variables x= (x, y), the probability of an event ais measured
in the product space ω x×ωywith the size
p[{ω|x−1(a)}].
this definition is quite abstract. to make it more concrete, we will look at discrete and
continuous random variables.
5.1.2 discrete random variables
suppose that the random variables xandyare discrete. let a={x(ω) =x, y(ξ) =y}
be a discrete event. then the above definition tells us that the probability of ais
p[a] =p
(ω, ξ)x(ω) =x,andy(ξ) =y
=p[x=xandy=y]| {z }
def=px,y(x,y).
we define this probability as the joint probability mass function (joint pmf) px,y(x, y).
245chapter 5. joint distributions
definition 5.1. letxandybe two discrete random variables. the joint pmf ofx
andyis defined as
px,y(x, y) =p[x=xandy=y] =p
(ω, ξ)x(ω) =x,andy(ξ) =y
.(5.1)
we sometimes write the joint pmf as px,y(x, y) =p[x=x, y =y].
figure 5.4: a joint pmf for a pair of discrete random variables consists of an array of impulses. to
measure the size of the event a, we sum all the impulses inside a.
figure 5.4 shows a graphical portrayal of the joint pmf. in a nutshell, px,y(x, y)
can be considered as a 2d extension of a single variable pmf. the probabilities are still
represented by the impulses, but the domain of these impulses is now a 2d plane. if we have
an event a, then the size of the event is
p[a] =x
(x,y)∈apx,y(x, y).
example 5.3 . let xbe a coin flip, ybe a die. the sample space of xis{0,1},
whereas the sample space of yis{1,2,3,4,5,6}. the joint pmf, according to our
definition, is the probability p[x=xandy=y], where xtakes a binary state and y
takes one of the 6 states. the following table summarizes all the 12 states of the joint
distribution.
y
1 2 3 4 5 6
x = 01
121
121
121
121
121
12
x = 11
121
121
121
121
121
12
in this table, since there are 12 coordinates, and each coordinate has an equal
chance of appearing, the probability for each coordinate becomes 1 /12. therefore, the
joint pmf of xandyis
px,y(x, y) =1
12, x = 0,1, y = 1,2,3,4,5,6.
2465.1. joint pmf and joint pdf
in this example, we observe that if xandyare not interacting with each other (for-
mally, independent ), the joint pmf is the product of the two individual probabilities.
example 5.4 . in the previous example, if we define a={x+y= 3}, the probability
p[a] is
p[a] =x
(x,y)∈apx,y(x, y) =px,y(0,3) +px,y(1,2)
=2
12.
ifb={min(x, y) = 1}, the probability p[b] is
p[b] =x
(x,y)∈bpx,y(x, y)
=px,y(1,1) +px,y(1,2) +px,y(1,3)
+px,y(1,4) +px,y(1,5) +px,y(1,6)
=6
12.
5.1.3 continuous random variables
the continuous version of the joint pmf is called the joint probability density function
(joint pdf ), denoted by fx,y(x, y). a joint pdf is analogous to a joint pmf. for example,
integrating it will give us the probability.
definition 5.2. letxandybe two continuous random variables. the joint pdf of
xandyis a function fx,y(x, y)that can be integrated to yield a probability
p[a] =z
afx,y(x, y)dx dy, (5.2)
for any event a ⊆ωx×ωy.
pictorially, we can view fx,yas a 2d function where the height at a coordinate ( x, y) is
fx,y(x, y), as can be seen from figure 5.5 . to compute the probability that ( x, y)∈ a,
we integrate the function fx,ywith respect to the area covered by the set a. for example,
if the set ais a rectangular box a= [a, b]×[c, d], then the integration becomes
p[a] =p[a≤x≤b, c≤y≤d]
=zd
czb
afx,y(x, y)dx dy.
247chapter 5. joint distributions
figure 5.5: a joint pdf for a pair of continuous random variables is a surface in the 2d plane. to
measure the size of the event a, we integrate fx,y(x, y)inside a.
example 5.5 . consider a uniform joint pdf fx,y(x, y) defined on [0 ,2]2withfx,y(x, y) =
1
4. leta= [a, b]×[c, d]. find p[a].
solution .
p[a] =p[a≤x≤b, c≤x≤d]
=zd
czb
afx,y(x, y)dx dy =zd
czb
a1
4dx dy =(d−c)(b−a)
4.
practice exercise 5.1 . in the previous example, let b={x+y≤2}. find p[b].
solution .
p[b] =z
bfx,y(x, y)dx dy =z2
0z2−y
0fx,y(x, y)dx dy
=z2
0z2−y
01
4dx dy =z2
02−y
4dy=1
2.
here, the limits of the integration can be determined from figure 5.6 . the inner
integration (with respect to x) should start from 0 and end at 2 −y, which is the line
defining the set x+y≤2. since the inner integration is performed for every y, we
need to enumerate all the possible y’s to complete the outer integration. this leads to
the outer limit from 0 to 2.
5.1.4 normalization
the normalization property of a two-dimensional pmf and pdf is the property that, when
we enumerate all outcomes of the sample space, we obtain 1.
2485.1. joint pmf and joint pdf
figure 5.6: to calculate p[x+y≤2], we perform a 2d integration over a triangle.
theorem 5.1. letω = ω x×ωy. all joint pmfs and joint pdfs satisfy
x
(x,y)∈ωpx,y(x, y) = 1 orz
ωfx,y(x, y)dx dy = 1. (5.3)
example 5.6 . consider a joint uniform pdf defined in the shaded area [0 ,3]×[0,3]
with pdf defined below. find the constant c.
fx,y(x, y) =(
c if (x, y)∈[0,3]×[0,3],
0 otherwise .
solution . to find the constant c, we note that
1 =z3
0z3
0fx,y(x, y)dx dy =z3
0z3
0c dx dy = 9c.
equating the two sides gives us c=1
9.
practice exercise 5.2 . consider a joint pdf
fx,y(x, y) =(
ce−xe−y0≤y≤x <∞,
0 otherwise .
find the constant c. tip: consider the area of integration as shown in figure 5.7 .
solution . there are two ways to take the integration shown in figure 5.7 . we choose
the inner integration w.r.t. yfirst.
z
ωfx,y(x, y)dx dy =z∞
0zx
0ce−xe−ydy dx =z∞
0ce−x(1−e−x) =c
2.
therefore, c= 2.
249chapter 5. joint distributions
figure 5.7: to integrate the probability p[0≤y≤x], we perform a 2d integration over a triangle.
the two subfigures show the two ways of integrating the triangle. [left]r
dxfirst, and thenr
dy.
[right]r
dyfirst, and thenr
dx.
5.1.5 marginal pmf and marginal pdf
if we only sum / integrate for one random variable, we obtain the pmf / pdf of the other
random variable. the resulting pmf / pdf is called the marginal pmf / pdf.
definition 5.3. themarginal pmf is defined as
px(x) =x
y∈ωypx,y(x, y)and py(y) =x
x∈ωxpx,y(x, y), (5.4)
and the marginal pdf is defined as
fx(x) =z
ωyfx,y(x, y)dyand fy(y) =z
ωxfx,y(x, y)dx. (5.5)
since fx,y(x, y) is a two-dimensional function, when integrating over yfrom−∞to∞, we
project fx,y(x, y) onto the x-axis. therefore, the resulting function depends on xonly.
example 5.7 . consider the joint pdf fx,y(x, y) =1
4shown below. find the marginal
pdfs.
2505.1. joint pmf and joint pdf
solution . if we integrate over xandy, we have
fx(x) =

3, if 1< x≤2,
1, if 2< x≤3,
0, otherwise .and fy(y) =

1, if 1< x≤2,
2, if 2< x≤3,
1, if 3< x≤4,
0, otherwise .
so the marginal pdfs are the projection of the joint pdfs onto the x- and y-axes.
practice exercise 5.3 . a joint gaussian random variable ( x, y) has a joint pdf
given by
fx,y(x, y) =1
2πσ2exp
−((x−µx)2+ (y−µy)2)
2σ2
.
find the marginal pdfs fx(x) and fy(y).
solution .
fx(x) =z∞
−∞fx,y(x, y)dy
=z∞
−∞1
2πσ2exp
−((x−µx)2+ (y−µy)2)
2σ2
dy
=1√
2πσ2exp
−(x−µx)2
2σ2
·z∞
−∞1√
2πσ2exp
−(y−µy)2
2σ2
dy.
recognizing that the last integral is equal to unity because it integrates a gaussian
pdf over the real line, it follows that
fx(x) =1√
2πσ2exp
−(x−µx)2
2σ2
.
similarly, we have
fy(y) =1√
2πσ2exp
−(y−µy)2
2σ2
.
5.1.6 independent random variables
two random variables are said to be independent if and only if the joint pmf or pdf can
be factorized as a product of the marginal pmf / pdfs.
definition 5.4. random variables xandyareindependent if and only if
px,y(x, y) =px(x)py(y),orfx,y(x, y) =fx(x)fy(y).
this definition is consistent with the definition of independence of two events. recall that
two events aandbare independent if and only if p[a∩b] =p[a]p[b]. letting a={x=x}
251chapter 5. joint distributions
andb={y=y}, we see that if aandbare independent then p[x=x∩y=y] is the
product p[x=x]p[y=y]. this is precisely the relationship px,y(x, y) =px(x)py(y).
example 5.8 . consider two random variables with a joint pdf given by
fx,y(x, y) =1
2πσ2exp
−(x−µx)2+ (y−µy)2
2σ2
.
arexandyindependent?
solution . we know that
fx,y(x, y) =1√
2πσexp
−(x−µx)2
2σ2
| {z }
fx(x)×1√
2πσexp
−(y−µy)2
2σ2
| {z }
fy(y).
therefore, the random variables xandyare independent.
practice exercise 5.4 . let xbe a coin and ybe a die. then the joint pmf is given
by the table below.
y
1 2 3 4 5 6
x = 01
121
121
121
121
121
12
x = 11
121
121
121
121
121
12
arexandyindependent?
solution . for any xandy, we have that
px,y(x, y) =1
12=1
2|{z}
px(x)×1
6|{z}
py(y).
therefore, the random variables xandyare independent.
example 5.9 . consider two random variables xandywith a joint pdf given bya
fx,y(x, y)∝exp
−(x−y)2	
= exp
−x2+ 2xy−y2	
= exp
−x2	
|{z}
fx(x)exp{2xy}|{z}
extra termexp
−y2	
|{z}
fy(y).
this pdf cannot be factorized into a product of two marginal pdfs. therefore, the
random variables are dependent.
awe use the notation “ ∝” to denote “proportional to”. it implies that the normalization constant
is omitted.
2525.1. joint pmf and joint pdf
we can extrapolate the definition of independence to multiple random variables. if
there are many random variables x1, x2, . . . , x n, they will have a joint pdf
fx1,...,x n(x1, . . . , x n).
if these random variables x1, x2, . . . , x nare independent, then the joint pdf can be
factorized as
fx1,...,x n(x1, . . . , x n) =fx1(x1)·fx2(x2)···fxn(xn)
=ny
n=1fxn(xn).
this gives us the definition of independence for nrandom variables.
definition 5.5. a sequence of random variables x1, . . . , x nisindependent if and
only if their joint pdf (or joint pmf) can be factorized.
fx1,...,x n(x1, . . . , x n) =ny
n=1fxn(xn). (5.6)
example 5.10 . throw a die 4 times. let x1,x2,x3andx4be the outcomes. then,
since these four throws are independent, the probability mass function of any quadrable
(x1, x2, x3, x4) is
px1,x2,x3,x4(x1, x2, x3, x4) =px1(x1)px2(x2)px3(x3)px4(x4).
for example, the probability of getting (1 ,5,2,6) is
px1,x2,x3,x4(1,5,2,6) = px1(1)px2(5)px3(2)px4(6) =1
64
.
the example above demonstrates an interesting phenomenon. if the nrandom vari-
ables are independent, and if they all have the same distribution, then the joint pdf/pmf
is just one of the individual pdfs taken to the power n. random variables satisfying this
property are known as independent and identically distributed random variables.
definition 5.6 (independent and identically distributed (i.i.d.) ).a collection of
random variables x1, . . . , x nis called independent and identically distributed (i.i.d.)
if
allx1, . . . , x nare independent; and
allx1, . . . , x nhave the same distribution, i.e., fx1(x) =···=fxn(x).
ifx1, . . . , x nare i.i.d., we have that
fx1,...,x n(x1, . . . , x 1) =ny
n=1fx1(xn),
253chapter 5. joint distributions
where the particular choice of x1is unimportant because fx1(x) =···=fxn(x).
why is i.i.d. so important?
if a set of random variables are i.i.d., then the joint pdf can be written as a
product of pdfs.
integrating a joint pdf is difficult. integrating a product of pdfs is much easier.
example 5.11 . let x1, x2, . . . , x nbe a sequence of i.i.d. gaussian random variables
where each xihas a pdf
fxi(x) =1√
2πexp
−x2
2
.
the joint pdf of x1, x2, . . . , x nis
fx1,...,x n(x1, . . . , x n) =ny
i=11√
2πexp
−x2
i
2
=1√
2πn
exp(
−nx
i=1x2
i
2)
,
which is a function depending not on the individual values of x1, x2, . . . , x nbut on the
sumpn
i=1x2
i. so we have “compressed” an n-dimensional function into a 1d function.
example 5.12 . let θbe a deterministic number that was sent through a noisy channel.
we model the noise as an additive gaussian random variable with mean 0 and variance
σ2. supposing we have observed measurements xi=θ+wi, for i= 1, . . . , n , where
wi∼gaussian(0 , σ2), then the pdf of each xiis
fxi(x) =1√
2πσ2exp
−(x−θ)2
2σ2
.
thus the joint pdf of ( x1, x2, . . . , x n) is
fx1,...,x n(x1, . . . , x n) =ny
i=11√
2πσ2exp
−(xi−θ)2
2σ2
=1√
2πσ2n
exp(
−nx
i=1(xi−θ)2
2σ2)
.
essentially, this joint pdf tells us the probability density of seeing sample data
x1, . . . , x n.
2545.1. joint pmf and joint pdf
5.1.7 joint cdf
we now introduce the cumulative distribution function (cdf) for multiple variables.
definition 5.7. letxandybe two random variables. the joint cdf ofxandy
is the function fx,y(x, y)such that
fx,y(x, y) =p[x≤x∩y≤y]. (5.7)
this definition can be more explicitly written as follows.
definition 5.8. ifxandyare discrete, then
fx,y(x, y) =x
y′≤yx
x′≤xpx,y(x′, y′). (5.8)
ifxandyare continuous, then
fx,y(x, y) =zy
−∞zx
−∞fx,y(x′, y′)dx′dy′. (5.9)
if the two random variables are independent , then we have
fx,y(x, y) =zx
−∞fx(x′)dx′zy
−∞fy(y′)dy′=fx(x)fy(y).
example 5.13 . let xandybe two independent uniform random variables
uniform(0 ,1). find the joint cdf.
solution .
fx,y(x, y) =fx(x)fy(y) =zx
0fx(x′)dx′zy
0fy(y′)dy′
=zx
01dx′zy
01dy′=xy.
practice exercise 5.5 . let xandybe two independent uniform random variables
gaussian( µ, σ2). find the joint cdf.
solution . let φ( ·) be the cdf of the standard gaussian.
fx,y(x, y) =fx(x)fy(y)
=zx
−∞fx(x′)dx′zy
−∞fy(y′)dy′= φx−µ
σ
φy−µ
σ
.
255chapter 5. joint distributions
here are a few properties of the cdf:
fx,y(x,−∞) =z−∞
−∞zx
−∞fx,y(x′, y′)dx′dy′=zx
−∞0dx′= 0,
fx,y(−∞, y) =zy
−∞z−∞
−∞fx,y(x′, y′)dx′dy′=zy
−∞0dy′= 0,
fx,y(−∞,−∞) =z−∞
−∞z−∞
−∞fx,y(x′, y′)dx′dy′= 0,
fx,y(∞,∞) =z∞
−∞z∞
−∞fx,y(x′, y′)dx′dy′= 1.
in addition, we can obtain the marginal cdf as follows.
proposition 5.1. letxandybe two random variables. the marginal cdf is
fx(x) =fx,y(x,∞), (5.10)
fy(y) =fx,y(∞, y). (5.11)
proof . we prove only the first case. the second case is similar.
fx,y(x,∞) =zx
−∞z∞
−∞fx,y(x′, y′)dy′dx′=zy
−∞fx(x′)dx′=fx(x).□
by the fundamental theorem of calculus, we can derive the pdf from the cdf.
definition 5.9. letfx,y(x, y)be the joint cdf of xandy. then, the joint pdf
is
fx,y(x, y) =∂2
∂y ∂xfx,y(x, y). (5.12)
the order of the partial derivatives can be switched, yielding a symmetric result:
fx,y(x, y) =∂2
∂x ∂yfx,y(x, y).
example 5.14 . let xandybe two uniform random variables with joint cdf
fx,y(x, y) =xyfor 0≤x≤1 and 0 ≤y≤1. find the joint pdf.
solution .
fx,y(x, y) =∂2
∂x∂yfx,y(x, y) =∂2
∂x∂yxy= 1,
which is consistent with the definition of a joint uniform random variable.
2565.2. joint expectation
practice exercise 5.6 . let xandybe two exponential random variables with joint
cdf
fx,y(x, y) = (1 −e−λx)(1−e−λy), x ≥0, y≥0.
find the joint pdf.
solution .
fx,y(x, y) =∂2
∂x∂yfx,y(x, y) =∂2
∂x∂y(1−e−λx)(1−e−λy)
=∂
∂x 
(1−e−λx)(λe−λy)
=λe−λxλe−λy.
which is consistent with the definition of a joint exponential random variable.
5.2 joint expectation
5.2.1 definition and interpretation
when we have a single random variable, the expectation is defined as
e[x] =z
ωxfx(x)dx.
for a pair of random variables, what would be a good way of defining the expectation?
certainly, we cannot just replace fx(x) by fx,y(x, y) because the integration has to be-
come a double integration. however, if it is a double integration, where should we put the
variable y? it turns out that a useful way of defining the expectation for xandyis as
follows.
definition 5.10. letxandybe two random variables. the joint expectation is
e[xy] =x
y∈ωyx
x∈ωxxy·px,y(x, y) (5.13)
ifxandyare discrete, or
e[xy] =z
y∈ωyz
x∈ωxxy·fx,y(x, y)dx dy (5.14)
ifxandyare continuous. joint expectation is also called correlation .
the double summation and integration on the right-hand side of the equation is nothing
but the state times the probability. here, the state is the product xy, and the probability is
the joint pmf px,y(x, y) (or pdf). therefore, as long as you agree that joint expectation
should be defined as e[xy], the double summation and the double integration make sense.
257chapter 5. joint distributions
the biggest mystery here is e[xy]. you may wonder why the joint expectation should
be defined as the expectation of the product e[xy]. why not the sum e[x+y], or the
difference e[x−y], or the quotient e[x/y ]? why are we so deeply interested in xtimes y?
these are excellent questions. that the joint expectation is defined as the product has to do
with the correlation between two random variables. we will take a small detour into linear
algebra.
let us consider two discrete random variables xandy, both with nstates. so x
will take the states {x1, x2, . . . , x n}andywill take the states {y1, y2, . . . , y n}. let’s define
them as two vectors: xdef= [x1, . . . , x n]tandydef= [y1, . . . , y n]t. since xandyare random
variables, they have a joint pmf px,y(x, y). the array of the pmf values can be written
as a matrix:
pmf as a matrix = pdef=
px,y(x1, y1)px,y(x1, y2)··· px,y(x1, yn)
px,y(x2, y1)px,y(x2, y2)··· px,y(x2, yn)
............
px,y(xn, y1)px,y(xn, y2)···px,y(xn, yn)
.
let’s try to write the joint expectation in terms of matrices and vectors. the definition
of a joint expectation tells us that
e[xy] =nx
i=1nx
j=1xiyj·px,y(xi, yj),
which can be written as
e[xy] =x1···xn
|{z }
xt
px,y(x1, y1)··· px,y(x1, yn)
.........
px,y(xn, y1)···px,y(xn, yn)

| {z }
p
y1
...
yn

|{z}
y=xtpy.
this is a weighted inner product between xandyusing the weight matrix p.
why correlation is defined as e[xy]
e[xy] is a weighted inner product between the states:
e[xy] =xtpy.
xandyare the states of the random variables xandy.
the inner product measures the similarity between two vectors.
example 5.15 . let xbe a discrete random variable with nstates, where each state
has an equal probability. thus, px(x) = 1 /nfor all x. let y=xbe another variable.
2585.2. joint expectation
then the joint pmf of ( x, y) is
px,y(x, y) =(
1
n, x =y,
0, x ̸=y.
it follows that the joint expectation is
e[xy] =nx
i=1nx
j=1xiyj·px,y(xi, yj) =1
nnx
i=1xiyi.
equivalently, we can obtain the result via the inner product by defining
p=
1
n0··· 0
01
n··· 0
............
0··· ···1
n
=1
ni.
in this case, the weighted inner product is
xtpy=xty
n=1
nnx
i=1xiyi=e[xy].
how do we understand the inner product? ignoring the matrix pfor a moment, we
recall an elementary result in linear algebra.
definition 5.11. letx∈rnandy∈rnbe two vectors. define the cosine angle
cosθas
cosθ=xty
∥x∥∥y∥, (5.15)
where ∥x∥=qpn
i=1x2
iis the norm of the vector x, and ∥y∥=qpn
i=1y2
iis the
norm of the vector y.
this definition can be understood as the geometry between two vectors, as illustrated in
figure 5.8 . if the two vectors xandyare parallel so that x=αyfor some α, then the
angle θ= 0. if xandyare orthogonal so that xty= 0, then θ=π/2. therefore, the inner
product xtytells us the degree of correlation between the vectors xandy.
now let’s come back to our discussion about the joint expectation. the cosine angle
definition tells us that if e[xy] =xtpy, the following form would make sense:
cosθ=xtpy
∥x∥∥y∥=e[xy]
∥x∥∥y∥.
that is, as long as we can find out the norms ∥x∥and∥y∥, we will be able to interpret
e[xy] from the cosine angle perspective. but what would be a reasonable definition of ∥x∥
259chapter 5. joint distributions
figure 5.8: the geometry of joint expectation. e[xy]gives us the cosine angle between the two random
variables. this, in turn, tells us the correlation between the two random variables.
and∥y∥? we define the norm by first considering the variance of the random variable x
andy:
e[x2] =nx
i=1xixi·px(xi)
=
x1···xn
|{z }
xt
px(x1)··· 0
.........
0 ···px(xn)

| {z }
px
x1
...
xn

|{z}
x
=xtpxx=∥x∥2
px,
where pxis the diagonal matrix storing the probability masses of the random variable x.
it is not difficult to show that px= diag( p1) by following the definition of the marginal
distributions (which are the column and row sums of the joint pmf). similarly we can define
e[y2] =nx
j=1yjyj·py(yj)
=
y1···yn
|{z }
yt
py(y1)··· 0
.........
0 ···py(yn)

| {z }
py
y1
...
yn

|{z}
y
=ytpyy=∥y∥2
py.
therefore, one way to define the cosine angle is to start with
cosθ=xtpxyy
∥x∥px∥y∥py,
where pxy=p,∥x∥px=p
xtpxxand∥y∥py=p
ytpyy. but writing it in terms of
the expectation, we observe that this cosine angle is exactly
cosθ=xtpxyy
∥x∥px∥y∥py=e[xy]p
e[x2]p
e[y2].
2605.2. joint expectation
therefore, e[xy] defines the cosine angle between the two random variables, which, in turn,
defines the correlation between the two. a large |e[xy]|means that xandyare highly
correlated, and a small |e[xy]|means that xandyare not very correlated. if e[xy] = 0,
then the two random variables are uncorrelated. therefore, e[xy] tells us how the two
random variables are related to each other.
to further convince you thate[xy]√
e[x2]√
e[y2]can be interpreted as a cosine angle, we
show that
−1≤e[xy]p
e[x2]p
e[y2]≤1,
because if this ratio can go beyond +1 and −1, it makes no sense to call it a cosine angle.
the argument follows from a very well-known inequality in probability, called the cauchy-
schwarz inequality (for expectation), which states that −1≤e[xy]√
e[x2]√
e[y2]≤1:
theorem 5.2 (cauchy-schwarz inequality ).for any random variables xandy,
(e[xy])2≤e[x2]e[y2]. (5.16)
the following proof can be skipped if you are reading the book the first time.
proof . let t∈rbe a constant. consider e[(x+ty)2] =e[x2+ 2txy +t2y2]. since
e[(x+ty)2]≥0 for any t, it follows that
e[x2+ 2txy +t2y2]≥0.
expanding the left-hand side yields t2e[y2] + 2te[xy] +e[x2]≥0. this is a quadratic
equation in t, and we know that for any quadratic equation at2+bt+c≥0 we must have
b2−4ac≤0. therefore, in our case, we have that
(2e[xy])2−4e[y2]e[x2]≤0,
which means ( e[xy])2≤e[x2]e[y2]. the equality holds when e[(x+ty)2] = 0. in this
case, x=−tyfor some t, i.e., the random variable xis a scaled version of yso that the
vector formed by the states of xis parallel to that of y.
□
end of the proof.
5.2.2 covariance and correlation coefficient
in many practical problems, we prefer to work with central moments, i.e., e[(x−µx)2] in-
stead of e[x2]. this essentially means that we subtract the mean from the random variable.
if we adopt such a centralized random variable, we can define the covariance as follows.
261chapter 5. joint distributions
definition 5.12. letxandybe two random variables. then the covariance ofx
andyis
cov(x, y) =e[(x−µx)(y−µy)], (5.17)
where µx=e[x]andµy=e[y].
it is easy to show that if x=y, then the covariance simplifies to the variance:
cov(x, x ) =e[(x−µx)(x−µx)]
= var[ x].
thus, covariance is a generalization of variance. the former can handle a pair of variables,
whereas the latter is only for a single variable. we can also demonstrate the following result.
theorem 5.3. letxandybe two random variables. then
cov(x, y) =e[xy]−e[x]e[y] (5.18)
proof . just apply the definition of covariance:
cov(x, y) =e[(x−µx)(y−µy)]
=e[xy−xµy−y µx+µxµy]
=e[xy]−µxµy.
□
the next theorem concerns the sum of two random variables.
theorem 5.4. for any xandy,
a.e[x+y] =e[x] +e[y].
b.var[x+y] = var[ x] + 2cov( x, y) + var[ y].
proof . recall the definition of joint expectation:
e[x+y] =x
yx
x(x+y)px,y(x, y)
=x
yx
xxpx,y(x, y) +x
yx
xypx,y(x, y)
=x
xx x
ypx,y(x, y)!
+x
yy x
xpx,y(x, y)!
=x
xxpx(x) +x
yypy(y)
=e[x] +e[y].
2625.2. joint expectation
similarly,
var[x+y] =e[(x+y)2]−e[x+y]2
=e[(x+y)2]−(µx+µy)2
=e[x2+ 2xy+y2]−(µ2
x+ 2µxµy+µ2
y)
=e[x2]−µ2
x+e[y2]−µ2
y+ 2(e[xy]−µxµy)
= var[ x] + 2cov( x, y) + var[ y].
□
with covariance defined, we can now define the correlation coefficient ρ, which is the
cosine angle of the centralized variables. that is,
ρ= cos θ
=e[(x−µx)(y−µy)]p
e[(x−µx)2]e[(y−µy)2].
recognizing that the denominator of this expression is just the variance of xandy, we
define the correlation coefficient as follows.
definition 5.13. letxandybe two random variables. the correlation coefficient
is
ρ=cov(x, y)p
var[x]var[y]. (5.19)
since −1≤cosθ≤1,ρis also between −1 and 1. the difference between ρande[xy]
is that ρisnormalized with respect to the variance of xandy, whereas e[xy] is not
normalized. the correlation coefficient has the following properties:
ρis always between −1 and 1, i.e., −1≤ρ≤1. this is due to the cosine angle
definition.
when x=y(fully correlated), ρ= +1.
when x=−y(negatively correlated), ρ=−1.
when xandyare uncorrelated, ρ= 0.
5.2.3 independence and correlation
if two random variables xandyare independent, the joint expectation can be written as
a product of two individual expectations.
theorem 5.5. ifxandyare independent, then
e[xy] =e[x]e[y]. (5.20)
263chapter 5. joint distributions
proof . we only prove the discrete case because the continuous can be proved similarly. if
xandyare independent, we have px,y(x, y) =px(x)py(y). therefore,
e[xy] =x
yx
xxypx,y(x, y) =x
yx
xxypx(x)py(y)
= x
xxpx(x)! x
yypy(y)!
=e[x]e[y].
□
in general, for any two independent random variables and two functions fandg,
e[f(x)g(y)] =e[f(x)]e[g(y)].
the following theorem illustrates a few important relationships between independence
and correlation.
theorem 5.6. consider the following two statements:
a.xandyare independent;
b.cov(x, y) = 0 .
statement (a) implies statement (b), but (b) does not imply (a). thus, independence
is a stronger condition than correlation.
proof . we first prove that (a) implies (b). if xandyare independent, then e[xy] =
e[x]e[y]. in this case,
cov(x, y) =e[xy]−e[x]e[y] =e[x]e[y]−e[x]e[y] = 0.
to prove that (b) does not imply (a), we show a counterexample. consider a discrete
random variable zwith pmf
pz(z) =1
41
41
41
4
.
letxandybe
x= cosπ
2zand y= sinπ
2z.
then we can show that e[x] = 0 and e[y] = 0. the covariance is
cov(x, y) =e[(x−0)(y−0)]
=eh
cosπ
2zsinπ
2zi
=e1
2sinπz
=1
2
(sinπ0)1
4+ (sin π1)1
4+ (sin π2)1
4+ (sin π3)1
4
= 0.
2645.2. joint expectation
the next step is to show that xandyare dependent. to this end, we only need to show
thatpx,y(x, y)̸=px(x)py(y). the joint pmf px,y(x, y) can be found by noting that
z= 0⇒x= 1, y= 0,
z= 1⇒x= 0, y= 1,
z= 2⇒x=−1, y= 0,
z= 3⇒x= 0, y=−1.
thus, the pmf is
px,y(x, y) =
01
40
1
401
4
01
40
.
the marginal pmfs are
px(x) =1
41
21
4
, p y(y) =1
41
21
4
.
the product px(x)py(y) is
px(x)py(y) =
1
161
81
16
1
81
41
8
1
161
81
16
.
therefore, px,y(x, y)̸=px(x)py(y), although e[xy] =e[x]e[y].
□
what is the relationship between independent and uncorrelated?
independent ⇒uncorrelated.
independent ⇍uncorrelated.
5.2.4 computing correlation from data
we close this section by discussing a very practical problem: given a dataset containing two
columns of data points, how do we determine whether the two columns are correlated?
recall that the correlation coefficient is defined as
ρ=e[xy]−µxµy
σxσy.
if we have a dataset containing ( xn, yi)n
n=1, then the correlation coefficient can be approxi-
mated by
bρ=1
npn
n=1xnyn−xyq
1
npn
n=1(xn−x)2q
1
npn
n=1(yn−y)2,
where x=1
npn
n=1xnandy=1
npn
n=1ynare the means. this equation should not be a
surprise because essentially all terms are the empirical estimates. thus, bρis the empirical
correlation coefficient determined from the dataset. as n→ ∞ , we expect bρ→ρ.
265chapter 5. joint distributions
-5 -4 -3 -2 -1 0 1 2 3 4 5-5-4-3-2-1012345
-5 -4 -3 -2 -1 0 1 2 3 4 5-5-4-3-2-1012345
-5 -4 -3 -2 -1 0 1 2 3 4 5-5-4-3-2-1012345
(a)bρ=−0.0038 (b) bρ= 0.5321 (c) bρ= 0.9656
figure 5.9: visualization of correlated variables. each of these figures represent a scattered plot of a
dataset containing (xn, yn)n
n=1. (a) is uncorrelated. (b) is somewhat correlated. (c) is strongly correlated.
figure 5.9 shows three example datasets. we plot the ( xn, yn) pairs as coordinates in
the 2d plane. the first dataset contains samples that are almost uncorrelated. we can see
that xndoes not tell us anything about yn. the second dataset is moderately correlated.
the third dataset is highly correlated: if we know xn, we are almost certain to know the
corresponding yn, with a small number of perturbations.
on a computer, computing the correlation coefficient can be done using built-in com-
mands such as corrcoef in matlab and stats.pearsonr in python. the codes to gen-
erate the results in figure 5.9 (b) are shown below.
% matlab code to compute the correlation coefficient
x = mvnrnd([0,0],[3 1; 1 1],1000);
figure(1); scatter(x(:,1),x(:,2));
rho = corrcoef(x)
# python code to compute the correlation coefficient
import numpy as np
import scipy.stats as stats
import matplotlib.pyplot as plt
x = stats.multivariate_normal.rvs([0,0], [[3,1],[1,1]], 10000)
plt.figure(); plt.scatter(x[:,0],x[:,1])
rho,_ = stats.pearsonr(x[:,0],x[:,1])
print(rho)
5.3 conditional pmf and pdf
whenever we have a pair of random variables xandythat are correlated, we can define
their conditional distributions, which quantify the probability of x=xgiven y=y. in
this section, we discuss the concepts of conditional pmf and pdf.
2665.3. conditional pmf and pdf
5.3.1 conditional pmf
we start by defining the conditional pmf for a pair of discrete random variables.
definition 5.14. letxandybe two discrete random variables. the conditional
pmf ofxgiven yis
px|y(x|y) =px,y(x, y)
py(y). (5.21)
the simplest way to understand this is to view px|y(x|y) asp[x=x|y=y]. that is,
given that y=y, what is the probability for x=x? to see why this perspective makes
sense, let us recall the definition of a conditional probability:
px|y(x|y) =px,y(x, y)
py(y)
=p[x=x∩y=y]
p[y=y]=p[x=x|y=y].
as we can see, the last two equalities are essentially the definitions of conditional probability
and the joint pmf.
how should we understand the notation px|y(x|y)? is it a one-variable function in xor
a two-variable function in ( x, y)? what does px|y(x|y) tell us? to answer these questions,
let us first try to understand the randomness exhibited in a conditional pmf. in px|y(x|y),
the random variable yisfixed to a specific value y=y. therefore there is nothing random
about y. all the possibilities of yhave already been taken care of by the denominator
py(y). only the variable xinpx|y(x|y) has randomness. what do we mean by “fixed at a
value y=y”? consider the following example.
example 5.16 . suppose there are two coins. let
x= the sum of the values of two coins ,
y= the value of the first coin .
clearly, xhas 3 states: 0, 1, 2, and yhas two states: either 0 or 1. when we say
px|y(x|1), we refer to the probability mass function of xwhen fixing y= 1. if we do
not impose this condition, the probability mass of xis simple:
px(x) =1
4,1
2,1
4
.
however, if we include the conditioning, then
px|y(x|1) =px,y(x,1)
py(1)
=
0,2
4,1
4
1
6=
0,2
3,1
3
.
267chapter 5. joint distributions
to put this in plain words, when y= 1, there is no way for xto take the state 0. the
chance for xto take the state 1 is 2 /3 because either (0 ,1) or (1 ,0) can give x= 1.
the chance for xto take the state 2 is 1 /3 because it has to be (1 ,1) in order to give
x= 2. therefore, when we say “conditioned on y= 1”, we mean that we limit our
observations to cases where y= 1. since yis already fixed at y= 1, there is nothing
random about y. the only variable is x. this example is illustrated in figure 5.10 .
figure 5.10: suppose xis the sum of two coins with pmf 0.25,0.5,0.25. let ybe the first coin.
when xis unconditioned, the pmf is just [0.25,0.5,0.25]. when xis conditioned on y= 1,
then “ x= 0” cannot happen. therefore, the resulting pmf px|y(x|1)only has two states. after
normalization we obtain the conditional pmf [0,0.66,0.33].
since yis already fixed at a particular value y=y,px|y(x|y) is a probability mass
function of x(we want to emphasize again that it is xand not y). so px|y(x|y) is a one-
variable function in x. it is not the same as the usual pmf px(x).px|y(x|y) is conditioned
ony=y. for example, px|y(x|1) is the pmf of xrestricted to the condition that y= 1.
in fact, it follows that
x
x∈ωxpx|y(x|y) =x
x∈ωxpx,y(x, y)
py(y)=p
x∈ωxpx,y(x, y)
py(y)=py(y)
py(y)= 1,
but this tells us that px|y(x|y) is a legitimate probability mass of x. if we sum over the y’s
instead, then we will hit a bump:
x
y∈ωypx|y(x|y) =x
y∈ωypx,y(x, y)
py(y)̸= 1.
therefore, while px|y(x|y) is a legitimate probability mass function of x, it is not a prob-
ability mass function of y.
example 5.17 . consider a joint pmf given in the following table. find the conditional
pmf px|y(x|1) and the marginal pmf px(x).
y=
1 2 3 4
x = 11
201
201
200
20
21
202
203
201
20
31
202
203
201
20
40
201
201
201
20
2685.3. conditional pmf and pdf
solution . to find the marginal pmf, we sum over all the y’s for every x:
x= 1 : px(1) =4x
y=1px,y(1, y) =1
20+1
20+1
20+0
20=3
20,
x= 2 : px(2) =4x
y=1px,y(2, y) =1
20+2
20+2
20+1
20=6
20,
x= 3 : px(3) =4x
y=1px,y(3, y) =1
20+3
20+3
20+1
20=8
20,
x= 4 : px(4) =4x
y=1px,y(4, y) =0
20+1
20+1
20+1
20=3
20.
hence, the marginal pmf is
px(x) =3
206
208
203
20
.
the conditional pmf px|y(x|1) is
px|y(x|1) =px,y(x,1)
py(1)=1
201
201
200
20
3
20=1
31
31
30
.
practice exercise 5.7 . consider two random variables xandydefined as follows.
y=(
102, with prob 5 /6,
104, with prob 1 /6.x=

10−4y, with prob 1 /2,
10−3y, with prob 1 /3,
10−2y, with prob 1 /6.
find px|y(x|y),px(x) and px,y(x, y).
solution . since ytakes two different states, we can enumerate y= 102andy= 104.
this gives us
px|y(x|102) =

1/2, ifx= 0.01,
1/3, ifx= 0.1,
1/6, ifx= 1.
px|y(x|104) =

1/2, ifx= 1,
1/3, ifx= 10,
1/6, ifx= 100 .
269chapter 5. joint distributions
the joint pmf px,y(x, y) is
px,y(x,102) =px|y(x|102)py(102) =

 1
2 5
6
, x = 0.01, 1
3 5
6
, x = 0.1, 1
6 5
6
, x = 1.
px,y(x,104) =px|y(x|104)py(104) =

 1
2 1
6
, x = 1, 1
3 1
6
, x = 10, 1
6 1
6
, x = 100 .
therefore, the joint pmf is given by the following table.
1040 01
121
181
36
102 5
125
185
360 0
0.01 0.1 1 10 100
the marginal pmf px(x) is thus
px(x) =x
ypx,y(x, y) =5
125
182
91
181
36
.
in the previous two examples, what is the probability p[x∈a|y=y] or the proba-
bilityp[x∈a] for some events a? the answers are giving by the following theorem.
theorem 5.7. letxandybe two discrete random variables, and let abe an event.
then
(i)p[x∈a|y=y] =x
x∈apx|y(x|y)
(ii)p[x∈a] =x
x∈ax
y∈ωypx|y(x|y)py(y) =x
y∈ωyp[x∈a|y=y]py(y).
proof . the first statement is based on the fact that if acontains a finite number of elements,
thenp[x∈a] is equivalent to the sump
x∈ap[x=x]. thus,
p[x∈a|y=y] =p[x∈a∩y=y]
p[y=y]
=p
x∈ap[x=x∩y=y]
p[y=y]
=x
x∈apx|y(x|y).
the second statement holds because the inner summationp
y∈ωypx|y(x|y)py(y) is just
the marginal pmf px(x). thus the outer summation yields the probability.
□
2705.3. conditional pmf and pdf
example 5.18 . let us follow up on example 5.17. what is the probability that
p[x > 2|y= 1]? what is the probability that p[x > 2]?
solution . since the problem asks about the conditional probability, we know that it
can be computed by using the conditional pmf. this gives us
p[x > 2|y= 1] =x
x>2px|y(x|1)
=px|y(1|1) +px|y(2|1) +px|y(3|1)|{z}
1
3+px|y(4|1)|{z}
0=1
3.
the other probability is
p[x > 2] =x
x>2px(x)
=px(1) +px(2) + px(3)|{z}
8
20+px(4)|{z}
3
20=11
20.
what is the rule of thumb for conditional distribution?
the pmf/pdf should match with the probability you are finding.
if you want to find the conditional probability p[x∈a|y=y], use the condi-
tional pmf px|y(x|y).
if you want to find the probability p[x∈a], use the marginal pmf px(x).
finally, we define the conditional cdf for discrete random variables.
definition 5.15. letxandybe discrete random variables. then the conditional
cdf ofxgiven y=yis
fx|y(x|y) =p[x≤x|y=y] =x
x′≤xpx|y(x′|y). (5.22)
5.3.2 conditional pdf
we now discuss the conditioning of a continuous random variable.
definition 5.16. letxandybe two continuous random variables. the conditional
pdf ofxgiven yis
fx|y(x|y) =fx,y(x, y)
fy(y). (5.23)
271chapter 5. joint distributions
example 5.19 . let xandybe two continuous random variables with a joint pdf
fx,y(x, y) =(
2e−xe−y, 0≤y≤x <∞,
0, otherwise .
find the conditional pdfs fx|y(x|y) and fy|x(y|x).
solution . we first find the marginal pdfs.
fx(x) =z∞
−∞fx,y(x, y)dy=zx
02e−xe−ydy= 2e−x(1−e−x),
fy(y) =z∞
−∞fx,y(x, y)dx=z∞
y2e−xe−ydx= 2e−2y.
thus, the conditional pdfs are
fx|y(x|y) =fx,y(x, y)
fy(y)
=2e−xe−y
2e−2y=e−(x+y), x≥y,
fy|x(y|x) =fx,y(x, y)
fx(x)
=2e−xe−y
2e−x(1−e−x)=e−y
1−e−x,0≤y < x.
where does the conditional pdf come from? we cannot duplicate the argument
we used for the discrete case because the denominator of a conditional pmf becomes
p[y=y] = 0 when yis continuous. to answer this question, we first define the conditional
cdf for continuous random variables.
definition 5.17. letxandybe continuous random variables. then the conditional
cdf ofxgiven y=yis
fx|y(x|y) =rx
−∞fx,y(x′, y)dx′
fy(y). (5.24)
why should the conditional cdf of continuous random variable be defined in this way? one
way to interpret fx|y(x|y) is as the limiting perspective. we can define the conditional cdf
as
fx|y(x|y) = lim
h→0p(x≤x|y≤y≤y+h)
= lim
h→0p(x≤x∩y≤y≤y+h)
p[y≤y≤y+h].
2725.3. conditional pmf and pdf
with some calculations, we have that
lim
h→0p(x≤x∩y≤y≤y+h)
p[y≤y≤y+h]= lim
h→0rx
−∞ry+h
yfx,y(x′, y′)dy′dx′
ry+h
yfy(y′)dy′
= lim
h→0rx
−∞fx,y(x′, y′)dx′·h
fy(y)·h
=rx
−∞fx,y(x′, y′)dx′
fy(y).
the key here is that the small step size hin the numerator and the denominator will
cancel each other out. now, given the conditional cdf, we can verify the definition of the
conditional pdf. it holds that
fx|y(x|y) =d
dxfx|y(x|y)
=d
dx(rx
−∞fx,y(x′, y)dx′
fy(y))
(a)=fx,y(x, y)
fy(y),
where (a) follows from the fundamental theorem of calculus.
just like the conditional pmf, we can calculate the probabilities using the conditional
pdfs. in particular, if we evaluate the probability where x∈agiven that ytakes a
particular value y=y, then we can integrate the conditional pdf fx|y(x|y), with respect
tox.
theorem 5.8. letxandybe continuous random variables, and let abe an event.
(i)p[x∈a|y=y] =r
afx|y(x|y)dx,
(ii)p[x∈a] =r
ωyp[x∈a|y=y]fy(y)dy.
example 5.20 . let xbe a random bit such that
x=(
+1,with prob 1 /2,
−1,with prob 1 /2.
suppose that xis transmitted over a noisy channel so that the observed signal is
y=x+n,
where n∼gaussian(0 ,1) is the noise, which is independent of the signal x. find the
probabilities p[x= +1|y >0] and p[x=−1|y >0].
solution . first, we know that
fy|x(y|+ 1) =1√
2πe−(y−1)2
2 and fy|x(y| −1) =1√
2πe−(y+1)2
2.
273chapter 5. joint distributions
therefore, integrating yfrom 0 to ∞gives us
p[y >0|x= +1] =z∞
01√
2πe−(y−1)2
2dy
= 1−z0
−∞1√
2πe−(y−1)2
2dy
= 1−φ0−1
1
= 1−φ(−1).
similarly, we have p[y >0|x=−1] = 1 −φ(+1). the probability we want to find is
p[x= +1|y >0], which can be determined using bayes’ theorem.
p[x= +1|y >0] =p[y >0|x= +1]p[x= +1]
p[y >0].
the denominator can be found by using the law of total probability:
p[y >0] =p[y >0|x= +1]p[x= +1]
+p[y >0|x=−1]p[x=−1]
= 1−1
2(φ(+1) + φ( −1))
=1
2,
since φ(+1) + φ( −1) = φ(+1) + 1 −φ(+1) = 1. therefore,
p[x= +1|y >0] = 1 −φ(−1)
= 0.8413.
the implication is that if y > 0, the probability p[x= +1|y > 0] = 0 .8413. the
complement of this result gives p[x=−1|y >0] = 1 −0.8413 = 0 .1587.
practice exercise 5.8 . find p[y > y ], where
x∼uniform[1 ,2], y|x∼exponential( x).
solution . the tricky part of this problem is the tendency to confuse the two variables
xandy. once you understand their roles the problem becomes easy. first notice that
y|x∼exponential( x) is a conditional distribution. it says that given x=x, the
probability distribution of yis exponential, with the parameter x. thus, we have that
fy|x(y|x) =xe−xy.
why? recall that if y∼exponential( λ) then fy(y) =λe−λy. now if we replace λ
with x, we have xe−xy. so the role of xin this conditional density function is as a
parameter.
2745.4. conditional expectation
given this property, we can compute the conditional probability:
p[y > y |x=x] =z∞
yfy|x(y′|x)dy′
=z∞
yxe−xy′dy′=
−e−xy′∞
y′=y=e−xy.
finally, we can compute the marginal probability:
p[y > y ] =z
ωxp[y >0|x=x′]fx(x′)dx′
=z1
0e−x′ydx′
=1
ye−x′yx′=1
x′=0=1
y 
1−e−y
.
we can double-check this result by noting that the problem asks about the probability
p[y > y ]. thus, the answer must be a function of ybut not of x.
5.4 conditional expectation
5.4.1 definition
when dealing with two dependent random variables, at times we would like to determine
the expectation of a random variable when the second random variable takes a particular
state. the conditional expectation is a formal way of doing so.
definition 5.18. theconditional expectation ofxgiven y=yis
e[x|y=y] =x
xxpx|y(x|y) (5.25)
for discrete random variables, and
e[x|y=y] =z∞
−∞xfx|y(x|y)dx (5.26)
for continuous random variables.
there are two points to note here. first, the expectation of e[x|y=y] is taken with respect
tofx|y(x|y). we assume that the random variable yis already fixed at the state y=y.
thus, the only source of randomness is x. secondly, since the expectation e[x|y=y] has
eliminated the randomness of x, the resulting function is in y.
275chapter 5. joint distributions
what is conditional expectation?
e[x|y=y] is the expectation using fx|y(x|y).
the integration is taken w.r.t. x, because y=yis given and fixed.
5.4.2 the law of total expectation
theorem 5.9. the law of total expectation states that
e[x] =x
ye[x|y=y]py(y),ore[x] =z∞
−∞e[x|y=y]fy(y)dy. (5.27)
proof . we will prove the discrete case only, as the continuous case can be proved by replacing
summation with integration.
e[x] =x
xxpx(x) =x
xx x
ypx,y(x, y)!
=x
xx
yxpx|y(x|y)py(y)
=x
y x
xxpx|y(x|y)!
py(y) =x
ye[x|y=y]py(y).
□
figure 5.11 illustrates the idea behind the proof. essentially, we decompose the expec-
tation e[x] into “subexpectations” e[x|y=y]. the probability of each subexpectation is
py(y). by summing the subexpectation multiplied by py(y), we obtain the overall expecta-
tion.
figure 5.11: the expectation e[x]can be decomposed into a set of subexpectations. this gives us
e[x] =p
ye[x|y=y]py(y).
2765.4. conditional expectation
what is the law of total expectation?
the law of total expectation is a decomposition rule.
it decomposes e[x] into smaller/easier conditional expectations.
this law can also be written in a more compact form.
corollary 5.1. letxandybe two random variables. then
e[x] =ey
ex|y[x|y]
. (5.28)
proof . the previous theorem states that e[x] =p
ye[x|y=y]py(y). if we treat e[x|y=
y] as a function of y, for instance h(y), then
e[x] =x
ye[x|y=y]py(y) =x
yh(y)py(y) =e[h(y)] =e[e[x|y]].
□
example 5.21 . suppose there are two classes of cars. let xbe the speed of a car
andcbe the class. when c= 1, we know that x∼gaussian( µ1, σ1). we know that
p[c= 1] = p. when c= 2, x∼gaussian( µ2, σ2). also, p[c= 2] = 1 −p. if you see
a car on the freeway, what is its average speed?
solution . the problem has given us everything we need. in particular, we know that
the conditional pdfs are:
fx|c(x|1) =1p
2πσ2
1exp
−(x−µ1)2
2σ2
1
,
fx|c(x|2) =1p
2πσ2
2exp
−(x−µ2)2
2σ2
2
.
therefore, conditioned on c, we have two expectations:
e[x|c= 1] =z∞
−∞x fx|c(x|1)dx=µ1,
e[x|c= 2] =z∞
−∞x fx|c(x|2)dx=µ2.
the overall expectation e[x] is
e[x] =2x
c=1e[x|c=c]pc(c)
=e[x|c= 1]p[c= 1] + e[x|c= 2]p[c= 2]
=pµ1+ (1−p)µ2.
277chapter 5. joint distributions
practice exercise 5.9 . consider a joint pmf given by the following table. find
e[x|y= 102] ande[x|y= 104].
y1040 01
121
181
36
102 5
125
185
360 0
0.01 0.1 1 10 100
x
solution . to find the conditional expectation, we first need to know the conditional
pmf.
px|y(x|102) =1
21
31
60 0
,
px|y(x|104) =
0 01
21
31
6
.
therefore, the conditional expectations are
e[x|y= 102] = (10−2)1
2
+ (10−1)1
3
+ (1)1
6
=123
600,
e[x|y= 104] = (1)1
2
+ (10)1
3
+ (100)1
6
=123
6.
from the conditional expectations we can also find e[x]:
e[x] =e[x|y= 102]py(102)
+e[x|y= 104]py(104)
=123
6005
6
+123
61
6
= 3.5875.
example 5.22 . consider two random variables xandy. the random variable x
is gaussian-distributed with x∼gaussian( µ, σ2). the random variable yhas a
conditional distribution y|x∼gaussian( x, x2). find e[y].
solution . the notation y|x∼gaussian( x, x2) means that given the variable x,
the other variable yhas a conditional distribution gaussian( x, x2). that is, the
variable yis a gaussian with mean xand variance x2. how can the mean be a
random variable xand the variance be another random variable x2? because xis
the conditional variable. y|xmeans that you have already chosen one state of x.
given that particular state, the distribution of yfollows fy|x. therefore, for this
2785.4. conditional expectation
problem, we know the pdfs:
fx(x) =1√
2πσ2exp
−(x−µ)2
2σ2
,
fy|x(y|x) =1√
2πx2exp
−(y−x)2
2x2
.
the conditional expectation of ygiven xis
e[y|x=x] =z∞
−∞y1√
2πx2exp
−(y−x)2
2x2
dy
=e[gaussian( x, x2)] =x.
the last equality holds because we are computing the expectation of a gaussian ran-
dom variable with mean x. finally, applying the law of total expectation, we can show
that
e[y] =z∞
−∞e[y|x=x]fx(x)dx
=z∞
−∞x1√
2πσ2exp
−(x−µ)2
2σ2
dx
=e[gaussian( µ, σ2)] =µ,
where the last equality is based on the fact that it is the mean of a gaussian.
practice exercise 5.10 . find e[sin(x+y)], if x∼gaussian(0 ,1), and y|x∼
uniform[ x−π, x+π].
solution . we know that the conditional density is
fy|x(y|x) =1
2π, x −π≤y≤x+π.
therefore, we can compute the probability
e[sin(x+y)|x=x] =zx+π
x−πsin(x+y)fy|x(y|x)dy
=1
2πzx+π
x−πsin(x+y)dy
| {z }
=0= 0.
hence, the overall expectation is
e[sin(x+y)] =z1
0e[sin(x+y)|x=x]| {z }
=01√
2πe−x2
2dx= 0.
279chapter 5. joint distributions
5.5 sum of two random variables
one typical problem we encounter in engineering is to determine the pdf of the sum of
two random variables xandy, i.e., x+y. such a problem arises naturally when we want
to evaluate the average of many random variables, e.g., the sample mean of a collection of
data points. this section will discuss a general principle for determining the pdf of a sum
of two random variables.
5.5.1 intuition through convolution
first, consider two random variables, xandy, both discrete uniform random variables
in the range of 0 ,1,2,3. that is, px(x) =py(y) = [1 /4,1/4,1/4,1/4]. since this is such a
simple problem we can enumerate all the possible cases of the sum z=x+y. the resulting
probabilities are shown in the following table.
z=x+ycases, written in terms of (x, y) probability
0 (0,0) 1/16
1 (0,1), (1,0) 2/16
2 (1,1), (2,0), (0,2) 3/16
3 (3,0), (2,1), (1,2), (0,3) 4/16
4 (3,1), (2,2), (1,3) 3/16
5 (3,2), (2,3) 2/16
6 (3,3) 1/16
clearly, the pmf of zis not fz(z) =fx(x)+fy(y). (caution! do not write this.) the
pmf of zlooks like a triangle distribution. how can we get to this triangle distribution
from two uniform distributions? the key is the idea of convolution. let us start with the
pmf of x, which is px(x). let us also flip py(y) over the y-axis. as we shift the flipped py,
we multiply and add the pmf values as shown in figure 5.12 . this gives us
pz(0) =p[x+y= 0]
=p[(x, y) = (0 ,0)]
=px(0)py(0)
=1
16.
now, if we shift towards the right by 1, we have
pz(1) =p[x+y= 1]
=p[(x, y) = (0 ,1)∪(0,1)]
=px(0)py(1) + px(1)py(0) =2
16.
by continuing our argument, you can see that we will obtain the same pmf as the one
shown in the table.
2805.5. sum of two random variables
figure 5.12: when summing two random variables xandy, we are effectively taking the convolutions
of the two respective pmf / pdfs.
5.5.2 main result
we can show that for any arbitrary random variable xandy, the sum z=x+yhas a
distribution that is the convolution of two individual pdfs.
theorem 5.10. letxandybe two independent random variables with pdfs fx(x)
andfy(y)respectively. let z=x+y. the pdf of zis given by
fz(z) = (fx∗fy)(z) =z∞
−∞fx(z−y)fy(y)dy, (5.29)
where “ ∗” denotes the convolution.
proof . we begin by analyzing the cdf of z. the cdf of zis
fz(z) =p[z≤z] =p[x+y≤z].
we now draw a picture to illustrate the line under which we want to integrate. as shown in
figure 5.13 , the equation x+y≤zdefines a straight line in the xyplane. you can think
of it as y≤ −x+z, so that the slope is −1 and the y-intercept is z.
now, shall we take the upper half of the triangle or the lower half? since the equation
isy≤ −x+z, a value of yhas to be less than that of the line. another easy way to check
is to assume z >0 so that we have a positive y-intercept. then we check where the origin
281chapter 5. joint distributions
figure 5.13: the shaded region highlights the set x+y≤z. to integrate the pdf over this region,
we first take the inner integration over dxand then take the outer integration over dy.
(0,0) belongs. in this case, if z >0, the origin (0 ,0) will satisfy the equation y≤ −x+z,
and so it must be included. thus, we conclude that the area is below the line.
once we have determined the area to be integrated, we can write down the integration:
p[x+y≤z] =z∞
−∞zz−y
−∞fx,y(x, y)dx dy
=z∞
−∞zz−y
−∞fx(x)fy(y)dx dy, (independence)
where the integration limits are just a rewrite of x+y≤z(in this case since we are
integrating xfirst we have x≤ −y+z). then, by the fundamental theorem of calculus,
we can show that
fz(z) =d
dzfz(z) =d
dzz∞
−∞zz−y
−∞fx(x)fy(y)dx dy
=z∞
−∞d
dzzz−y
−∞fx(x)fy(y)dx
dy
=z∞
−∞fx(z−y)fy(y)dy= (fx∗fy)(z),
where “ ∗” denotes the convolution.
how is convolution related to random variables?
if you sum xandy, the resulting pdf is the convolution of fxandfy.
e.g., convolving two uniform random variables gives you a triangle pdf.
5.5.3 sum of common distributions
theorem 5.11 (sum of two poissons) .letx1∼poisson (λ1)andx2∼poisson (λ2).
then
x1+x2∼poisson (λ1+λ2). (5.30)
2825.5. sum of two random variables
proof . let us apply the convolution principle.
py(k) =p[x1+x2=k]
=p[x1=ℓ∩x2=k−ℓ]
=kx
ℓ=0λℓ
1e−λ1
ℓ!·λk−ℓ
2e−λ2
(k−ℓ)!
=e−(λ1+λ2)kx
ℓ=0λℓ
1
ℓ!·λk−ℓ
2
(k−ℓ)!
=e−(λ1+λ2)·1
k!kx
ℓ=0k!
ℓ!(k−ℓ)!λℓ
1λk−ℓ
2
| {z }
=pk
ℓ=0(k
ℓ)λℓ
1λk−ℓ
2
=(λ1+λ2)k
k!e−(λ1+λ2),
where the last step is based on the binomial identitypk
ℓ=0 k
ℓ
aℓbk−ℓ= (a+b)k.
□
theorem 5.12 (sum of two gaussians ).letx1andx2be two gaussian random
variables such that
x1∼gaussian (µ1, σ2
1)and x 2∼gaussian (µ2, σ2
2).
then
x1+x2∼gaussian (µ1+µ2, σ2
1+σ2
2). (5.31)
proof . let us apply the convolution principle.
fz(z) =z∞
−∞fx(t)fy(z−t)dt
=z∞
−∞1√
2πσ2exp
−(t−µ1)2
2σ2
·1√
2πσ2exp
−(z−t−µ2)2
2σ2
dt
=1√
2πσ2z∞
−∞1√
2πσ2exp
−(t−µ1)2+ (z−t−µ2)2
2σ2
dt.
we now complete the square:
(t−µ1)2+ (z−t−µ2)2= [t2−2µ1t+µ2
1] + [t2+ 2t(µ2−z) + (µ2−z)2]
= 2t2−2t(µ1−µ2+z) +µ2
1+ (µ2−z)2
= 2
t2−2t·µ1−µ2+z
2
+µ2
1+ (µ2−z)2
= 2
t−µ1−µ2+z
22
−2µ1−µ2+z
22
+µ2
1+ (µ2−z)2.
283chapter 5. joint distributions
the last term can be simplified to
−2µ1−µ2+z
22
+µ2
1+ (µ2−z)2
=−µ2
1−2µ1(µ2−z) + (µ2−z)2
2+µ2
1+ (µ2−z)2
=µ2
1+ 2µ1(µ2−z) + (µ2−z)2
2=(µ1+µ2−z)2
2.
substituting these into the integral, we can show that
fz(z) =1√
2πσ2z∞
−∞1√
2πσ2exp(
−2
t−µ1−µ2+z
22+(µ1+µ2−z)2
2
2σ2)
dt
=1√
2πσ2exp
−(µ1+µ2−z)2
2(2σ2)z∞
−∞1√
2πσ2exp(
−
t−µ1−µ2+z
22
σ2)
dt
| {z }
=1√
2
=1p
2π(2σ)2exp
−(µ1+µ2−z)2
2(2σ2)
.
therefore, we have shown that the resulting distribution is a gaussian with mean µ1+µ2
and variance 2 σ2. □
practice exercise 5.11 . let xandybe independent, and let
fx(x) =(
xe−x, x ≥0,
0, x < 0,and fy(y) =(
ye−y, y ≥0,
0, y < 0.
find the pdf of z=x+y.
solution . using the results derived above, we see that
fz(z) =z∞
−∞fx(z−y)fy(y)dy
=zz
−∞fx(z−y)fy(y)dy,
where the upper limit zcame from the fact that x≥0. therefore, since z=x+y, we
must have z−y=x≥0 and so z≥y. this is portrayed graphically in figure 5.14 .
substituting the pdfs into the integration yields
fz(z) =zz
0(z−y)e−(z−y)ye−ydy=z3
6e−z, z≥0.
forz <0,fz(z) = 0.
the functions of two random variables are not limited to summation. the following
example illustrates the case of the product of two random variables.
2845.5. sum of two random variables
figure 5.14: [left] the outer integral goes from 0 to zbecause the triangle stops at y=z. [right] if
the triangle is unbounded, then the integral goes from −∞ to∞.
example 5.23 . let xandybe two independent random variables such that
fx(x) =(
2x, if 0≤x≤1,
0, otherwise ,and fy(y) =(
1, if 0≤y≤1,
0, otherwise .
letz=xy. find fz(z).
solution . the cdf of zcan be evaluated as
fz(z) =p[z≤z] =p[xy≤z] =z∞
−∞zz
y
−∞fx(x)fy(y)dx dy.
taking the derivative yields
fz(z) =d
dzfz(z) =d
dzz∞
−∞zz
y
−∞fx(x)fy(y)dx dy
(a)=z∞
−∞1
yfxz
y
fy(y)dy,
where (a) holds by the fundamental theorem of calculus. the upper and lower limit of
this integration can be determined by noting that
0≤z
y=x≤1,
which implies that z≤y. since y≤1, we have that z≤y≤1. therefore, the pdf is
fz(z) =z1
z1
yfxz
y
fy(y)dy
=z1
z2z
y2dy= 2(1 −z), z≥0.
forz <0,fz(z) = 0.
285chapter 5. joint distributions
closing remark . for some random variables, summing two i.i.d. copies remain the same
random variable (but with different parameters). for other random variables, summing
two i.i.d. copies gives a different random variable. table 5.1 summarizes some of the most
commonly used random variable pairs.
x1 x2 sum x1+x2
bernoulli( p) bernoulli( p) binomial(2 , p)
binomial( n, p) binomial( m, p) binomial( m+n, p)
poisson( λ1) poisson( λ2) poisson( λ1+λ2)
exponential( λ) exponential( λ) erlang(2 , λ)
gaussian( µ1, σ2
1) gaussian( µ2, σ2
2) gaussian( µ1+µ2, σ2
1+σ2
2)
table 5.1: common distributions of the sum of two random variables.
5.6 random vectors and covariance matrices
we now enter the second part of this chapter. in the first part, we were mainly interested
in a pair of random variables. in the second part, however, we will study vectors of n
random variables. to understand a vector of random variables, we will not drill down to
the integrations of the pdfs (which you would certainly not enjoy). instead, we will blend
linear algebra tools and probabilistic tools to learn a few practical data analysis techniques.
5.6.1 pdf of random vectors
joint distributions can be generalized to more than two random variables. the most conve-
nient way is to consider a vector of random variables and their corresponding states.
x=
x1
x2
...
xn
and x=
x1
x2
...
xn
.
our notation here is unconventional since bold upper case letters usually represent matrices.
here, xdenotes a vector, specifically a random vector. its state is a vector x. in this chapter,
we will use the following notational convention: xandyrepresent random vectors while
arepresents a matrix.
one way to think about xis to imagine that if you put your hand into the sample
space, you will pick up a vector x. this random realization xhasnentries, and so you
need to specify the probability of getting all these entries simultaneously . accordingly, we
should expect that xis characterized by an n-dimensional pdf
fx(x) =fx1,x2,...,x n(x1, x2, . . . , x n).
2865.6. random vectors and covariance matrices
essentially, this pdf tells us the probability density for random variable x1=x1, random
variable x2=x2, etc. it is a coordinate-wise description. for example, if xcontains three
elements such that x= [x1, x2, x3]t, and if the state we are looking at is x= [3,1,7]t,
then fx(x) is the probability density such that this 3d coordinate ( x1, x2, x3) takes the
value [3 ,1,7]t.
to compute the probability, we can integrate fx(x) with respect to x. letabe the
event. then
p[x∈ a] =z
afx(x)dx
=z
···z
afx1,...,x n(x1, . . . , x n)dx1. . . dx n.
if the random coordinates x1, . . . , x nareindependent , the pdf can be written as a prod-
uct of nindividual pdfs:
fx1,...,x n(x1, . . . , x n) =fx1(x1)fx2(x2)···fxn(xn),and so
p[x∈ a] =z
···z
afx1(x1)fx2(x2)···fxn(xn)dx1···dxn.
however, this does not necessarily simplify the calculation unless ais separable, e.g., a=
[a1, b1]×[a2, b2]× ··· × [an, bn]. in this case the integration becomes
p[x∈ a] =ny
i=1"zbi
aifxi(xi)dxi#
,
which is obviously manageable.
example 5.24 . letx= [x1, . . . , x n]tbe a vector of zero-mean unit variance gaus-
sian random vectors. let a= [−1,2]n. then
p[x∈ a] =z
afx(x)dx
=z
···z
afx1,···,xn(x1, . . . , x n)dx1···dxn
=z2
−1fx1(x1)dx1n
= [φ(2) −φ(−1)]n,
where φ( ·) is the standard gaussian cdf.
as you can see from the definition of a vector random variable, computing the proba-
bility typically involves integrating a high-dimensional function, which is tedious. however,
the good news is that in practice we seldom need to perform such calculations. often we are
more interested in the mean and the covariance of the random vectors because they usually
carry geometric meanings. the next subsection explores this topic.
287chapter 5. joint distributions
5.6.2 expectation of random vectors
letx= [x1, . . . , x n]tbe a random vector. we define the expectation of a random vector
as follows.
definition 5.19. letx= [x1, . . . , x n]tbe a random vector. the expectation is
µdef=e[x] =
e[x1]
e[x2]
...
e[xn]
. (5.32)
the resulting vector is called the mean vector . since the mean vector is a vector of
individual elements, we need to compute the marginal pdfs before computing the expec-
tations:
e[x] =
e[x1]
...
e[xn]
=
r
ωx1fx1(x1)dx1
...r
ωxnfxn(xn)dxn
,
where the marginal pdf is determined by
fxn(xn) =z
ωfx\n(x\n)dx\n.
in the equation above, x\n= [x1, . . . , x n−1, xn+1, . . . , x n]tcontains all the elements with-
outxn. for example, if the pdf is fx1,x2,x3(x1, x2, x3), then
e[x1] =z
x1z
fx1,x2,x3(x1, x2, x3)dx2dx3
| {z }
fx1(x1)dx1.
again, this will become tedious when there are many variables.
while the definition of the expectation may be challenging to understand, some prob-
lems using it are straightforward. we will first demonstrate the case of independent poisson
random variables, and then we will discuss joint gaussians.
example 5.25 . letx= [x1, . . . , x n]tbe a random vector such that xnare inde-
pendent poissons with xn∼poisson( λn). then
e[x] =
e[x1]
...
e[xn]
=
p∞
k=0k·λk
1e−λ1
k!...p∞
k=0k·λk
ne−λn
k!
=
λ1
...
λn
.
on computers, computing the mean vector can be done using built-in commands such
asmean in matlab and np.mean in python. however, caution is needed when performing
the calculation. in matlab, mean computes along first dimension (rows index). thus, if we
2885.6. random vectors and covariance matrices
have an n×2 array, applying mean will give us a 1 ×2 vector. to obtain the column mean
vector of size n×1, we need to specify the direction as mean(x,2) . similarly, in python,
when calling np.mean , we need to specify the axis.
% matlab code to compute a mean vector
x = randn(100,2);
mx = mean(x,2);
# python code to compute a mean vector
import numpy as np
import scipy.stats as stats
x = stats.multivariate_normal.rvs([0,0],[[1,0],[0,1]],100)
mx = np.mean(x,axis=1)
5.6.3 covariance matrix
definition 5.20. thecovariance matrix of a random vector x= [x1, . . . , x n]tis
σdef= cov( x) =
var[x1] cov( x1, x2)··· cov(x1, xn)
cov[x2, x1] var[ x2]··· cov(x2, xn)
............
cov(xn, x1) cov( xn, x2)··· var[xn]
. (5.33)
a more compact way of writing the covariance matrix is
σ= cov( x) =e[(x−µ)(x−µ)t],
where µ=e[x] is the mean vector. the notation abtmeans the outer product , defined
as
abt=
a1
...
an
b1···bn
=
a1b1a1b2··· a1bn
............
anb1anb2···anbn
.
it is easy to show that cov( x) = cov( x)t, i.e., they are symmetric.
theorem 5.13. if the coordinates x1, . . . , x nare independent, then the covariance
matrix cov(x) =σis a diagonal matrix:
σ= cov( x) =
var[x1] 0 ··· 0
0 var[ x2]··· 0
............
0 0 ··· var[xn]
.
289chapter 5. joint distributions
proof . if all xi’s are independent, then cov( xi, xj) = 0 for all i̸=j. substituting this
into the definition of the covariance matrix, we obtain the result.
□
if we ignore the mean vector µ, we obtain the autocorrelation matrix r.
definition 5.21. letx= [x1, . . . , x n]tbe a random vector. the autocorrelation
matrix is
r=e[xxt] =
e[x1x1]e[x1x2]···e[x1xn]
e[x2x1]e[x2x2]···e[x2xn]
............
e[xnx1]e[xnx2]···e[xnxn]
. (5.34)
we state without proof that
σ=r−µµt,
which corresponds to the single-variable case where σ2=e[x2]−µ2.
on computers, computing the covariance matrix is done using built-in commands cov
in matlab and np.cov in python. like the mean vectors, when computing the covariance,
we need to specify the direction. for example, for an n×2 data matrix x, the covariance
needs to be a 2 ×2 matrix. if we compute the covariance along the wrong direction, we will
obtain an n×nmatrix, which is incorrect.
% matlab code to compute covariance matrix
x = randn(100,2);
covx = cov(x);
# python code to compute covariance matrix
import numpy as np
import scipy.stats as stats
x = stats.multivariate_normal.rvs([0,0],[[1,0],[0,1]],100)
covx = np.cov(x,rowvar=false)
print(covx)
5.6.4 multidimensional gaussian
with the above tools in hand, we can now define a high-dimensional gaussian. the pdf of
a high-dimensional gaussian is defined as follows.
definition 5.22. ad-dimensional joint gaussian has the pdf
fx(x) =1p
(2π)d|σ|exp
−1
2(x−µ)tς−1(x−µ)
, (5.35)
where ddenotes the dimensionality of the vector x.
2905.6. random vectors and covariance matrices
the mean vector and the covariance matrix of a joint gaussian is readily available from the
definition.
e[x] =µ and cov( x) =σ.
it is easy to show that if xis a scalar x, then d= 1,µ=µ, and σ=σ2. substituting
these into the above definition returns us the familiar 1d gaussian.
thed-dimensional gaussian is a generalization of the 1d gaussian(s). suppose that xi
andxjareindependent for all i̸=j. then e[xixj] =e[xi]e[xj] and hence cov( xi, xj) =
0. consequently, the covariance matrix σis a diagonal matrix:
σ=
σ2
1··· 0
.........
0···σ2
d
,
where σ2
i= var[ xi]. when this occurs, the exponential term in the gaussian pdf is
(x−µ)tς−1(x−µ) =
x1−µ1
...
xd−µd
t
σ2
1··· 0
.........
0···σ2
d
−1
x1−µ1
...
xd−µd
=dx
i=1(xi−µi)2
σ2
i.
moreover, the determinant |σ|is
|σ|=
σ2
1··· 0
.........
0···σ2
d
=dy
i=1σ2
i.
substituting these results into the joint gaussian pdf, we obtain
fx(x) =ny
i=11p
(2π)σ2
iexp
−(x−µi)2
2σ2
i
,
which is a product of individual gaussians.
the gaussian has different offsets and orientations for different choices of µandς.
figure 5.15 shows a few examples. note that for σto be valid σhas to be “symmetric
positive semi-definite”, the meaning of which will be explained shortly.
generating random numbers from a multidimensional gaussian can be done by calling
built-in commands. in matlab, we use mvnrnd . in python, we have a similar command.
% matlab code to generate random numbers from multivariate gaussian
mu = [0 0];
sigma = [.25 .3; .3 1];
x = mvnrnd(mu,sigma,100);
# python code to generate random numbers from multivariate gaussian
import numpy as np
import scipy.stats as stats
x = stats.multivariate_normal.rvs([0,0],[[0.25,0.3],[0.3,1.0]],100)
291chapter 5. joint distributions
-5 -4 -3 -2 -1 0 1 2 3 4 5-5-4-3-2-1012345
-5 -4 -3 -2 -1 0 1 2 3 4 5-5-4-3-2-1012345
-5 -4 -3 -2 -1 0 1 2 3 4 5-5-4-3-2-1012345
(µ,σ) =0
2
,5 0
0 0.5
(µ,σ) =1
2
,1−0.5
−0.5 1
(µ,σ) =0
0
,2 1 .9
1.9 2
figure 5.15: visualization of 2d gaussians with different means and covariances.
to display the data points and overlay with the contour, we can use matlab com-
mands such as contour . the resulting plot looks like the one shown in figure 5.16 . in
python the corresponding command is plt.contour . to set up the plotting environment
we use the commands np.meshgrid . the grid points are used to evaluate the pdf values,
thus giving us the contour.
% matlab code: overlay random numbers with the gaussian contour.
x = mvnrnd([0 0],[.25 .3; .3 1],1000);
x1 = -2.5:.01:2.5;
x2 = -3.5:.01:3.5;
[x1,x2] = meshgrid(x1,x2);
f = mvnpdf([x1(:) x2(:)],[0 0],[.25 .3; .3 1]);
f = reshape(f,length(x2),length(x1));
figure(1);
scatter(x(:,1),x(:,2),’rx’, ’linewidth’, 1.5); hold on;
contour(x1,x2,f,[.001 .01 .05:.1:.95 .99 .999], ’linewidth’, 2);
# python code: overlay random numbers with the gaussian contour.
import numpy as np
import scipy.stats as stats
import matplotlib.pyplot as plt
x = stats.multivariate_normal.rvs([0,0],[[0.25,0.3],[0.3,1.0]],1000)
x1 = np.arange(-2.5, 2.5, 0.01)
x2 = np.arange(-3.5, 3.5, 0.01)
x1, x2 = np.meshgrid(x1,x2)
xpos = np.empty(x1.shape + (2,))
xpos[:,:,0] = x1
xpos[:,:,1] = x2
f = stats.multivariate_normal.pdf(xpos,[0,0],[[0.25,0.3],[0.3,1.0]])
plt.scatter(x[:,0],x[:,1])
plt.contour(x1,x2,f)
2925.7. transformation of multidimensional gaussians
-2.5 -2 -1.5 -1 -0.5 0 0.5 1 1.5 2 2.5
x-3-2-10123y
figure 5.16: 1000 random numbers drawn from a 2d gaussian, overlaid with the contour plot.
5.7 transformation of multidimensional gaussians
as we have seen in figure 5.15 , the shape and orientation of a multidimensional gaussian
are determined by the mean vector µand the covariance matrix σ. this means that if we
can somehow transform the mean vector and the covariance matrix, we will get another
gaussian. a few practical questions are:
how do we shift and rotate a gaussian random variable?
if we have an arbitrary gaussian, how do we go back to zero-mean unit-variance
gaussian?
how do we generate random vectors according to a predefined gaussian?
these questions come up frequently in data analysis. answering the first two questions will
help us transform gaussians back and forth, while answering the last question will help us
with generating random samples.
5.7.1 linear transformation of mean and covariance
suppose we have an arbitrary (not necessarily a gaussian) random vector x= [x1, . . . , x n]t
with mean µxand covariance σx. entries of xare not necessarily independent. let
a∈rn×nbe a transformation, and let y=ax. that is,
y=
y1
y2
...
yn
=
a11a12··· a1n
a21a22··· a2n
............
an1an2···ann

x1
x2
...
xn
=ax.
then we can show the following result.
293chapter 5. joint distributions
theorem 5.14. the mean vector and covariance matrix of y=ax are
µy=aµx, σy=aσxat. (5.36)
proof . we first show the mean. consider the nth element of y:
e[yn] =e"nx
k=1ankxk#
=nx
k=1anke[xk].
therefore,
µy=
e[y1]
e[y2]
...
e[yn]
=
pn
k=1a1ke[xk]pn
k=1a2ke[xk]
...pn
k=1anke[xk]

=
a11a12··· a1n
a21a22··· a2n
............
an1an2···ann

e[x1]
e[x2]
...
e[xn]
=aµx.
the covariance matrix follows from the fact that
σy=e[(y−µy)(y−µy)t]
=e[(ax−aµx)(ax−aµx)t]
=e[a(x−µx)(x−µx)tat]
=ae[(x−µx)(x−µx)t]at
=aσxat.
□
what if we shift the random vector by defining y=x+b? we state the following
result without proof (try proving it as an exercise).
theorem 5.15. the mean vector and covariance matrix of y=x+bare
µy=µx+b, σy=σx. (5.37)
for a gaussian random vector, the linear transformations either shifts the gaussian or
rotates the gaussian, as shown in figure 5.17 :
if we add btox, the resulting operation is a translation.
if we multiply abyx, then the resulting operation is a rotation and scaling.
2945.7. transformation of multidimensional gaussians
figure 5.17: transforming a gaussian. [left] translation by a vector b. [right] rotation and scaling by
a matrix x.
how to rotate, scale, and translate a gaussian random variable
we rotate and scale a gaussian by y=ax.
we translate a gaussian by y=x+b.
5.7.2 eigenvalues and eigenvectors
as our next step, we need to understand eigendecomposition . you can easily find relevant
background in any undergraduate linear algebra textbook. here we provide a summary for
completeness.
when applying a matrix ato a vector x, a typical engineering question is: what x
would be invariant to a? or in other words, for what xcan we make sure that ax=λx,
for some scalar λ? if we can find such a vector x, we say that xis the eigenvector ofa.
eigenvectors are useful for seeking principal components of datasets or finding efficient signal
representations. they are defined as follows:
definition 5.23. given a square matrix a∈rn×n, the vector u∈rn(with u̸=0)
is called the eigenvector ofaif
au=λu, (5.38)
for some λ∈r. the scalar λis called the eigenvalue associated with u.
ann×nmatrix has neigenvectors and neigenvalues. therefore, the above equation can
be generalized to
aui=λiui,
fori= 1, . . . , n , or more compactly as au = λu. the eigenvalues λ1, . . . , λ nare not
necessarily distinct. there are matrices with identical eigenvalues, the identity matrix being
a trivial example. on the other hand, not all square matrices have eigenvectors. for example,
the matrix0 1
0 0
does not have an eigenvalue. matrices that have eigenvalues must be
diagonalizable .
295chapter 5. joint distributions
there are a number of equivalent conditions for λto be an eigenvalue:
• there exists u̸= 0 such that au=λu;
• there exists u̸= 0 such that ( a−λi)u=0;
• (a−λi) is not invertible;
• det(a−λi) = 0.
we are mostly interested in symmetric matrices. if ais symmetric, then all the eigen-
values are real, and the following result holds.
theorem 5.16. ifais symmetric, all the eigenvalues are real, and there exists u
such that utu=ianda=uλut. then

| | |
a1a2···an
| | |

| {z }
a=
| | |
u1u2···un
| | |

| {z }
u
λ1
λ2
...
λn

| {z }
λ
—ut
1—
—ut
2—
...
—ut
n —

| {z }
ut.
(5.39)
we call such a decomposition the eigendecomposition . in matlab, we can compute the
eigenvalues of a matrix by using the eigcommand. in python, the corresponding command
isnp.linalg.eig . note that in our demonstration below we symmetrize the matrix. this
step is needed, for otherwise the eigenvalues will contain complex numbers.
% matlab code to perform eigendecomposition
a = randn(100,100);
a = (a + a’)/2; % symmetrize because a is not symmetric
[u,s] = eig(a); % eigendecomposition
s = diag(s); % extract eigenvalue
# python code to perform eigendecomposition
import numpy as np
a = np.random.randn(100,100)
a = (a + np.transpose(a))/2
s, u = np.linalg.eig(a)
s = np.diag(s)
the condition that utu=iis the result of an orthonormal matrix. equivalently,
ut
iuj= 1 if i=jandut
iuj= 0 if i̸=j. since {ui}n
i=1is orthonormal, it can serve as a
basis of any vector in rn:
x=nx
j=1αjuj,
where αj=ut
jxis called the basis coefficient . basis vectors are useful in that they can
provide alternative representations of a vector.
2965.7. transformation of multidimensional gaussians
figure 5.18: the center and the radius of the ellipse is determined by µandς.
the geometry of the joint gaussian is determined by its eigenvalues and eigenvectors.
consider the eigendecomposition of σ:
σ=uλut
=
| | |
u1u2···ud
| | |

λ10··· 0
0λ2··· 0
............
0··· ··· λd

−ut
1−
−ut
2−
...
−ut
d−
,
for some unitary matrix uand diagonal matrix λ. the columns of uare called the eigen-
vectors, and the entries of λare called the eigenvalues. since σis symmetric, all λi’s are
real. in addition, since σis positive semi-definite, all λi’s are non-negative. accordingly, the
volume defined by the multidimensional gaussian is always a convex object, e.g., an ellipse
in 2d or an ellipsoid in 3d.
the orientation of the axes is defined by the column vectors ui. in the case of d= 2,
the major axis is defined by u1and the minor axis is defined by u2. the corresponding radii
of each axis are specified by the eigenvalues λ1andλ2.figure 5.18 provides an illustration.
5.7.3 covariance matrices are always positive semi-definite
the following subsection about positive semi-definite matrices can be skipped if it is your
first time reading the book.
now that we understand eigendecomposition, what can we do with it? here is one practical
problem. given a matrix σ, how do you know whether this σis valid? for example, if we
give you a singular matrix, then σ−1may not exist. checking the validity of σrequires the
concept of positive semi-definite .
given a square matrix a∈rn×n, it is important to check the positive semi-definiteness
ofa. there are two practical scenarios where we need positive semi-definiteness. (1) if
we are estimating the covariance matrix σfrom a dataset, we need to ensure that σ=
e[(x−µ)(x−µ)t] is positive semi-definite because all covariance matrices are positive
297chapter 5. joint distributions
semi-definite. otherwise, the matrix we estimate is not a legitimate covariance matrix. (2)
if we solve an optimization problem involving a function f(x) =xtax, then having a
being positive semi-definite, we can guarantee that the problem is convex. convex problems
ensure that a local minimum is also global, and convex problems can be solved efficiently
using known algorithms.
definition 5.24 (positive semi-definite ).a matrix a∈rn×nis positive semi-
definite if
xtax≥0 (5.40)
for any x∈rn.aispositive definite ifxtax>0for any x∈rn.
using eigendecomposition, it is not difficult to show that positive semi-definiteness is equiv-
alent to having non-negative eigenvalues.
theorem 5.17. a matrix a∈rn×nispositive semi-definite if and only if
λi(a)≥0 (5.41)
for all i= 1, . . . , n , where λi(a)denotes the ith eigenvalue of a.
proof . by the definitions of eigenvalue and eigenvector, we have that
aui=λiui,
where λiis the eigenvalue and uiis the corresponding eigenvector. if ais positive semi-
definite, then ut
iaui≥0 since uiis a particular vector in rn. so we have
0≤ut
iaui=λ∥ui∥2,
and hence λi≥0. conversely, if λi≥0 for all i, then since a=pn
i=1λiuiut
iwe can
conclude that
xtax=xt nx
i=1λiuiut
i!
x=nx
i=1λi(ut
ix)2≥0.
□
the following corollary shows that if a∈rn×nis positive definite, it must be invert-
ible. being invertible also means that the columns of aare linearly independent.
corollary 5.2. if a matrix a∈rn×nispositive definite (but not semi-definite),
thenamust be invertible, i.e., there exists a−1∈rn×nsuch that
a−1a=aa−1=i. (5.42)
the next theorem tells us that the covariance matrix is always positive semi-definite.
2985.7. transformation of multidimensional gaussians
theorem 5.18. the covariance matrix cov(x) =σissymmetric positive semi-
definite , i.e.,
σt=σ,and vtσv≥0,∀v∈rd.
proof . symmetry follows immediately from the definition, because cov( xi, xj) = cov( xj, xi).
the positive semi-definiteness comes from the fact that
vtσv=vte[(x−µ)(x−µ)t]v
=e[vt(x−µ)(x−µ)tv]
=e[btb] =e[∥b∥2]≥0,
where b= (x−µ)tv. □
end of the discussion.
5.7.4 gaussian whitening
besides checking positive semi-definiteness, another typical problem we encounter is how to
generate random samples according to some gaussian distributions.
from gaussian (0,i)to gaussian (µ,σ). if we are given zero-mean unit-variance gaus-
sianx∼gaussian( 0,i), how do we generate y∼gaussian( µ,σ) from x?
the idea is to define a transformation
y=σ1
2x+µ,
where σ1
2=uλ1
2ut. then the mean of yis
e[y] =e[σ1
2x+µ] =σ1
2e[x] +µ=σ1
20+µ=µ,
and the covariance matrix is
e[(y−µ)(y−µ)t] =e[(σ1
2x+µ−µ)(σ1
2x+µ−µ)t]
=e[(σ1
2x)(σ1
2x)t] =σ1
2e[xxt]σ1
2
=σ1
2iς1
2=σ.
the following theorem summarizes this result.
theorem 5.19. letxbex∼gaussian (0,i). consider a mean vector µand a
covariance matrix σwith eigendecomposition σ=uλut. if
y=σ1
2x+µ, (5.43)
where σ1
2=uλ1
2ut, then y∼gaussian (µ,σ).
299chapter 5. joint distributions
therefore, the two steps for doing this gaussian whitening are:
step 1: generate samples {x1, . . . ,xn}that are distributed according to gaussian( 0,i).
step 2: define ynwhere
yn=σ1
2xn+µ.
these two steps are portrayed in figure 5.19 .
figure 5.19: generating an arbitrary gaussian from gaussian (0,i).
example 5.26 . consider a set of n= 1000 i.i.d. gaussian( 0,i) data points as shown
infigure 5.20 , for example,
x1=0.5377
1.8399
,x2=−2.2588
0.8622
, . . . , x1000=0.3188
−1.3077
.
-5 -4 -3 -2 -1 0 1 2 3 4 5-5-4-3-2-1012345
-5 -4 -3 -2 -1 0 1 2 3 4 5-5-4-3-2-1012345
(a) before (b) after
figure 5.20: generating arbitrary gaussian random variables from gaussian (0,i).
transform these data points so that the new distribution is a gaussian with
µ=1
−2
and σ=3−0.5
−0.5 1
.
3005.7. transformation of multidimensional gaussians
solution . to perform the transformation, we first perform eigendecomposition of σ=
uλut. then σ1
2=uλ1
2ut. for our problem, we compute
σ1
2=1.722 −0.1848
−0.1848 0 .9828
.
multiplying this matrix to yield yn=σ1
2xn+µ, we obtain
y1=1.5870
−0.2971
,y2=−3.0495
−0.7351
, . . . , y1000=1.7907
−3.3441
.
in matlab, the above whitening procedure can be realized using the following com-
mands.
% matlab code to perform the whitening
x = mvnrnd([0,0],[1 0; 0 1],1000);
sigma = [3 -0.5; -0.5 1];
mu = [1; -2];
y = sigma^(0.5)*x’ + mu;
the python implementation is similar, although one needs to be careful with the
more complicated syntax. for example, sigma^(0.5) in matlab does the eigen-based
matrix power automatically, whereas in python we need to call a specific built-in command
fractional_matrix_power . in matlab, broadcasting a vector to a matrix can be rec-
ognized. in python, we need to call repmat explicitly to control the shape of the mean
vectors.
# python code to perform the whitening
import numpy as np
import scipy.stats as stats
from scipy.linalg import fractional_matrix_power
x = np.random.multivariate_normal([0,0],[[1,0],[0,1]],1000)
mu = np.array([1,-2])
sigma = np.array([[3, -0.5],[-0.5, 1]])
sigma2 = fractional_matrix_power(sigma,0.5)
y = np.dot(sigma2, x.t) + np.matlib.repmat(mu,1000,1).t
from gaussian (µ,σ)to gaussian (0,i). the reverse direction can be done as follows.
supposing that we have y∼gaussian( µ,σ), we define
x=σ−1
2(y−µ). (5.44)
then
e[x] =e[σ−1
2(y−µ)]
=σ−1
2(e[y]−µ) =0.
301chapter 5. joint distributions
the covariance is
cov(x) =e[(x−µx)(x−µx)t]
=e[xxt]
=eh
σ−1
2(y−µ)(y−µ)tς−t
2i
=σ−1
2e
(y−µ)(y−µ)t
σ−t
2
=σ−1
2σς−1
2=i.
the following theorem summarizes this result.
theorem 5.20. letybe a gaussian y∼gaussian (µ,σ). if
x=σ−1
2(y−µ), (5.45)
thenx∼gaussian (0,i).
thus the two steps of doing this reversed gaussian whitening are:
step 1: assuming that y1, . . . ,ynare distributed as gaussian( µ,σ), estimate µ
andς.
step 2: define xnwhere
xn=σ1
2(yn−µ). (5.46)
these two steps are shown pictorially in figure 5.21 .
figure 5.21: converting an arbitrary gaussian back to gaussian (0,i).
in practice, if we are given {yn}n
n=1, we need to estimate µandς. the estimations
are quite straightforward.
bµ=1
nnx
n=1yn,
bς=1
nnx
n=1(yn−bµ)(yn−bµ)t.
3025.8. principal-component analysis
on computers, these can be obtained using the command mean and cov. once we have
calculated bµandbς, we can define xnas
xn=bς−1
2(yn−bµ).
on computers, the codes for the whitening procedure that uses the estimated mean
and covariance are shown below.
% matlab code to perform whitening
y = mvnrnd([1; -2],[3 -0.5; -0.5 1],100);
my = mean(y);
covy = cov(y);
x = covy^(-0.5)*(y-my)’;
# python code to perform whitening
import numpy as np
import scipy.stats as stats
from scipy.linalg import fractional_matrix_power
y = np.random.multivariate_normal([1,-2],[[3,-0.5],[-0.5,1]],100)
my = np.mean(y,axis=0)
covy = np.cov(y,rowvar=false)
covy2 = fractional_matrix_power(covy,-0.5)
x = np.dot(covy2, (y-np.matlib.repmat(my,100,1)).t)
5.8 principal-component analysis
we have studied the covariance matrix σin some depth. it has many other uses besides
transforming gaussian random variables, and in this section we present one of them, called
theprincipal-component analysis (pca). pca is a widely used tool for dimension reduc-
tion. instead of using nfeatures to describe a data point, pca allows us to use the leading
pprincipal components to describe the same data point. in many problems in machine
learning, this makes the learning task easier and the inference task more efficient.
5.8.1 the main idea: eigendecomposition
pca can be summarized in one sentence:
the key idea of pca is the eigendecomposition of the covariance matrix σ.
this is a condensed summary of pca: it is just the eigendecomposition of the co-
variance. however, before we discuss the computational procedure, we will explain why we
would want to perform the eigendecomposition of the covariance matrix.
303chapter 5. joint distributions
consider a set of data points {x(1), . . . ,x(n)}, where each x(n)∈rdis ad-dimensional
vector. the dimension dis often high. for example, if we have an image of size 1024 ×1024×3,
then d= 3,145,728 — not a huge number, but enough to make you feel dizzy. the goal
of pca is to find a low-dimensional representation inrpwhere p≪d. if we can find
this low-dimensional representation, we can represent the d-dimensional input using only p
coefficients. since p≪d, we can “compress” the data by using a compact representation. in
modern data science, such a dimension reduction scheme is useful for handling large-scale
datasets.
mathematically, we define a set of basis vector v1, . . . ,vp, where each vi∈rd. our
goal is to approximate an input data point x(n)∈rdby these basis vectors:
x(n)≈px
i=1αivi,
where {αi}p
i=1are called the representation coefficients . the representation described by
this equation is a linear representation. linear representation is extremely common in prac-
tice. for example, a data point x(n)= [7,1,4]tcan be represented as

7
1
4

|{z}
x(n)= 3|{z}
α1
1
−1
0

|{z}
v1+ 4|{z}
α2
1
1
1

|{z}
v2.
therefore, the 3-dimensional input x(n)can now be represented by two coefficients α1= 3
andα2= 4. this is called dimensionality reduction .
pictorially, if we have already determined the basis vectors, we can compute the co-
efficients for every data point in the dataset. however, not all basis vectors are good. as
illustrated in figure 5.22 , an elongated dataset will be of the greatest benefit if the basis
vectors are oriented according to the data geometry. if we can find such basis vectors, then
the data points will have a large coefficient and a small coefficient, corresponding to the
major and the minor axes. dimensionality reduction can thus be achieved by, for example,
only keeping the larger coefficients.
figure 5.22: pca aims at finding a low-dimensional representation of a high-dimensional dataset. in
this figure, the 2d data points can be well represented by the 1d space spanned by v1.
the challenge here is that, given the dataset {x(1), . . . ,x(n)}, we need to determine
both the basis vectors {vi}p
i=1and the coefficients {αi}p
i=1. fortunately, this can be formu-
lated as an eigendecomposition problem.
3045.8. principal-component analysis
to see how this problem can be thus formulated, we consider the simplest case as
illustrated in figure 5.22 , where we want to find theleading principal component. that is,
we find ( α,v) such that x≈αv. this amounts to solving the optimization problem
(bv,bα) = argmin
∥v∥2=1,α
|
x
|
−α
|
v
|
2
.
the notation “argmin” means the argument that minimizes the function. the equation
says that we find the ( α,v) that minimizes the distance between xandαv. the constraint
∥v∥2= 1 limits the search to within a unit circle; otherwise our solution will not be unique.
solving the optimization problem is not difficult. if we take the derivative w.r.t. αand
set it to zero, we have that
2vt(x−αv) = 0 ⇒ α=vtx.
substituting α=xtvinto the objective function again, we show that
argmin
∥v∥2=1∥x−αv∥2= argmin
∥v∥2=1
xtx−2αxtv+α2vtv
,∥v∥2= 1
= argmin
∥v∥2=1
−2αxtv+α2
, dropxtx
= argmin
∥v∥2=1
−2(xtv)xtv+ (xtv)2
, substitute α=xtv
= argmax
∥v∥2=1
vtxxtv
, change min to max .
let us pause for a second. we have shown that if we have onedata point x, the leading
principal component vcan be determined by maximizing vtxxtv. what have we gained?
we have transformed the original optimization, which contains two variables ( v, α), to a new
optimization that contains one variable v. thus if we know how to solve the one-variable
problem we are done.
however, there is one more issue we need to address before we discuss how to solve
for the problem. the issue is that the formulation is about one data sample , not the entire
dataset. to include all the samples, we need to assume that xis a realization of a random
vector x. then the above optimization can be formulated in the expectation sense as
argmin
∥v∥2=1e∥x−αv∥2= argmax
∥v∥2=1vte
xxt
v
= argmax
∥v∥2=1vtσv,
where σdef=e[xtx].1therefore, if we can maximize vtσvwe will be able to determine
the principal component.
now comes the main result. the following theorem shows that the maximization is
equivalent to eigendecomposition. the proof requires lagrange multipliers, which are beyond
the scope of this book.
1here we assume that xis zero-mean, i.e., e[x] = 0. if it is not, then we can subtract the mean by
considering argmax
∥v∥2=1vte
(x−µ)(x−µ)t
v.
305chapter 5. joint distributions
theorem 5.21. letσbe ad×dmatrix with eigendecomposition σ=usut. then
the optimization
bv=argmax
∥v∥2=1vtσv (5.47)
has a solution bv=u1, i.e., the first column of the eigenvector matrix u.
the following proof requires an understanding of lagrange multipliers and constrained
optimizations. it is not essential for understanding this chapter.
we want to prove that the solution to the problem
bv= argmax
∥v∥2=1vtσv
is the eigenvector of the matrix σ. to show that, we first write down the lagrangian:
l(v, λ) =vtσv−λ(∥v∥2−1)
taking the derivative w.r.t. vand setting to zero yields
∇vl(v, λ) = 2σv−2λv=0.
this is equivalent to σv=λv. so if σ=usut, then by letting v=uiandλ=siwe can
satisfy the condition since σui=usutui=use i=siui.
end of the proof.
this theorem can be extended to the second (and other) principal components of
the covariance matrix. in fact, given the covariance matrix σwe can follow the procedure
outlined in figure 5.23 to determine the principal components. the eigendecomposition of a
d×dmatrix σwill give us a d×deigenvector matrix uand an eigenvalue matrix s. to keep
thepleading eigenvectors, we truncate the umatrix to only use the first peigenvectors. here,
we assume that the eigenvectors are ordered according to the magnitude of the eigenvalues,
from large to small.
in practice, if we are given a dataset {x(1), . . . ,x(n)}, we can first estimate the covari-
ance matrix σby
bς=1
nnx
n=1(x(n)−bµ)(x(n)−bµ)t,
where bµ=1
npn
n=1x(n)is the mean vector. afterwards, we can compute the eigendecom-
position of bσby
[u,s] = eig( bς).
on a computer, the principal components are obtained through eigendecomposition.
a matlab example and a python example are shown below. we explicitly show the two
principal components in this example. the magnitudes of these two vectors are determined
by the eigenvalues diag(s) .
3065.8. principal-component analysis
figure 5.23: the principal components are the eigenvectors of the covariance matrix. in this figure σ
denotes the covariance matrix, u1, . . . ,updenote the pleading eigenvectors, and sdenotes the diagonal
of the eigenvalue matrix.
% matlab code to perform the principal-component analysis
x = mvnrnd([0,0],[2 -1.9; -1.9 2],1000);
covx = cov(x);
[u,s] = eig(covx);
u(:,1) % principle components
u(:,2) % principle components
# python code to perform the principal-component analysis
import numpy as np
x = np.random.multivariate_normal([1,-2],[[3,-0.5],[-0.5,1]],1000)
covx = np.cov(x,rowvar=false)
s, u = np.linalg.eig(covx)
print(u)
example 5.27 . suppose we have a dataset containing n= 1000 samples, drawn from
an unknown distribution. the first few samples are
x1=0.5254
−0.6930
,x2=−0.4040
0.3724
, . . . , x1000=1.4165
−1.5463
.
we can compute the mean and covariance using matlab commands mean andcov.
this will return us
bµ=0.0561
−0.0303
andbς=2.0460 −1.9394
−1.9394 2 .0426
.
applying eigendecomposition on bς, we show that
[u,s] = eig( bς),
=⇒u=−0.7068 −0.7074
−0.7074 0 .7068
and s=0.1049 0
0 3 .9837
.
307chapter 5. joint distributions
therefore, we have obtained two principal components
u1=−0.7068
−0.7074
and u2=−0.7074
0.7068
.
as seen in the figure below, these two principal components make sense. the vector
u1is the orange line and is the minor axis. the vector u2is the blue line and is the
major axis. again, the ordering of the vectors is determined by the eigenvalues. since
u2has a larger eigenvalue (=3.9837), it is the leading principal component.
-5 -4 -3 -2 -1 0 1 2 3 4 5-5-4-3-2-1012345
figure 5.24: to determine the representation coefficients, we solve an inverse problem by finding the
vector αin the equation x(n)=upα(n).
why do we call our method principal component analysis ? the analysis part comes
from the fact that we can compress a data vector x(n)from a high dimension dto a low
dimension p. defining up= [u1, . . . ,up], a matrix containing the pleading eigenvectors of
the matrix u, we solve the inverse problem:
x(n)=upα(n),
where the goal is to determine the coefficient vector α(n)∈rp. since upis an orthonormal
matrix (i.e., ut
pup=i), it follows that
ut
px(n)=ut
pup|{z}
=iα(n),
3085.8. principal-component analysis
as illustrated in figure 5.24 . hence,
α(n)=ut
px(n).
this equation is a projection operation that projects a data point x(n)onto the space
spanned by the pleading principal components. repeating the procedure for all the data
points x(1), . . . ,x(n)in the dataset, we have compressed the dataset.
example 5.28 . using the example above, we can show that
α(1)=utx(1)=0.1189
−0.8615
,α(2)=0.0221
0.5491
, . . . , α(1000)=0.0927
−2.0950
.
the principal-component analysis says that since the leading components represent the
data, we only need to keep the blue-colored values because they are the coefficients
associated with the leading principal component.
5.8.2 the eigenface problem
as a concrete example of pca, we consider a computer vision problem called the eigen-
face problem. in 2001, researchers at yale university published the yale database, and
a few years later they extended it to a larger one ( http://vision.ucsd.edu/ ~leekc/
extyaledatabase/extyaleb.html ). the dataset, now known as the yale face dataset, con-
tains 16,128 images of 28 human subjects under nine poses and 64 illumination conditions.
the sizes of the images are d= 168 ×192 = 32,256 pixels. treating these n=16,128 images
as vectors in r32,256×1, we have 16,128 of these vectors. let us call them {x(1), . . . ,x(n)}.
following the procedure we described above, we estimate the covariance matrix by
computing
bς=e[(x−bµ)(x−bµ)t]≈1
nnx
n=1(x(n)−bµ)(x(n)−bµ)t, (5.48)
where bµ=e[x]≈1
npn
n=1x(n)is the mean vector. note that the size of bµis 32,256 ×1
and the size of bσis 32,256 ×32,256.
figure 5.25: the extended yale face database b.
once we obtain an estimate of the covariance matrix, we can perform an eigendecom-
position to get
[u,s] = eig( bς).
the columns of u, i.e.,{ui}d
i=1, are the eigenvectors of bς. these eigenvectors are the basis
of a testing face image.
309chapter 5. joint distributions
figure 5.26: given a face image, the learned basis vectors (from the eigendecomposition of the covari-
ance matrix) can be used to compress the image xinto a feature vector αwhere the dimension of αis
significantly lower than that of x.
with the basis vectors u1, . . . ,upwe can project every image in the dataset using a
low-dimensional representation. specifically, for an image xwe compute the coefficients
αi=ut
ix, i = 1, . . . , p
or more compactly α=utx. note that the dimension of xisd×1 (which in our case is
d= 32,526), and the dimensions of αcan be as few as p= 100. therefore, we are using a
100-dimensional vector to represent a 32,526-dimensional data. this is a huge dimensionality
reduction.
the process repeats for all the samples x(1), . . . ,x(n). this gives us a collection of rep-
resentation coefficients α(1), . . . ,α(n), where each α(n)is 100-dimensional (see figure 5.26 ).
notice that the basis vectors uiappear more or less “face images,” but they are the features
of the faces. pca says that a real face can be written as a linear combination of these basis
vectors.
how to solve the eigenface problem
compute the covariance matrix of all the images.
apply eigendecomposition to the covariance matrix.
project onto the basis vectors and find the coefficients.
the coefficients are the low-dimensional representation of the images.
we use the coefficients to perform downstream tasks, such as classification.
3105.8. principal-component analysis
5.8.3 what cannot be analyzed by pca?
pca is a dimension reduction tool. it compresses a raw data vector x∈rdinto a smaller
feature vector α∈rp. the advantage is that the downstream learning problems are much
easier because p≪d. for example, classification using αis more efficient than classification
using xsince there is very little information loss from xtoα.
there are three limitations of pca:
pcs fails when the raw data are not orthogonal . the basis vectors uireturned
by pca are orthogonal , meaning that ut
iuj= 0 as long as i̸=j. as a result, if
the data intrinsically have this orthogonality property, then pca will work very well.
however, if the data live in a space such as a donut shape as illustrated in figure 5.27 ,
then pca will fail. here, by failure, we mean that pis not much smaller than d. to
handle datasets behaving like figure 5.27 we need advanced tools. one of these is the
kernel-pca. the idea is to apply a nonlinear transformation to the data before you
run pca.
figure 5.27: [left] pca works when the data has redundant dimensions or is living on orthogonal
spaces. [right] pca fails when the data does not have easily decomposable spaces.
basis vectors returned by pca are not interpretable . a temptation with pca is to
think that the basis vectors uioffer meaningful information because they are the “prin-
cipal components”. however, since pca is the eigendecomposition of the covariance
matrix, which is purely a mathematical operation, there is no guarantee that the basis
vectors contain any semantic meaning. if we look at the basis vectors shown in fig-
ure 5.26 , there is almost no information one can draw. therefore, in the data-science
literature alternative methods such as non-negative matrix factorization and the more
recent deep neural network embedding are more attractive because the feature vectors
sometimes (not always) have meanings.
pca does not return you the most influential “component” . imagine that you
are analyzing medical data for research on a disease, in which each data vector x(n)
contains height, weight, bmi, blood pressure, etc. when you run pca on the dataset,
you will obtain some “principal components”. however, these principal components
will likely have everything, e.g., the height entry of the principal component will have
some values, the weight will have some values, etc. if you have found a principal
component, it does not mean that you have identified the leading risk factor of the
disease. if you want to identify the leading risk factor of the disease, e.g., whether
the height or weight is more important, you need to resort to advanced tools such as
variable selection or the lasso type of regression analysis (see chapter 7).
311chapter 5. joint distributions
closing remark . pcas are powerful computational tools based on the simplest concept of
covariance matrices because, as our derivation showed, covariance matrices encode the “vari-
ation” of the data. therefore, by finding a vector that aligns with the maximum variation
of the data, we can find the principal component.
5.9 summary
as you were reading this chapter, you may have felt that the first and second parts discuss
distinctly different subjects, and in fact many books treat them as separate topics. we take
a different approach. we think that they are essentially the same thing if you understand
the following chain of distributions:
fx(x)|{z}
one variable=⇒fx1,x2(x1, x2)|{z }
two variables=⇒ ··· =⇒fx1,...,x n(x1, . . . , x n)| {z }
nvariables.
the first part exclusively deals with two variables. the generalization from two variables to
nvariables is straightforward for pdfs and cdfs:
pdf: fx1,x2(x1, x2) =⇒fx1,...,x n(x1, . . . , x n).
cdf: fx1,x2(x1, x2) =⇒fx1,...,x n(x1, . . . , x n).
the joint expectation can also be generalized from two variables to nvariables:
var[x2
1] cov( x1, x2)
cov(x2, x1) var[ x2
2]
=⇒
var[x2
1]··· cov(x1, xn)
.........
cov(xn, x1)··· var[x2
n]
.
conditional pdfs and conditional expectations are powerful tools for decomposing
complex events into simpler events. specifically, the law of total expectation,
e[x] =z
e[x|y=y]fy(y)dy=ey[ex|y[x|y]],
is instrumental for evaluating variables defined through conditional relationships. the idea
is also extendable to more random variables, such as
e[x1] =z z
e[x1|x2=x2, x3=x3]fx2,x3(x2, x3)dx2dx3,
where e[x1|x2=x2, x3=x3] can be evaluated through
e[x1|x2=x2, x3=x3] =z
x1fx1|x2,x3(x1|x2, x3)dx1.
this type of chain relationship can generalize to other high-order cases.
it is important to remember that for any high-dimensional random variables, the char-
acterization is always made by the pdf fx(x) (or the cdf). we did not go into the details
3125.10. references
of analyzing fx(x) but have only discussed the mean vector e[x] =µand the covariance
matrix cov( x) =σ. we have been focusing exclusively on the high-dimensional gaussian
random variables
fx(x) =1p
(2π)d|σ|exp
−1
2(x−µ)tς(x−µ)
,
because they are ubiquitous in data science today. we discussed the linear transformations
from a zero-mean unit-variance gaussian to another gaussian, and vice versa.
5.10 references
joint distributions and correlation
5-1 dimitri p. bertsekas and john n. tsitsiklis, introduction to probability , athena sci-
entific, 2nd edition, 2008. chapters 2.5, 3.4, 4.2.
5-2 alberto leon-garcia, probability, statistics, and random processes for electrical en-
gineering , prentice hall, 3rd edition, 2008. chapters 5.1 – 5.6.
5-3 athanasios papoulis and s. unnikrishna pillai, probability, random variables and
stochastic processes , mcgraw-hill, 4th edition, 2001. chapters 6.1 – 6.4.
5-4 john a. gubner, probability and random processes for electrical and computer en-
gineers , cambridge university press, 2006. chapters 7.1 – 7.2.
5-5 sheldon ross, a first course in probability , prentice hall, 8th edition, 2010. chapters
6.1 – 6.3.
5-6 henry stark and john woods, probability and random processes with applications
to signal processing , prentice hall, 3rd edition, 2001. chapter 2.6.
conditional distributions and expectations
5-7 dimitri p. bertsekas and john n. tsitsiklis, introduction to probability , athena sci-
entific, 2nd edition, 2008. chapters 2.6, 3.5, 3.6, 4.3.
5-8 alberto leon-garcia, probability, statistics, and random processes for electrical en-
gineering , prentice hall, 3rd edition, 2008. chapter 5.7.
5-9 athanasios papoulis and s. unnikrishna pillai, probability, random variables and
stochastic processes , mcgraw-hill, 4th edition, 2001. chapters 6.6 – 6.7.
5-10 john a. gubner, probability and random processes for electrical and computer en-
gineers , cambridge university press, 2006. chapters 7.3 – 7.5.
5-11 sheldon ross, a first course in probability , prentice hall, 8th edition, 2010. chapters
7.5 – 7.6.
5-12 henry stark and john woods, probability and random processes with applications
to signal processing , prentice hall, 3rd edition, 2001. chapter 4.2.
313chapter 5. joint distributions
sum of random variables
5-13 dimitri p. bertsekas and john n. tsitsiklis, introduction to probability , athena sci-
entific, 2nd edition, 2008. chapter 4.5.
5-14 alberto leon-garcia, probability, statistics, and random processes for electrical en-
gineering , prentice hall, 3rd edition, 2008. chapter 7.1.
5-15 henry stark and john woods, probability and random processes with applications
to signal processing , prentice hall, 3rd edition, 2001. chapters 3.3 and 3.4.
vector random variables
5-16 alberto leon-garcia, probability, statistics, and random processes for electrical en-
gineering , prentice hall, 3rd edition, 2008. chapters 6.1 – 6.6.
5-17 john a. gubner, probability and random processes for electrical and computer en-
gineers , cambridge university press, 2006. chapters 8.1 – 8.3, 9.
5-18 henry stark and john woods, probability and random processes with applications
to signal processing , prentice hall, 3rd edition, 2001. chapters 5.1 – 5.6.
principal-component analysis
pca is often taught in machine learning courses. for first-time readers, we suggest reviewing
the linear algebraic tools in moon and stirling. then, the tutorial by shlens and the chapter
in bishop would be sufficient to cover most of the materials. more advanced topics, such as
kernel pca, can be found in the following references.
5-19 todd k. moon and wynn c. stirling, mathematical methods and algorithms for signal
processing , prentice-hall, 2000. chapter 7.
5-20 christopher bishop, pattern recognition and machine leanring , springer, 2006. chap-
ter 12.
5-21 jonathon shlens (2014) “a tutorial on principal component analysis”, https://
arxiv.org/pdf/1404.1100.pdf
5-22 paul honeine (2014), “an eigenanalysis of data centering in machine learning”, https:
//arxiv.org/pdf/1407.2904.pdf
5-23 quan wang (2012), “kernel principal component analysis and its applications”,
https://arxiv.org/abs/1207.3538
5-24 sch¨ olkopf et al. (2005), “kernel principal component analysis”, https://link.springer.
com/chapter/10.1007/bfb0020217
5.11 problems
exercise 1. (video solution)
alex and bob each flips a fair coin twice. use “1” to denote heads and “0” to denote tails.
letxbe the maximum of the two numbers alex gets, and let ybe the minimum of the
two numbers bob gets.
3145.11. problems
(a) find and sketch the joint pmf px,y(x, y).
(b) find the marginal pmf px(x) and py(y).
(c) find the conditional pmf px|y(x|y). does px|y(x|y) =px(x)? why or why not?
exercise 2.
two fair dice are rolled. find the joint pmf of xandywhen
(a)xis the larger value rolled, and yis the sum of the two values.
(b)xis the smaller, and yis the larger value rolled.
exercise 3.
the amplitudes of two signals xandyhave joint pdf
fxy(x, y) =e−x/2ye−y2
forx >0, y > 0.
(a) find the joint cdf.
(b) find p(x1/2> y).
(c) find the marginal pdfs.
exercise 4. (video solution)
find the marginal cdfs fx(x) and fy(y) and determine whether or not xandyare
independent, if
fxy(x, y) =

x−1−e−y−e−xy
y,if 1≤x≤2, y≥0
1−e−y−e−2y
y, ifx >2, y≥0,
0, otherwise .
exercise 5. (video solution)
(a) find the marginal pdf fx(x) if
fxy(x, y) =exp{−|y−x| −x2/2}
2√
2π.
(b) find the marginal pdf fy(y) if
fxy(x, y) =4e−(x−y)2/2
y2√
2π.
315chapter 5. joint distributions
exercise 6. (video solution)
letx, y be two random variables with joint cdf
fx,y(x, y) =y+e−x(y+1)
y+ 1.
show that
∂2
∂x∂yfx,y(x, y) =∂2
∂y∂xfx,y(x, y).
what is the implication of this result?
exercise 7. (video solution)
letxandybe two random variables with joint pdf
fx,y(x, y) =1
2πe−1
2(x2+y2).
(a) find the pdf of z= max( x, y).
(b) find the pdf of z= min( x, y).
you may leave your answers in terms of the φ( ·) function.
exercise 8.
the random vector ( x, y) has a joint pdf
fxy(x, y) = 2 e−xe−2y
forx >0, y > 0. find the probability of the following events:
(a){x+y≤8}.
(b){x−y≤10}.
(c){x2< y}.
exercise 9.
letxandybe zero-mean, unit-variance independent gaussian random variables. find the
value of rfor which the probability that ( x, y) falls inside a circle of radius ris 1/2.
exercise 10.
the input xto a communication channel is +1 or −1 with probabilities pand 1 −p,
respectively. the received signal yis the sum of xand noise n, which has a gaussian
distribution with zero mean and variance σ2= 0.25.
(a) find the joint probability p(x=j, y≤y).
(b) find the marginal pmf of xand the marginal pdf of y.
(c) suppose we are given that y >0. which is more likely, x= 1 or x=−1?
3165.11. problems
exercise 11. (video solution)
let
fx,y(x, y) =(
ce−xe−y,if 0≤y≤x <∞,
0,otherwise .
(a) find c.
(b) find fx(x) and fy(y).
(c) find e[x] ande[y], var[ x] and var[ y].
(d) find e[xy], cov( x, y) and ρ.
exercise 12. (video solution)
in class, we have used the cauchy-schwarz inequality to show that −1≤ρ≤1. this exercise
asks you to prove the cauchy-schwarz inequality:
(e[xy])2≤e[x2]e[y2].
hint: consider the expectation e[(tx+y)2]. note that this is a quadratic equation in tand
e[(tx+y)2]≥0 for all t. consider the discriminant of this quadratic equation.
exercise 13. (video solution)
let θ ∼uniform[0 ,2π].
(a) if x= cos θ, y= sin θ. are xandyuncorrelated?
(b) if x= cos(θ /4),y= sin(θ /4). are xandyuncorrelated?
exercise 14. (video solution)
letxandyhave a joint pdf
fx,y(x, y) =c(x+y),
for 0≤x≤1 and 0 ≤y≤1.
(a) find c,fx(x),fy(y), and e[y].
(b) find fy|x(y|x).
(c) find p[y > x |x > 1/2].
(d) find e[y|x=x].
(e) find e[e[y|x]], and compare with the e[y] computed in (a).
exercise 15. (video solution)
use the law of total expectation to compute the following:
317chapter 5. joint distributions
1.e[sin(x+y)], where x∼ n(0,1), and y|x∼uniform[ x−π, x+π]
2.p[y < y ], where x∼uniform[0 ,1], and y|x∼exponential( x)
3.e[xey], where x∼uniform[ −1,1], and y|x∼ n(0, x2)
exercise 16.
lety=x+n, where xis the input, nis the noise, and yis the output of a system. assume
that xandnare independent random variables. it is given that e[x] = 0, var[ x] =σ2
x,
e[n] = 0, and var[ n] =σ2
n.
(a) find the correlation coefficient ρbetween the input xand the output y.
(b) suppose we estimate the input xby a linear function g(y) =ay. find the value of
athat minimizes the mean squared error e[(x−ay)2].
(c) express the resulting mean squared error in terms of η=σ2
x/σ2
n.
exercise 17. (video solution)
two independent random variables xandyhave pdfs
fx(x) =(
e−x, x ≥0,
0, x < 0,fy(y) =(
0, y > 0,
ey, y ≤0.
find the pdf of z=x−y.
exercise 18.
letxandybe two independent random variables with densities
fx(x) =(
xe−x, x ≥0,
0, x < 0,and fy(y) =(
ye−y, y ≥0,
0, y < 0.
find the pdf of z=x+y.
exercise 19.
the random variables xandyhave the joint pdf
fxy(x, y) =e−(x+y)
for 0 < y < x < 1. find the pdf of z=x+y.
exercise 20.
the joint density function of xandyis given by
fxy(x, y) =e−(x+y)
forx >0, y > 0. find the pdf of the random variable z=x/y .
318chapter 6
sample statistics
when we think about probability, the first thing that likely comes to mind is flipping a coin,
throwing a die, or playing a card game. these are excellent examples of the subject. however,
they seldom fit in the context of modern data science, which is concerned with drawing
conclusions from data. in our opinion, the power of probability is its ability to summarize
microstates using macro descriptions . this statement will take us some effort to elaborate.
we study probability because we want to analyze the uncertainties. however, when we
have many data points, analyzing the uncertainties of each data point (the microstates)
is computationally very difficult. probability is useful here because it allows us to bypass
the microstates and summarize the macro behavior. instead of reporting the states of each
individual, we report their sample average. instead of offering the worst-case guarantee,
we offer a probabilistic guarantee. you ask: so what? if we can offer you a performance
guarantee at 99.99% confidence but one-tenth of the cost of a 100% performance guarantee,
would you consider our offer? the goal of this chapter is to outline the concepts of these
probabilistic arguments.
the significance of sample average
imagine that you have a box containing many tiny magnets. (you can also think of a dataset
containing two classes of labels.) in condensed matter physics, these are known as the spin
glasses . the orientations of the magnets depend on the magnetic field. under an extreme
condition where the magnetic field is strong, all magnets will point in the same direction.
when the magnetic field is not as strong, some will align with the field but some will not,
as we show in figure 6.1 .
if we try to study every single magnet in this box, the correlation of the magnets will
force us to consider a joint distribution, since if one magnet points to the right it is likely
that another magnet will also point to the right. the simultaneous description of all magnets
is modeled through a joint probability distribution
fx1,x2,...,x n(x1, x2, . . . , x n).
like any joint pdf, this pdf tells us the probability density that the magnets will take
a collection of states simultaneously. if nis large (say, on the order of millions), this joint
distribution will be very complicated.
319chapter 6. sample statistics
figure 6.1: imagine that we have a box of magnets and we want to measure their orientation angles.
the data points have individual randomness and correlations. studying each one individually could be
computationally infeasible, as we need to estimate the joint pdf fx1,...,x n(x1, . . . , x n)across all the
data points. probability offers a tool to summarize these individual states using a macro description.
for example, we can analyze the sample average xnof the data points and derive conclusions from
the pdf of xn, i.e., fxn(x). the objective of this chapter is to present a few probabilistic tools to
analyze macro descriptions, such as the sample average.
since the joint pdf is very difficult to obtain computationally, physicists proposed
to study the sample statistics. instead of looking at the individual states, they look at the
sample average of the states. if we define x1, . . . , x nas the states of the magnets, then
the sample average is
xn=1
nnx
n=1xn.
since each magnet is random, the sample average is also random, and therefore it is granted
a pdf:
fxn(x).
thus, xnhas a pdf, a mean, a variance, and so on.
we call xna sample statistic. it is called a statistic because it is a summary of the
microstates, and a sample statistic because the statistic is based on random samples, not on
the underlying theoretical distributions. we are interested in knowing the behavior of xn
because it is the summary of the observations. if we know the pdf of xn, we will know
the mean, the variance, and the value of xnwhen the magnetic field increases or decreases.
why study the sample average xn?
analyzing individual variables is not feasible because the joint pdf can be ex-
tremely high-dimensional.
sample average is a macro description of the data.
if you know the behavior of the sample average, you know most of the data.
probabilistic guarantee versus worst-case guarantee
besides the sample average, we are also interested in the difference between a probabilistic
guarantee and a deterministic guarantee.
320consider the birthday paradox (see chapter 1 for details). suppose there are 50 stu-
dents in a room. what is the probability that at least two students have the same birthday?
a naive thought would suggest that we need 366 students to guarantee a pair of the same
birthday because there are 365 days. so, with only 50 students, it would seem unlikely to
have a pair with the same birthday. however, it turns out that with just 50 students, the
probability of having at least one pair with the same birthday is more than 97%. figure 6.2
below shows a calculation by a computer, where we plot the estimated probability as a func-
tion of the number of students. what is more surprising is that with as few as 23 students,
the probability is greater than 50%. there is no need for there to be 365 students in order
to offer a guarantee.
0 10 20 30 40 50 60 70 80 90 100
number of people00.10.20.30.40.50.60.70.80.91probability
figure 6.2: the birthday paradox asks the question of how many people we need to ask in order to have
at least two of them having the same birthday. while we tend to think that the answer is 366 (because
there are 365 days), the actual probability, as we have calculated (see chapter 1), is more than 97%,
even if we have only asked 50 people. the curve above shows the probability of having at least one pair
of people having the same birthday as a function of the number of people. the plot highlights the gap
between the worst-case performance and an average-case performance.
why does this happen? certainly, we can trace back to the formulae in chapter 1 and
argue through the lens of combinations and permutations. however, the more important
message is about the difference between the worst-case guarantee and the average-case
guarantee .
worst case versus average case
worst-case guarantee: you need to ensure that the worst one is protected. this
requires an exhaustive search until hitting 100%. it is a deterministic guarantee.
average-case guarantee: you guarantee that with a high probability (e.g., 99.99%),
the undesirable event does not happen. this is a probabilistic guarantee.
is there a difference between 99.99% and 100%? if the probability is 99.99%, there is
one failure every 10,000 trials on average. you are unlikely to fail, but it is still possible.
a 100% guarantee says that no matter how many trials you make you will not fail. the
99.99% guarantee is much weaker (yes, much weaker, not just a little bit weaker) than the
deterministic guarantee. however, in practice, people might be willing to pay for the risk in
exchange for efficiency. this is the principle behind insurance. automobile manufacturing
321chapter 6. sample statistics
also uses this principle — your chance of purchasing a defective car is non-zero, but if the
manufacturer can sell enough cars to compensate for the maintenance cost of fixing your
car, they might be willing to offer a limited warranty in exchange for a lower selling price.
how do we analyze the probabilistic guarantee, e.g., for the sample average? remember
that the sample average xnis a random variable. since it is a random variable, it has a
mean, variance, and pdf.1to measure the probabilistic guarantee, we consider the event
bdef={|xn−µ| ≥ϵ},
where µ=e[xn] is the true population mean, and ϵ >0 is a very small number. this
probability is illustrated in figure 6.3 , assuming that xnhas the pdf of a gaussian. the
probability of bis the two tails under the pdf. therefore, bis abadevent because in
principle xnshould be close to µ. the probability p[b] measures situations where xn
stays very far from µ. if we can show that p[b] is small (e.g., <0.01%), then we can say
that we have obtained a probabilistic guarantee at 99.99%.
figure 6.3: the probabilistic guarantee of a sample average xnis established by computing the
probability of the tails. in this example, we assume that fxn(x)take a gaussian shape, and we define
ϵ= 1. anything belonging to |xn−µ| ≥ϵis called a undesired event b. if the probability of a
undesired event is small, we say that we can offer a probabilistic guarantee.
the moment we compute p[|xn−µ| ≥ϵ], we enter the race of probabilistic guarantee
(e.g., 99.99%). why? if the probability p[|xn−µ| ≥ϵ] is less than 0.01%, it still does not
exclude the possibility that something bad will happen once every 10,000 trials on average.
the chance is low, but it is still possible. we will learn some mathematical tools for analyzing
this type of probabilistic guarantee.
plan for this chapter
with these two main themes in mind, we now discuss the organization of this chapter. there
are four sections: two for mathematical tools and two for main results.
moment-generating functions : we have seen in chapter 5 that the pdf of a sum of
two random variables x+yis the convolution of the two pdfs fx∗fy. convolutions
are non-trivial, especially when we have more random variables to sum. the moment-
generating functions provide a convenient way of summing nrandom variables. they
are the transform domain techniques (e.g., fourier transforms). since convolutions in
1not all random variables have mean and variance, e.g., a cauchy random variable, but most of them
do.
322time are multiplications in frequency, the moment-generating functions allow us to
multiply pdfs in the transformed space. in this way, we can sum as many random
variables as we want. we will discuss this idea in section 6.1.
key concept 1: why study moment-generating functions?
moment-generating functions help us determine the pdf of x1+x2+···+xn.
probability inequalities : when analyzing sample statistics such as xn, evaluating the
exact probability could be difficult because it requires integrating the pdfs. however,
if our ultimate goal is to estimate the probability, deriving an upper bound might be
sufficient to achieve the goal. the probability inequalities are designed for this purpose.
in section 6.2, we discuss several of the most basic probability inequalities. we will
use some of them to prove the law of large numbers.
key concept 2: how can probability inequalities be useful?
probability inequalities help us upper-bound the bad event p[|xn−µ| ≥ϵ].
law of large numbers : this is the first main result of the chapter. the law of large
numbers says that the sample average xnconverges to the population mean µwhen
the number of samples grows to infinity. the law of large numbers comes in two
versions: the weak law of large numbers and the strong law of large numbers. the
difference is the type of convergence they guarantee. the weak law is based on con-
vergence in probability , whereas the strong law is based on almost sure convergence .
we will discuss these types of convergence in section 6.3.
key concept 3: what is the law of large numbers?
there is a weak law and a strong law of large numbers. the weak law of large
numbers says that xnconverges to the true mean µ, asngrows:
lim
n→∞p[|xn−µ|> ϵ] = 0.
central limit theorem : the central limit theorem says that the probability of
xncan be approximated by the probability of a gaussian. you can also think of
this as saying that the pdf of xnis converging to a distribution that can be well
approximated by a bell-shaped gaussian. if we have many random variables and their
sum is becoming a gaussian, we can ignore the individual pdfs and focus on the
gaussian. thus it explains why gaussian is so popular. we will discuss this theorem
in detail in section 6.4.
key concept 4: what is the central limit theorem?
the cdf of xncan be approximated by the cdf of a gaussian, as ngrows.
323chapter 6. sample statistics
6.1 moment-generating and characteristic functions
consider two independent random variables xandywith pdfs fx(x) and fy(y), respec-
tively. let z=x+ybe the sum of the two random variables. we know from chapter 5
that the pdf of z,fz, is the convolution of fxandfy. however, we think you will agree
that convolutions are not easy to compute. especially when the sum involves more random
variables, computing the convolution would be tedious. so how should we proceed in this
case? one approach is to use some kind of “frequency domain” method that transforms
the pdfs to another domain and then perform multiplication instead of the convolution
to make the calculations easy or at least easier. the moment-generating functions and the
characteristic functions are designed for this purpose.
6.1.1 moment-generating function
definition 6.1. for any random variable x, themoment-generating function (mgf)
mx(s)is
mx(s) =e
esx
. (6.1)
the definition says that the moment-generating function (mgf) is the expectation of the
random variable taken to the power esxfor some s. effectively, it is the expectation of a
function of random variables. the meaning of the expectation can be seen by writing out
the definition. for the discrete case, the mgf is
mx(s) =x
x∈ωesxpx(x), (6.2)
whereas in the continuous case, the mgf is
mx(s) =z∞
−∞esxfx(x)dx. (6.3)
the continuous case should remind us of the definition of a laplace transform. for any
function f(t), the laplace transform is
l[f](s) =z∞
−∞f(t)estdt.
from this perspective, we can interpret the mgf as the laplace transform of the pdf.
the argument sof the output can be regarded as the coordinate in the laplace space. if
s=−jω, then mx(jω) becomes the fourier transform of the pdf.
example 6.1 . consider a random variable xwith three states 0 ,1,2 and with prob-
ability masses2
6,3
6,1
6respectively. find the mgf.
3246.1. moment-generating and characteristic functions
solution . the moment-generating function is
mx(s) =e[esx] =es0·2
6+es1·3
6+es2·1
6
=1
3+es
2+e2s
6.
practice exercise 6.1 . find the mgf for a poisson random variable.
solution . the mgf of poisson random variable can be found as
mx(s) =e[esx] =∞x
x=0esxλxe−λ
x!=∞x
x=0(λes)x
x!e−λ=eλese−λ.
practice exercise 6.2 . find the mgf for an exponential random variable.
solution . the mgf of an exponential random variable can be found as
mx(s) =e[esx] =z∞
0esxλe−λxdx=z∞
0λe(s−λ)xdx=λ
λ−s, ifλ > s.
why are moment-generating functions so called? the following theorem reveals the
reason.
theorem 6.1. the mgf has the properties that
mx(0) = 1 ,
d
dsmx(s)|s=0=e[x],d2
ds2mx(s)|s=0=e[x2],
dk
dskmx(s)|s=0=e[xk], for any positive integer k.
proof . the first property can be proved by noting that
mx(0) =e[e0x] =e[1] = 1 .
the third property holds because
dk
dskmx(s) =z∞
−∞dk
dskesxfx(x)dx=z∞
−∞xkesxfx(x)dx.
setting s= 0 yields
dk
dskmx(s)|s=0=z∞
−∞xkfx(x)dx=e[xk].
the second property is a special case of the third property.
□
325chapter 6. sample statistics
the theorem tells us that if we take the derivative of the mgf and set s= 0, we will
obtain the moment. the order of the moment depends on the order of the derivative. as a
result, the mgf can “generate moments” by taking derivatives. this happens because of
the exponential function esx. sinced
dsesx=xesx, the variable xappears whenever we take
the derivative.
practice exercise 6.3 . let xbe a bernoulli random variable with parameter p.
find the first two moments using mgf.
solution . the mgf of a bernoulli random variable is
mx(s) =e[esx]
=es0px(0) + es1px(1)
= (1)(1 −p) + (es)(p)
= 1−p+pes.
the first and the second moment, using the derivative approach, are
e[x] =d
dsmx(s)
s=0=d
ds
1−p+pes
s=0=pes
s=0=p,
e[x2] =d2
ds2mx(s)
s=0=d2
ds2
1−p+pes
s=0=pes
s=0=p.
to facilitate our discussions of mgf, we summarize a few mgfs in the table below.
distribution pmf / pdf e[x] var[ x] mx(s)
bernoulli px(1) = pandpx(0) = 1 −p p p (1−p) 1 −p+pes
binomial px(k) = n
k
pk(1−p)n−knp np (1−p) (1 −p+pes)n
geometric px(k) =p(1−p)k−11
p1−p
p2pes
1−(1−p)es
poisson px(k) =λke−λ
k!λ λ eλ(es−1)
gaussian fx(x) =1√
2πσ2exp
−(x−µ)2
2σ2
µ σ2exp
µs+σ2s2
2
exponential fx(x) =λexp{−λx}1
λ1
λ2λ
λ−s
uniform fx(x) =1
b−aa+b
2(b−a)2
12esb−esa
s(b−a)
table 6.1: moment-generating functions of common random variables.
3266.1. moment-generating and characteristic functions
6.1.2 sum of independent variables via mgf
mgfs are most useful when analyzing the pdf of a sum of two random variables. the
following theorem highlights the result.
theorem 6.2. letxandybe independent random variables. let z=x+y. then
mz(s) =mx(s)my(s). (6.4)
proof . by the definition of mgf, we have that
mz(s) =eh
es(x+y)i(a)=e
esx
e
esy
=mx(s)my(s),
where (a) is valid because xandyare independent.
□
corollary 6.1. consider independent random variables x1, . . . , x n. let z=pn
n=1xn
be the sum of random variables. then the mgf of zis
mz(s) =ny
n=1mxn(s). (6.5)
if these random variables are further assumed to be identically distributed, the mgf is
mz(s) = (mx1(s))n. (6.6)
proof . this follows immediately from the previous theorem:
mz(s) =e[es(x1+···+xn)] =e[esx1]e[esx2]···e[esxn] =ny
n=1mxn(s).
if the random variables x1, . . . , x nare i.i.d., then the product simplifies to
ny
n=1mxn(s) =ny
n=1mx1(s) = (mx1(s))n.
□
theorem 6.3 (sum of bernoulli = binomial ).letx1, . . . , xnbe a sequence of
i.i.d. bernoulli random variables with parameter p. let z=x1+···+xnbe the sum.
then zis a binomial random variable with parameters (n, p).
proof . let us consider a sequence of i.i.d. bernoulli random variables xn∼bernoulli( p)
forn= 1, . . . , n . let z=x1+···+xn. the moment-generating function of zis
mz(s) =e[es(x1+···+xn)] =ny
n=1e[esxn]
=ny
n=1 
pes1+ (1−p)es0
= (pes+ (1−p))n.
327chapter 6. sample statistics
now, let us check the moment-generating function of a binomial random variable: if z∼
binomial( n, p), then
mz(s) =e[esz] =nx
n=0eskn
k
pk(1−p)n−k
=nx
n=0n
k
(pes)k(1−p)n−k= (pes+ (1−p))n,
where the last equality holds becausepn
n=0 n
k
akbn−k= (a+b)n. therefore, the two
moment-generating functions are identical. □
theorem 6.4 (sum of binomial = binomial ).letx1, . . . , xnbe a sequence of
i.i.d. binomial random variables with parameters (n, p). let z=x1+···+xnbe the
sum. then zis a binomial random variable with parameters (nn, p ).
proof . the mgf of a binomial random variable is
mxi(s) = (pes+ (1−p))n.
if we have nof these random variables, then z=x1+···+xnwill have the mgf
mz(s) =ny
i=1mxi(s) = (pes+ (1−p))nn.
note that this is just the mgf of another binomial random variable with parameter ( nn, p ).
□
theorem 6.5 (sum of poisson = poisson ).letx1, . . . , xnbe a sequence of
i.i.d. poisson random variables with parameter λ. let z=x1+···+xnbe the sum.
then zis a poisson random variable with parameters nλ.
proof . the mgf of a poisson random variable is
mx(s) =e[esx] =∞x
k=0eskλk
k!e−λ
=e−λ∞x
k=0(λes)k
k!
=e−λeλes=eλ(es−1).
assume that we have a sum of ni.i.d. poisson random variables. then, by the main theorem,
we have that
mz(s) = [mx(s)]n=enλ(es−1).
therefore, the resulting random variable zis a poisson with parameter nλ. □
3286.1. moment-generating and characteristic functions
theorem 6.6 (sum of gaussian = gaussian ).letx1, . . . , xnbe a sequence of
independent gaussian random variables with parameters (µ1, σ2
1), . . . , (µn, σ2
n). let
z=x1+···+xnbe the sum. then zis a gaussian random variable:
z=gaussiannx
n=1µn,nx
n=1σ2
n
. (6.7)
proof . we skip the proof of the mgf of a gaussian. it can be shown that
mx(s) = exp
µs+σ2s2
2
.
when we have a sequence of gaussian random variables, then
mz(s) =e[es(x1+···+xn)]
=mx1(s)···mxn(s)
=
exp
µ1s+σ2
1s2
2
···
exp
µns+σ2
ns2
2
= exp( nx
n=1µn!
s+ nx
n=1σ2
n!
s2
2)
.
therefore, the resulting random variable zis also a gaussian. the mean and variance of z
arepn
n=1µnandpn
n=1σ2
n, respectively.
□
6.1.3 characteristic functions
moment-generating functions are the laplace transforms of the pdfs. however, since the
laplace transform is defined on the entire right half-plane, not all pdfs can be transformed.
one way to mitigate this problem is to restrict sto the imaginary axis, s=jω. this will
give us the characteristic function .
definition 6.2 (usual definition) .thecharacteristic function of a random variable
xis
φx(jω) =e[ejωx]. (6.8)
however, we note that since ωcan take any value in ( −∞,∞), it does not matter if we
consider e[e−jωx] ore[ejωx]. this leads to the following equivalent definition of the char-
acteristic function:
definition 6.3 (alternative definition (for this book)) .thecharacteristic function
of a random variable xis
φx(jω) =e[e−jωx]. (6.9)
329chapter 6. sample statistics
if we follow this definition, we see that the characteristic function can be written as
φx(jω) =e[e−jωx] =z∞
−∞e−jωxfx(x)dx. (6.10)
this is exactly the fourier transform of the pdf. the reason for introducing this alternative
characteristic function is that e[e−jωx] is the fourier transform of fx(x) bute[ejωx] is the
inverse fourier transform of fx(x). the former is more convenient (in terms of notation)
for students who have taken a course in signals and systems. however, we should stress that
the usual way of defining the characteristic function is e[ejωx].
a list of common fourier transforms is shown in the table below. additional identities
can be found in standard signals and systems textbooks.
fourier transforms
f(t)←→f(ω) f(t)←→f(ω)
1.e−atu(t)←→1
a+jω,a >0 10. sinc2(wt
2)←→2π
w∆(ω
2w)
2.eatu(−t)←→1
a−jω,a >0 11. e−atsin(ω0t)u(t)←→ω0
(a+jω)2+ω2
0
3.e−a|t|←→2a
a2+ω2,a >0 12. e−atcos(ω0t)u(t)←→a+jω
(a+jω)2+ω2
0
4.a2
a2+t2←→πae−a|ω|,a >0 13. e−t2
2σ2←→√
2πσe−σ2ω2
2
5.te−atu(t)←→1
(a+jω)2,a >0 14. δ(t)←→1
6.tne−atu(t)←→n!
(a+jω)n+1,a >0 15. 1 ←→2πδ(ω)
7.rect(t
τ)←→τsinc(ωτ
2) 16. δ(t−t0)←→e−jωt0
8. sinc( wt)←→π
wrect(w
2w) 17. ejω0t←→2πδ(ω−ω0)
9.∆(t
τ)←→τ
2sinc2(ωτ
4) 18. f(t)ejω0t←→f(ω−ω0)
table 6.2: fourier transform pairs of commonly used functions.
example 6.2 . let xbe a random variable with pdf fx(x) =λe−λxforx≥0. find
the characteristic function.
solution . the fourier transform pair is
λe−λx−→λ· f
e−λx
=λ·1
λ+jω.
therefore, the characteristic function is φ x(jω) =λ
λ+jω.
3306.1. moment-generating and characteristic functions
example 6.3 . let xandybe independent, and let
fx(x) =(
λe−λx, x ≥0,
0, x < 0,fy(y) =(
λe−λy, y ≥0,
0, y < 0.
find the pdf of z=x+y.
solution . the characteristic function of xandycan be found from the fourier table:
φx(jω) =λ
λ+jωand φ y(jω) =λ
λ+jω.
therefore, the characteristic function of zis
φz(jω) = φ x(jω)φy(jω) =λ2
(λ+jω)2.
by inverse fourier transform, we have that
fz(z) =f−1λ2
(λ+jω)2
=λ2ze−λz, z≥0.
why φx(jω)but not mx(s)?as we said, the function is not always defined. recall
that the expectation e[x] exists only when fx(x) is absolutely integrable, or e[|x|]<∞.
for a characteristic function, the expectation is valid because e[|ejωx|] =e[1] = 1. however,
for a function, e[|esx|] could be unbounded. to see a counterexample, we consider the
cauchy distribution.
theorem 6.7. consider the cauchy distribution with pdf
fx(x) =1
π(x2+ 1). (6.11)
the mgf of xis undefined but the characteristic function is well defined.
proof . the mgf is
mx(s) =z∞
−∞esx 1
π(x2+ 1)dx≥z∞
1esx 1
π(x2+ 1)dx
≥z∞
1(sx)3
6π(x2+ 1)dx, because esx≥(sx)3
6
≥z∞
1(sx)3
6π(2x2)dx=s3
12πz∞
1x dx =∞.
therefore, the mgf is undefined. on the other hand, by the fourier table we know that
φx(jω) =f1
π(x2+ 1)
=e−|ω|.
□
331chapter 6. sample statistics
example 6.4 . let x0, x1, . . .be a sequence of independent random variables with
pdf
fxk(x) =ak
π(a2
k+x2), a k=1
2k+1fork= 0,1, . . . .
find the pdf of y, where y=p∞
k=0xk.
solution . from the fourier transform table, we know that
ak
π(a2
k+x2)=1
akπ·a2
k
(a2
k+x2)f←→1
akπ·πake−ak|ω|=e−ak|ω|.
the characteristic function of yis
φy(jω) =∞y
k=0φxk(jω) = exp(
−|ω|∞x
k=0ak)
.
sincep∞
k=0ak=p∞
k=01
2k+1=1
2+1
4+···= 1, the characteristic function becomes
φy(jω) =e−|ω|. the inverse fourier transform gives us
e−|ω|=1
π·πe−|ω|f←→1
π·1
1 +x2.
therefore the pdf of yis
fy(y) =1
π(1 +y2).
example 6.5 . two random variables xandyhave the pdfs
fx(x) =(
e−x, x ≥0,
0, x < 0,and fy(y) =(
e−y, y ≥0,
0, y < 0.
find the pdf of z= max( x, y)−min(x, y).
solution . we first show that
z= max( x, y)−min(x, y) =|x−y|.
suppose x > y , then max( x, y) =xand min( x, y) =y. soz=x−y. ifx < y ,
then max( x, y) =yand min( x, y) =x. soz=y−x. combining the two cases
gives us z=|x−y|. now, consider the fourier transform of the pdfs:
e−xf←→1
1 +jω.
3326.2. probability inequalities
letu=x−y, and let z=|u|. the characteristic function is
φu(jω) =e[e−jω(x−y)] =e[e−jωx]e[ejωy]
=1
1 +jω·1
1−jω=1
1 +ω2f←→ fu(u) =1
2e−|u|.
with the pdf of u, we can find the cdf of z:
fz(z) =p[z≤z] =p[|u| ≤z]
=zz
−zfu(u)du
=zz
−z1
2e−|u|du
= 2zz
01
2e−udu= 1−e−z.
hence, the pdf is
fz(z) =d
dzfz(z) =e−z.
closing remark . moment-generating functions and characteristic functions are useful
mathematical tools. in this section, we have confined our discussion to using them to com-
pute the sum of two random variables. later sections and chapters will explain further uses
for these functions. for example, we use the mgfs when proving chernoff’s bound and
proving the central limit theorem.
6.2 probability inequalities
moment-generating functions and characteristic functions are powerful tools for handling the
sum of random variables. we now introduce another set of tools, known as the probability
inequalities , that allow us to do approximations. we will highlight a few basic probability
inequalities in this section.
6.2.1 union bound
the first inequality is the union bound we had introduced when we discussed the axioms of
probabilities. the union bound states the following:
theorem 6.8 (union bound ).leta1, . . . , a nbe a collection of sets. then
p"n[
n=1an#
≤nx
n=1p[an]. (6.12)
333chapter 6. sample statistics
proof . we can prove this by induction. first, if n= 2,
p[a1∪a2] =p[a1] +p[a2]−p[a1∩a2]≤p[a1] +p[a2],
because p[a1∩a2] is a probability and so it must be non-negative. thus we have proved
the base case. assume that the statement is true for n=k. we need to prove that the
statement is also true for n=k+ 1. to this end, we note that
p"k+1[
n=1an#
=p" k[
n=1an!
∪ak+1#
=p"k[
n=1an#
+p[ak+1]−p" k[
n=1an!
∩ak+1#
≤p"k[
n=1an#
+p[ak+1].
then, according to our hypothesis for n=k, it follows that
p"k[
n=1an#
≤kx
n=1p[an].
putting these together,
p"k+1[
n=1an#
≤kx
n=1p[an] +p[ak+1] =k+1x
n=1p[an].
therefore, by the principle of induction, we have proved the statement.
□
remark . the tightness of the union bound depends on the amount of overlapping between
the events a1, . . . , a n, as illustrated in figure 6.4 . if the events are disjoint, the union bound
is tight. if the events are overlapping significantly, the union is loose. the idea of the union
bound is the principle of divide and conquer. we decompose the system into smaller events
for a system of nvariables and use the union bound to upper-limit the overall probability. if
the probability of each event is small, the union bound tells us that the overall probability
of the system will also be small.
figure 6.4: conditions under which the union bound is loose or tight. [left] the union bound is loose
when the sets are overlapping. [right] the union bound is tight when the sets are (nearly) disjoint.
3346.2. probability inequalities
example 6.6 . let x1, . . . , x nbe a sequence of i.i.d. random variables with cdf
fxn(x) and let z= min( x1, . . . , x n). find an upper bound on the cdf.
solution . note that z= min( x1, . . . , x n)≤zis equivalent to at least one of the
xn’s being less than z. thus, we have that
z= min( x1, . . . , x n)≤z⇔x1≤z∪ ··· ∪ xn≤z.
substituting this result into the cdf,
fz(z) =p[z≤z]
=p[min( x1, . . . , x n)≤z]
=p[x1≤z∪ ··· ∪ xn≤z]
≤p[x1≤z] +···+p[xn≤z]
=n·fx(z).
6.2.2 the cauchy-schwarz inequality
the second inequality we study here is the cauchy-schwarz inequality , which we previously
mentioned in chapter 5. we review it for the sake of completeness.
theorem 6.9 (cauchy-schwarz inequality ).letxandybe two random variables.
then
e[xy]2≤e[x2]e[y2]. (6.13)
proof . let f(s) =e[(sx+y)2] for any real s. then
f(s) =e[(sx+y)2]
=e[s2x2+ 2sxy +y2]
=e[x2]s2+ 2e[xy]s+e[y2].
this is a quadratic equation, and f(s)≥0 for all sbecause e[(sx+y)2]≥0.
recall that for a quadratic equation ϕ(x) =ax2+bx+c, the function ϕ(x)≥0 if and
only if b2−4ac≤0. substituting this result into our problem, we show that
(2e[xy])2−4e[x2]e[y2]≤0.
this implies that
e[xy]2≤e[x2]e[y2],
which completes the proof.
□
remark . as shown in chapter 5, the cauchy-schwarz inequality is useful in analyzing
e[xy]. for example, we can use the cauchy-schwarz inequality to prove that the correlation
coefficient ρis bounded between −1 and 1.
335chapter 6. sample statistics
6.2.3 jensen’s inequality
our next inequality is jensen’s inequality . to motivate the inequality, we recall that
var[x] =e[x2]−e[x]2.
since var[ x]≥0 for any x, it follows that
e[x2]|{z}
=e[g(x)]≥e[x]2
|{z}
=g(e[x]). (6.14)
jensen’s inequality is a generalization of the above result by recognizing that the inequality
does not only hold for the function g(x) =x2but also for any convex function g. the
theorem is stated as follows:
theorem 6.10 (jensen’s inequality ).letxbe a random variable, and let g:r→r
be aconvex function. then
e[g(x)]≥g(e[x]). (6.15)
if the function gisconcave , then the inequality sign is flipped: e[g(x)]≤g(e[x]). the
way to remember this result is to remember that e[x2]−e[x]2= var[ x]≥0.
now, what is a convex function? informally, a function gisconvex if, when we pick any
two points on the function and connect them with a straight line, the line will be above the
function for that segment. this definition is illustrated in figure 6.5 . consider an interval
[x, y], and the line segment connecting g(x) and g(y). if the function g(·) is convex, then
the entire line segment should be above the curve.
figure 6.5: illustration of a convex function, a concave function, and a function that is neither convex
nor concave.
the definition of a convex function essentially follows the above picture:
definition 6.4. a function gisconvex if
g(λx+ (1−λ)y)≤λg(x) + (1 −λ)g(y), (6.16)
for any 0≤λ≤1.
here λrepresents a “sweeping” constant that goes from xtoy. when λ= 1 then λx+(1−λ)y
simplifies to x, and when λ= 0 then λx+ (1−λ)ysimplifies to y.
3366.2. probability inequalities
the definition is easy to understand. the left-hand side g(λx+(1−λ)y) is the function
evaluated at any points in the interval [ x, y]. the right-hand side is the red straight line we
plotted in figure 6.5 . it connects the two points g(x) and g(y). convexity means that the
red line is entirely above the curve.
for twice-differentiable 1d functions, convexity can be described by the curvature of
the function. a function is convex if
g′′(x)≥0. (6.17)
this is self-explanatory because if the curvature is non-negative for all x, then the slope of
ghas to keep increasing.
example 6.7 . the following functions are convex or concave:
g(x) = log xis concave, because g′(x) =1
xandg′′(x) =−1
x2≤0 for all x.
g(x) =x2is convex, because g′(x) = 2 xandg′′(x) = 2 is positive.
g(x) =e−xis convex, because g′(x) =−e−xandg′′(x) =e−x≥0.
why is jensen inequality valid for a convex function? consider the illustration in
figure 6.6 . suppose we have a random variable xtaking some pdf fx(x). there is a
convex function g(·) that maps the random variable xtog(x). since g(·) is convex, a pdf
like the one we see in figure 6.6 will become skewed. (you can map the left tail to the new
left tail, the peak to the new peak, and the right tail to the new right tail.) as you can see
from the figure, the new random variable g(x) has a mean e[g(x)] that is greater than the
mapped old mean g(e[x]). jensen’s inequality captures this phenomenon by stating that
e[g(x)]≥g(e[x]) for any convex function g(·).
figure 6.6: jensen’s inequality states that if there is a convex function g(·)that maps a random variable
xto a new random variable g(x), the new mean e[g(x)]will be greater than the mapped old mean
g(e[x]).
proving jensen’s inequality is straightforward for a two-state discrete random variable.
define a random variable xwith states xandy. the probabilities for these two states are
p[x=x] =λandp[x=y] = 1−λ. then
e[x] =x
x′∈{x,y}x′px(x′) =λx+ (1−λ)y.
337chapter 6. sample statistics
now, let g(·) be a convex function. we know from the expectation that
e[g(x)] =x
x′∈{x,y}g(x′)px(x′) =g(x)λ+ (1−λ)g(y).
by convexity of the function g(·), it follows that
g(λx+ (1−λ)y)| {z }
=g(e[x])≤λf(x) + (1 −λ)g(y)| {z }
=e[g(x)],
where in the underbrace we substitute the definitions using the expectation. therefore,
for any two-state discrete random variables, the proof of jensen’s inequality follows directly
from the convexity. if the discrete random variable takes more than two states, we can prove
the theorem by induction. for continuous random variables, we can prove the theorem using
the following approach.
you may skip the proof of jensen’s inequality if this is your first time reading the book.
here we present an alternative proof of jensen’s inequality that does not require proof
by induction. the idea is to recognize that if the function gis convex we can find a tangent
linel(x) =ax+bat the point e[x] that is uniformly lower than g(x), i.e., g(x)≥l(x)
for all x. then we can prove the result with a simple geometric argument. figure 6.7
illustrates this idea.
figure 6.7: geometric illustration of the proof of jensen’s inequality. suppose g(·)is a convex function.
for any point xong(·), we can find a tangent line l(x) =ax+b. since the black curve is always
above the tangent, it follows that e[g(x)]≥e[l(x)]for any x. also, note that at a particular point
e[x], the black curve and the red line touch, and so we have l(e[x]) =g(e[x]).
proof of jensen’s inequality . consider l(x) as defined above. since gis convex, g(x)≥
l(x) for all x. therefore,
e[g(x)]≥e[l(x)]
=e[ax+b]
=ae[x] +b
=l(e[x]) =g(e[x]),
where the last equality holds because lis a tangent line to gwhere they meet at e[x].
□
3386.2. probability inequalities
what are ( a, b) in the proof? by taylor expansion,
g(x)≈g(e[x]) +g′(e[x])(x−e[x])
def=l(x).
therefore, if we want to be precise, then a=g′(e[x]) and b=g(e[x])−g′(e[x])e[x].
the end of the proof.
example 6.8 . by jensen’s inequality, we have that
(a)e[x2]≥e[x]2, because g(x) =x2is convex.
(b)e1
x
≥1
e[x], because g(x) =1
xis convex.
(c)e[logx]≤loge[x], because g(x) = log xis concave.
6.2.4 markov’s inequality
our next inequality, markov’s inequality , is an elementary inequality that links probability
and expectation.
theorem 6.11 (markov’s inequality ).letx≥0be a non-negative random variable.
then, for any ε >0, we have
p[x≥ε]≤e[x]
ε. (6.18)
markov’s inequality concerns the tailof the random variable. as illustrated in figure 6.8 ,
p[x≥ε] measures the probability that the random variable takes a value greater than ε.
markov’s inequality asserts that this probability p[x≥ε] is upper-bounded by the ratio
e[x]/ε. this result is useful because it relates the probability and the expectation. in many
problems the probability p[x≥ε] could be difficult to evaluate if the pdf is complicated.
the expectation, on the other hand, is usually easier to evaluate.
proof . consider εp[x≥ε]. it follows that
εp[x≥ε] =z∞
εε fx(x)dx≤z∞
εxfx(x)dx,
where the inequality is valid because for any x≥εthe integrand (which is non-negative)
will always increase (or at least not decrease). it then follows that
z∞
εxfx(x)dx≤z∞
0xfx(x)dx=e[x].□
a pictorial interpretation of markov’s inequality is shown in figure 6.9 . for x > 0, it
is not difficult to show that e[x] =r∞
01−fx(x)dx. then, in the cdf plot, we see that
ε·p[x≥ε] is a rectangle covering the top left corner. this area is clearly smaller than the
area covered by the function 1 −fx(x).
339chapter 6. sample statistics
figure 6.8: markov’s inequality provides an upper bound to the tail of a random variable. the inequality
states that the probability p[x≥ε]is upper bounded by the ratio e[x]/ε.
figure 6.9: the proof of markov’s inequality follows from the fact that ε·p[x≥ε]occupies the
top left corner marked by the yellow rectangle. the expectation is the area above the cdf so that
e[x] =r∞
01−fx(x)dx. since the yellow rectangle is smaller than the orange shaded area, it follows
thatε·p[x≥ε]≤e[x], which is markov’s inequality.
practice exercise 6.4 . prove that if x > 0, then e[x] =r∞
01−fx(x)dx.
solution . we start from the right-hand side:
z∞
01−fx(x)dx=z∞
01−p[x≤x]dx
=z∞
0p[x≥x]dx
=z∞
0z∞
xfx(t)dt dx
=z∞
0zt
0fx(t)dx dt
=z∞
0tfx(t)dt=e[x].
the change in the integration order is illustrated below.
3406.2. probability inequalities
how tight is markov’s inequality? it is possible to create a random variable such that
the equality is met (see exercise 6.14). however, in general, the estimate provided by the
upper bound is not tight. here is an example.
practice exercise 6.5 . let x∼uniform(0 ,4). verify markov’s inequality for p[x≥
2],p[x≥3] and p[x≥4].
solution . first, we observe that e[x] = 2. then
p[x≥2] = 0 .5,e[x]
2= 1,
p[x≥3] = 0 .25,e[x]
3= 0.67,
p[x≥4] = 0 ,e[x]
4= 0.5.
therefore, although the upper bounds are all valid, they are very loose.
if markov’s inequality is not tight, why is it useful? it turns out that while markov’s
inequality is not tight, its variations can be powerful. we will come back to this point when
we discuss chernoff’s bound.
6.2.5 chebyshev’s inequality
the next inequality is a simple extension of markov’s inequality. the result is known as
chebyshev’s inequality.
theorem 6.12 (chebyshev’s inequality ).letxbe a random variable with mean µ.
then for any ε >0we have
p[|x−µ| ≥ε]≤var[x]
ε2. (6.19)
the tail measured by chebyshev’s inequality is illustrated in figure 6.10 . since the
event |x−µ| ≥εinvolves an absolute value, the probability measures the two-sided tail.
chebyshev’s inequality states that this tail probability is upper-bounded by var[ x]/ε2.
341chapter 6. sample statistics
figure 6.10: chebyshev’s inequality states that the two-sided tail probability p[|x−µ| ≥ε]is upper-
bounded by var[x]/ε2
proof . we apply markov’s inequality to show that
p[|x−µ| ≥ε] =p[(x−µ)2≥ε2]
≤e[(x−µ)2]
ε2=var[x]
ε2.
□
an alternative form of chebyshev’s inequality is obtained by letting ε=kσ. in this
case, we have
p[|x−µ| ≥kσ]≤σ2
k2σ2=1
k2.
therefore, if a random variable is ktimes the standard deviation away from the mean, then
the probability bound drops to 1 /k2.
practice exercise 6.6 . let x∼uniform(0 ,4). find the bound of chebyshev’s
inequality for the probability p[|x−µ| ≥1].
solution . note that e[x] = 2 and σ2= 42/12 = 4 /3. therefore, we have
p[|x−µ| ≥1]≤σ2
ε2=4
3,
which is a valid upper bound, but quite conservative.
practice exercise 6.7 . let x∼exponential(1). find the bound of chebyshev’s
inequality for the probability p[x≥ε].
solution . note that e[x] = 1 and σ2= 1. thus we have
p[x≥ε] =p[x−µ≥ε−µ]≤p[|x−µ| ≥ε−µ]
≤σ2
(ε−µ)2=1
(ε−1)2.
3426.2. probability inequalities
we can compare this with the exact probability, which is
p[x≥ε] = 1−fx(ε) =e−ε.
again, the estimate given by chebyshev’s inequality is acceptable but too conservative.
corollary 6.2. letx1, . . . , x nbe i.i.d. random variables with mean e[xn] =µand
variance var[xn] =σ2. let xn=1
npn
n=1xnbe the sample mean. then
pxn−µ> ϵ
≤σ2
nϵ2. (6.20)
proof . we can first show that e[xn] =µand var[ xn] satisfies
var[xn] =1
n2nx
n=1var[xn] =σ2
n.
then by chebyshev’s inequality,
pxn−µ> ϵ
≤var[xn]
ϵ2=σ2
nϵ2.
□
the consequence of this corollary is that the upper bound σ2n/ϵ2will converge to zero
asn→ ∞ . therefore, the probability of getting the event {xn−µ> ϵ}is vanishing.
it means that the sample average xnis converging to the true population mean µ, in the
sense that the probability of failing is shrinking.
6.2.6 chernoff’s bound
we now introduce a powerful inequality or a set of general procedures that gives us some
highly useful inequalities. the idea is named for herman chernoff, although it was actually
due to his colleague herman rubin.
theorem 6.13 (chernoff’s bound ).letxbe a random variable. then, for any
ε≥0, we have that
p[x≥ε]≤e−φ(ε), (6.21)
wherea
φ(ε) = max
s>0
sε−logmx(s)
, (6.22)
andmx(s)is the moment-generating function.
aφ(ε) is called the fenchel-legendre dual function of log mx. see references [6-14].
343chapter 6. sample statistics
proof . there are two tricks in the proof of chernoff’s bound. the first trick is a nonlinear
transformation. since esxis an increasing function for any s >0 and x, we have that
p[x≥ε] =p[esx≥esε]
(a)
≤e[esx]
esε
(b)=e−sεmx(s)
=e−sε+log mx(s),
where the inequality (a) is due to markov’s inequality. step (b) just uses the definition of
mgf that e[esx] =mx(s).
now for the second trick. note that the above result holds for all s. that means it
must also hold for the sthat minimizes e−sε+log mx(s). this implies that
p[x≥ε]≤min
s>0n
e−sε+log mx(s)o
.
again, since exis increasing, the minimizer of the above probability is also the maximizer
of this function:
φ(ε) = max
s>0
sε−logmx(s)
.
thus, we conclude that p[x≥ε]≤e−φ(ε).
□
6.2.7 comparing chernoff and chebyshev
let’s consider an example of how chernoff’s bound can be useful.
suppose that we have a random variable x∼gaussian(0 , σ2/n). the number ncan
be regarded as the number of samples. for example, if y1, . . . , y narengaussian random
variables with mean 0 and variance σ2, then the average x=1
npn
n=1ynwill have mean
0 and variance σ2/n. therefore, as ngrows, the variance of xwill become smaller and
smaller.
first, since the random variable is gaussian, we can show the following:
lemma 6.1. letx∼gaussian (0,σ2
n)be a gaussian random variable. then, for any
ε >0,
p[x≥ε] = 1−φ √
nε
σ!
, (6.23)
where φis the standard gaussian’s cdf.
note that this is the exact result: if you tell me ε,n, and σ, then the probability p[x≥ε]
is exactly the one shown on the right-hand side. no approximation, no randomness.
3446.2. probability inequalities
proof . since xis gaussian, the probability is
p[x≥ε] =z∞
ε1p
2π(σ2/n)exp
−x2
2(σ2/n)
dx
= 1−zε
−∞1p
2π(σ2/n)exp
−x2
2(σ2/n)
dx
= 1−z ε√
σ2/n
−∞1√
2πexp
−x2
2
dx
= 1−φ 
εp
σ2/n!
= 1−φ √
nε
σ!
.
□
let us compute the bound given by chebyshev’s inequality.
lemma 6.2. letx∼gaussian (0,σ2
n)be a gaussian random variable. then, for any
ε >0, chebyshev’s inequality implies that
p[x≥ε]≤σ2
nε2. (6.24)
proof . we apply chebyshev’s inequality by assuming that µ= 0:
p[x≥ε] =p[x−µ≥ε−µ]≤p[|x−µ| ≥ε−µ]
≤e[(x−µ)2]
(ε−µ)2=σ2
nε2.
□
we now compute chernoff’s bound.
theorem 6.14. letx∼gaussian (0,σ2
n)be a gaussian random variable. then, for
anyε >0, chernoff’s bound implies that
p[x≥ε]≤exp
−ε2n
2σ2
. (6.25)
proof . the mgf of a zero-mean gaussian random variable with variance σ2/nismx(s) =
expn
σ2s2
2no
. therefore, the function φcan be written as
φ(ε) = max
s>0
sε−logmx(s)
= max
s>0
sε−σ2s2
2n
.
to maximize the function we take the derivative and set it to zero. this yields
d
ds
sε−σ2s2
2n
= 0 ⇒ s∗=nε
σ2.
345chapter 6. sample statistics
note that this s∗is a maximizer because sε−σ2s2
2nis a concave function.
substituting s∗intoφ(ε),
φ(ε) = max
s>0sε−σ2s2
2n
=s∗ε−σ2(s∗)2
2n=nε
σ2
ε−σ2
2nnε
σ22
=ε2n
2σ2,
and hence
p[x≥ε]≤e−φ(ε)= exp
−ε2n
2σ2
.
□
figure 6.11 shows the comparison between the exact probability, the bound provided
by chebyshev’s inequality, and chernoff’s bound:
exact :p[x≥ε] = 1−φ√
nε
σ
.
chebyshev :p[x≥ε]≤σ2
nε2,
chernoff :p[x≥ε]≤expn
−ε2n
2σ2o
.
in this numerical experiment, we set ε= 0.1, and σ= 1. we vary the number n. as we can
see from the figure, the bound provided by chebyshev is valid but very loose. it does not
even capture the tail as ngrows. on the other hand, chernoff’s bound is reasonably tight.
however, one should note that the tightness of chernoff is only valid for large n. when n
is small, it is possible to construct random variables such that chebyshev is tighter.
the matlab code used to generate this plot is illustrated below.
% matlab code to compare the probability bounds
epsilon = 0.1;
sigma = 1;
n = logspace(1,3.9,50);
p_exact = 1-normcdf(sqrt(n)*epsilon/sigma);
p_cheby = sigma^2./(epsilon^2*n);
p_chern = exp(-epsilon^2*n/(2*sigma^2));
loglog(n, p_exact, ’-o’, ’color’, [1 0.5 0], ’linewidth’, 2); hold on;
loglog(n, p_cheby, ’-’, ’color’, [0.2 0.7 0.1], ’linewidth’, 2);
loglog(n, p_chern, ’-’, ’color’, [0.2 0.0 0.8], ’linewidth’, 2);
what could go wrong if we insist on using chebyshev’s inequality? consider the fol-
lowing example.
example 6.9 . let x∼gaussian(0 , σ2/n). suppose that we want the probability to
be no greater than a confidence level of α:
p[x≥ε]≤α.
3466.2. probability inequalities
101102103
n10-1510-1010-5100probability
exact
chebyshev
chernoff
figure 6.11: comparison between chernoff’s bound and chebyshev’s bound. the random variable we
use is x∼gaussian (0, σ2/n). as ngrows, we show the probability bounds predicted by the two
methods.
letα= 0.05,ε= 0.1, and σ= 1. find the nusing (i) chebyshev’s inequality and (ii)
chernoff’s inequality.
solution : (i) chebyshev’s inequality implies that
p[x≥ε]≤σ2
nε2≤α,
which means that
n≥σ2
αε2.
if we plug in α= 0.05,ε= 0.1, and σ= 1, then n≥2000.
(ii) for chernoff’s inequality, it holds that
p[x≥ε]≤exp
−ε2n
2σ2
≤α,
which means that
n≥ −2σ2
ε2logα
plugging in α= 0.05,ε= 0.1, and σ= 1, we have that n≥600. this is more than 3
times smaller than the one predicted by chebyshev’s inequality. which one is correct?
both are correct but chebyshev’s inequality is overly conservative. if n≥600 can
makep[x≥ε]≤α, then certainly n≥2000 will work too. however, n≥2000 is too
loose.
347chapter 6. sample statistics
6.2.8 hoeffding’s inequality
chernoff’s bound can be used to derive many powerful inequalities. here we present an
inequality for bounded random variables. this result is known as hoeffding’s inequality.
theorem 6.15 (hoeffding’s inequality ).letx1, . . . , x nbe i.i.d. random variables
with 0≤xn≤1, ande[xn] =µ. then
pxn−µ> ϵ
≤2e−2ϵ2n, (6.26)
where xn=1
npn
n=1xn.
you may skip the proof of hoeffding’s inequality if this is your first time reading the book.
proof . (hoeffding’s inequality) first, we show that
p
xn−µ > ϵ
=p"
1
nnx
n=1xn−µ > ϵ#
=p"nx
n=1(xn−µ)> nϵ#
=ph
espn
n=1(xn−µ)≥esϵni
≤e[espn
n=1(xn−µ)]
esϵn=e[es(xn−µ)]
esϵn
.
letzn=xn−µ. then −µ≤zn≤1−µ. at this point we use hoeffding lemma (see
below) that e[eszn]≤es2
8because b−a= (1−µ)−(−µ) = 1. thus,
p
xn−µ > ϵ
≤e[eszn]
esϵn
≤ 
es2
8
esϵ!n
=es2n
8−sϵn,∀s.
this result holds for all s, and thus it holds for the sthat minimizes the right-hand side.
this implies that
p
xn−µ > ϵ
≤min
s
exps2n
8−sϵn
.
minimizing the exponent givesd
dsn
s2n
8−sϵno
=sn
4−ϵn= 0. thus we have s= 4ϵ.
hence,
p
xn−µ > ϵ
≤exp(4ϵ)2n
8−(4ϵ)ϵn
=e−2ϵ2n.
by symmetry, p
xn−µ <−ϵ
≤e−2ϵ2n. then by union bound we show that
p
|xn−µ|> ϵ
=p
xn−µ > ϵ
+p
xn−µ <−ϵ
≤e−2ϵ2n+e−2ϵ2n
= 2e−2ϵ2n.□
3486.2. probability inequalities
lemma 6.3 (hoeffding’s lemma ).leta≤x≤bbe a random variable with
e[x] = 0. then
mx(s)def=e
esx
≤exps2(b−a)2
8
. (6.27)
proof . since a≤x≤b, we can write xas a linear combination of aandb:
x=λb+ (1−λ)a,
where λ=x−a
b−a. since exp( ·) is a convex function, it follows that eλb+(1−λ)a≤λeb+(1−λ)ea.
(recall that his convex if h(λx+ (1−λ)y)≤λh(x) + (1 −λ)h(y).) therefore, we have
esx≤λesb+ (1−λ)esa
=x−a
b−aesb+b−x
b−aesa.
taking expectations on both sides of the equation,
e[esx]≤−a
b−aesb+b
b−aesa,
because e[x] = 0. now, if we let θ=−a
b−a, then
−a
b−aesb+b
b−aesa=θesb+ (1−θ)esa
=esa
1−θ+θes(b−a)
=
1−θ+θes(b−a)
e−sθ(b−a)
= (1−θ+θeu)e−θu=e−θu+log(1 −θ+θeu),
where we let u=s(b−a). this can be simplified as e[esx]≤e[eϕ(u)] by defining
ϕ(u) =−θu+ log(1 −θ+θeu).
the final step is to approximate ϕ(u). to this end, we use taylor approximation:
ϕ(u) =ϕ(0) + uϕ′(0) +u2
2ϕ′′(ξ),
for some ξ∈[a, b]. since ϕ(0) = 0, ϕ′(0) = 0, and ϕ′′(u)≤1
4for all u, it follows that
ϕ(u) =u2
2ϕ′′(ξ)≤u2
8=s2(b−a)2
8.□
end of the proof.
349chapter 6. sample statistics
what is so special about the hoeffding’s inequality?
since hoeffding’s inequality is derived from chernoff’s bound, it inherits the
tightness. hoeffding’s inequality is much stronger than chebyshev’s inequality
in bounding the tail distributions.
hoeffding’s inequality is one of the few inequalities that do not require e[x] and
var[x] on the right-hand side.
a downside of the inequality is that boundedness is not always easy to satisfy.
for example, if xnis a gaussian random variable, hoeffding does not apply.
there are more advanced inequalities for situations like these.
interpreting hoeffding’s inequality . one way to interpret hoeffding’s inequality is to
write the equation as
pxn−µ> ϵ
≤2e−2ϵ2n
|{z}
δ,
which is equivalent to
pxn−µ≤ϵ
≥1−δ.
this means that with a probability at least 1 −δ, we have
xn−ϵ≤µ≤xn+ϵ.
if we let δ= 2e−2ϵ2n, this becomes
xn−r
1
2nlog2
δ≤µ≤xn+r
1
2nlog2
δ. (6.28)
this inequality is a confidence interval (see chapter 9). it says that with probability at
least 1 −δ, the interval [ xn−ϵ,xn+ϵ] includes the true population mean µ.
there are two questions one can ask about the confidence interval:
given nandδ, what is the confidence interval? equation (6.28) tells us that if we
know n, to achieve a probability of at least 1 −δthe confidence interval will follow
equation (6.28). for example, if n= 10,000 and δ= 0.01,q
1
2nlog2
δ= 0.016.
therefore, with a probability at least 99%, the true population mean µwill be included
in the interval
xn−0.16≤µ≤xn+ 0.16.
if we want to achieve a certain confidence interval, what is the nwe need? if we are
given ϵandδ, the nwe need is
δ≤2e−2ϵ2n⇒ n≥log2
δ
2ϵ2.
for example, if δ= 0.01 and ϵ= 0.01, the nwe need is n≥26,500.
when is hoeffding’s inequality used? hoeffding’s inequality is fundamental in modern
machine learning theory. in this field, one often wants to quantify how well a learning
3506.3. law of large numbers
algorithm performs with respect to the complexity of the model and the number of training
samples. for example, if we choose a complex model, we should expect to use more training
samples or overfit otherwise. hoeffding’s inequality provides an asymptotic description of
the training error, testing error, and the number of training samples. the inequality is
often used to compare the theoretical performance limit of one model versus another model.
therefore, although we do not need to use hoeffding’s inequality in this book, we hope you
appreciate its tightness.
closing remark . we close this section by providing the historic context of chernoff’s
inequality. herman chernoff, the discoverer of chernoff’s inequality, wrote the following
many years after the publication of the original paper in 1952.
“in working on an artificial example, i discovered that i was using the central limit
theorem for large deviations where it did not apply. this led me to derive the asymptotic
upper and lower bounds that were needed for the tail probabilities. [herman] rubin claimed
he could get these bounds with much less work, and i challenged him. he produced a rather
simple argument, using markov’s inequality, for the upper bound. since that seemed to be
a minor lemma in the ensuing paper i published (chernoff, 1952), i neglected to give him
credit. i now consider it a serious error in judgment, especially because his result is stronger
for the upper bound than the asymptotic result i had derived. ” — herman chernoff, “a
career in statistics,” in lin et al., past, present, and future of statistical science (2014),
p. 35.
6.3 law of large numbers
in this section, we present our first main result: the law of large numbers. we will discuss
two versions of the law: the weak law and the strong law. we will also introduce two forms
of convergence: convergence in probability and almost sure convergence.
6.3.1 sample average
the law of large numbers is a probabilistic statement about the sample average . suppose
that we have a collection of i.i.d. random variables x1, . . . , x n. the sample average of these
nrandom variables is defined as follows:
definition 6.5. thesample average of a sequence of random variables x1, . . . , x n
is
xn=1
nnx
n=1xn. (6.29)
if the random variables x1, . . . , x nare i.i.d. so that they have the same population
mean e[xn] =µ(forn= 1, . . . , n ), then by the linearity of the expectation,
e
xn
=1
nnx
n=1e[xn] =µ.
351chapter 6. sample statistics
therefore, the mean of xnis the population mean µ.
the sample average, xn, plays an important role in statistics. for example, by sur-
veying 10,000 americans, we can find a sample average of their ages. since we never have
access to the true population mean, the sample average is an estimate, and since xnis only
an estimate, we need to ask how good the estimate is.
one reason we ask this question is that xnis a finite-sample “approximation” of µ.
more importantly, the root of the problem is that xnitself is a random variable because
x1, . . . , x nare all random variables. since xnis a random variable, there is a pdf of
xn; there is a cdf of xn; there is e[xn]; and there is var[ xn]. since xnis a random
variable, it has uncertainty. to say that we are confident about xn, we need to ensure that
the uncertainty is within some tolerable range.
how do we control the uncertainty? we can compute the variance. if x1, . . . , x nare
i.i.d. random variables with the same variance var[ xn] =σ2(forn= 1, . . . , n ), then
var
xn
=1
n2nx
n=1var[xn] =1
n2nx
n=1σ2=σ2
n.
therefore, the variance will shrink to 0 as ngrows. in other words, the more samples we
use to construct the sample average, the less deviation the random variable xnwill have.
visualizing the sample average
to help you visualize the randomness of xn, we consider an experiment of drawing n
bernoulli random variables x1, . . . , x nwith parameter p= 1/2. since xnis bernoulli, it
follows that
e[xn] =p and var[ xn] =p(1−p).
we construct a sample average xn=1
npn
n=1xn. since xnis a bernoulli random variable,
we know everything about xn. first, xnis a binomial random variable, since xnis the
sum of bernoulli random variables. second, the mean and variance of xnare respectively
µxndef=e[xn] =1
nnx
n=1e[xn] =p,
σ2
xndef= var[ xn] =1
n2nx
n=1var[xn] =p(1−p)
n.
infigure 6.12 , we plot the random variables xn(the black crosses) for every n. you
can see that at each n, e.g., n= 100, there are many possible observations for xnbecause
xnitself is a random variable. as nincreases, we see that the deviation of the random
variables becomes smaller. in the same plot, we show the bounds µ±3σxn, which are three
standard deviations from the mean. we can see clearly that the bounds provide a very good
envelope covering the random variables. as ngoes to infinity, we can see that the standard
deviation goes to zero, and so xnapproaches the true mean.
for your reference, the matlab code and the python code we used to generate the
plot are shown below.
% matlab code to illustrate the weak law of large numbers
nset = round(logspace(2,5,100));
3526.3. law of large numbers
102103104105
n0.30.40.50.60.7sample average
figure 6.12: the weak law of large numbers. in this plot, we assume that x1, . . . , x nare i.i.d. bernoulli
random variables with a parameter p. the black crosses in the plot are the sample averages
xn=1
npn
n=1xn. the red curves are the ideal bounds µxn±3σxn, where µxn=pand
σxn=p
p(1−p)/n. as ngrows, we observe that the variance shrinks to zero. therefore, the
sample average is converging to the true population mean.
for i=1:length(nset)
n = nset(i);
p = 0.5;
x(:,i) = binornd(n, p, 1000,1)/n;
end
y = x(1:10:end,:)’;
semilogx(nset, y, ’kx’); hold on;
semilogx(nset, p+3*sqrt(p*(1-p)./nset), ’r’, ’linewidth’, 4);
semilogx(nset, p-3*sqrt(p*(1-p)./nset), ’r’, ’linewidth’, 4);
# python code to illustrate the weak law of large numbers
import numpy as np
import matplotlib.pyplot as plt
import scipy.stats as stats
import numpy.matlib
p = 0.5
nset = np.round(np.logspace(2,5,100)).astype(int)
x = np.zeros((1000,nset.size))
for i in range(nset.size):
n = nset[i]
x[:,i] = stats.binom.rvs(n, p, size=1000)/n
nset_grid = np.matlib.repmat(nset, 1000, 1)
plt.semilogx(nset_grid, x,’ko’);
plt.semilogx(nset, p + 3*np.sqrt((p*(1-p))/nset), ’r’, linewidth=6)
plt.semilogx(nset, p - 3*np.sqrt((p*(1-p))/nset), ’r’, linewidth=6)
353chapter 6. sample statistics
note the outliers for each ninfigure 6.12 . for example, at n= 102we see a point
located near 0.7 on the y-axis. this point is outside three standard deviations. is it normal?
yes. being outside three standard deviations only says that the probability of having this
outlier is small . it does not say that the outlier is impossible . having a small probability does
not exclude the possibility. by contrast, if you say that something will surely not happen you
mean that there is not even a small probability. the former is a weaker statement than the
latter. therefore, even though we establish a three standard deviation envelope, there are
points falling outside the envelope. as ngrows, the chance of having a bad outlier becomes
smaller. therefore, the greater the n, the smaller the chance we will get an outlier.
if the random variables xnare i.i.d., the above phenomenon is universal. below is an
example of the poisson case.
practice exercise 6.8 . let xn∼poisson( λ). define the sample average as xn=
1
npn
n=1xn. find the mean and variance of xn.
solution . since xnis poisson, we know that e[xn] =λand var[ xn] =λ. so
e[xn] =1
nnx
n=1e[xn] =1
nnx
n=1λ=λ,
var[xn] =1
n2nx
n=1var[xn] =1
n2nx
n=1λ=λ
n.
therefore, as n→ ∞ , the variance var[ xn]→0.
6.3.2 weak law of large numbers (wlln)
the analysis of figure 6.12 shows us something important, namely that the convergence
in a probabilistic way is different from that in a deterministic way. we now describe one
fundamental result related to probabilistic convergence, known as the weak law of large
numbers.
theorem 6.16 (weak law of large numbers ).letx1, . . . , x nbe a set of i.i.d. ran-
dom variables with mean µand variance σ2. assume e[x2]<∞. let xn=1
npn
n=1xn.
then for any ε >0,
lim
n→∞p
|xn−µ|> ε
= 0. (6.30)
proof . by chebyshev’s inequality,
p
|xn−µ|> ε
≤var[xn]
ε2=var[xn]
nε2.
therefore, setting n→ ∞ we have
lim
n→∞p
|xn−µ|> ε
= lim
n→∞var[xn]
nε2= 0.
□
3546.3. law of large numbers
example 6.10 . consider a set of i.i.d. random variables x1, . . . , x nwhere
xn∼gaussian( µ, σ2).
verify that the sample average xn=1
npn
n=1xnfollows the weak law of large num-
bers.
solution : since xnis a gaussian, the sample average xnis also a gaussian:
xn∼gaussian
µ,σ2
n
.
consider the probability p
|xn−µ|> ε
for each n:
δndef=p
|xn−µ|> ε
=p
xn−µ > ε
+p
xn−µ <−ε
= 1−φ 
ε√
n
σ!
+ φ 
−ε√
n
σ!
= 2φ 
−ε√
n
σ!
.
if we set σ= 1 and ε= 0.1, then
δ1= 2φ
−0.1·1
1
= 0.9203, δ 5= 2φ 
−0.1·√
5
1!
= 0.8231,
δ10= 2φ 
−0.1·√
10
1!
= 0.7518, δ 100= 2φ 
−0.1·√
100
1!
= 0.3173,
δ1000= 2φ 
−0.1·√
1000
1!
= 0.0016.
as you can see, the the sequence δ1, δ2, . . . , δ n, . . .rapidly converges to 0 as ngrows.
in fact, since φ( z) is a increasing function for z <0 with φ( −∞) = 0, it follows that
lim
n→∞p
|xn−µ|> ε
= lim
n→∞2φ 
−ε√
n
σ!
= 0.
the weak law of large numbers is portrayed graphically in figure 6.13 . in this figure
we draw several pdfs of the sample average xn. the shapes of the pdfs are getting
narrower as the variance of the random variable shrinks. since the pdfs become narrower,
the probability p[|xn−µ|> ε] becomes more unlikely. at the limit when n→ ∞ , the
probability vanishes. the weak law of large numbers asserts that this happens for any set of
i.i.d. random variables. it says that the sequence of probability values δndef=p[|xn−µ|> ε]
355chapter 6. sample statistics
will converge to zero.
figure 6.13: the weak law of large numbers states that as nincreases, the variance of the sample
average xnshrinks. as a result, the probability p[|xn−µ|> ε]decreases and eventually vanishes.
note that the convergence here is that of the sequence of probabilities p[|xn−µ|> ε], which is just
a sequence of numbers.
what is the weak law of large numbers?
letxnbe the sample average of i.i.d. random variables x1, . . . , x n.
lim
n→∞p
|xn−µ|> ε
= 0. (6.31)
for details, see theorem 6.16.
the wlln concerns the sequence of probability values δn=p[|xn−µ|> ε].
the probabilities converge to zero as ngrows.
it is weak because having a small probability does not exclude the possibility of
happening.
6.3.3 convergence in probability
the example above tells us that in order to show convergence, we need to first compute the
probability δnof each event and then take the limit of the sequence, e.g., the one shown in
the table below:
δ1 δ5 δ10 δ100 δ1000 δ10000
0.9203 0.8231 0.7518 0.3173 0.0016 1.5240 ×10−23
therefore, the convergence is the convergence of the probability . since {δ1, δ2, . . .}is a
sequence of real numbers (between 0 and 1), any convergence results for real numbers apply
here.
note that the convergence controls only the probabilities. probability means chance.
therefore, having the limit converging to zero only means that the chance of happening is
becoming smaller and smaller. however, at any n, there is still a chance that some bad
event can happen.
3566.3. law of large numbers
what do we mean by a bad event? assume that xnare fair coins. the sample average
xn= (1/n)pn
n=1xnis more or less equal to 1/2 as ngrows. however, even if nis a
large number, say n= 1000, we are still not certain that the sample average is exactly 1/2.
it is possible, though very unlikely, that we obtain 1000 heads or 1000 tails (so that the
sample average is “1” or “0”). the bottom line is: having a probability converging to zero
only means that for any tolerance level we can always find an nlarge enough so that the
probability is smaller than that tolerance.
the type of convergence described by the weak law of large numbers is known as the
convergence in probability .
definition 6.6. a sequence of random variables a1, . . . , a nconverges in probability
to a deterministic number αif for every ε >0,
lim
n→∞p[|an−α|> ε] = 0. (6.32)
we write anp→αto denote convergence in probability.
the following two examples illustrate how to prove convergence in probability.
example 6.11 . let x1, . . . , x nbe i.i.d. random variables with xn∼uniform(0 ,1).
define an= min( x1, . . . , x n). show that anconverges in probability to zero.
solution . (without determining the pdf of an, we notice that as nincreases, the
value of anwill likely decrease. therefore, we should expect anto converge to zero.)
pick an ε >0. it follows that
p[|an−0| ≥ε] =p[min( x1, . . . , x n)≥ε], because xn≥0
=p[x1≥εand···andxn≥ε]
=p 
x1≥ε
···p 
xn≥ε
= (1−ε)n.
setting the limit of n→ ∞ , we conclude that
lim
n→∞p[|an−0| ≥ε] = lim
n→∞(1−ε)n= 0.
therefore, anconverges to zero in probability.
practice exercise 6.9 . let x∼exponential(1). by evaluating the cdf, we know
thatp[x≥x] =e−x. let an=x/n . prove that anconverges to zero in probability.
solution . for any ε >0,
p[|an−0| ≥ε] =p[an≥ε]
=p[x≥nε]
=e−nε.
357chapter 6. sample statistics
putting n→ ∞ on both sides of the equation gives us
lim
n→∞p[|an−0| ≥ε] = lim
n→∞e−nε= 0.
thus, anconverges to zero in probability.
example 6.12 . construct an example such that anconverges in probability to some-
thing, but e[an] does not converge to the same thing.
solution . consider a sequence of random variables ansuch that
p[an=α] =

1−1
n, α = 0,
1
n, α =n2,
0, otherwise .
the pdf of the random variable anis shown in figure 6.14 .
figure 6.14: probability density function of the random variable an.
we first show that anconverges in probability to zero. let ε >0 be a fixed
constant. since ε >0,p[an≥ε] =1
nfor any n >√ε. therefore, we have that
lim
n→∞p[|an−0| ≥ε] = lim
n→∞p[an≥ε]
= lim
n→∞1
n= 0.
hence, anconverges to 0 in probability.
however, e[an] does not converge to zero, because
e[an] = 0·
1−1
n
+n2·1
n=n.
soe[an] goes to infinity as ngrows.
6.3.4 can we prove wlln using chernoff’s bound?
the following discussion of using chernoff’s bound to prove wlln can be skipped if this
is your first time reading the book.
3586.3. law of large numbers
in proving wlln we use chebyshev’s inequality. can we use chernoff’s inequality (or
hoeffding’s) to prove the result? yes, we can use them. however, notice that the task here is
to prove convergence, not to find the bestconvergence. finding the best convergence means
finding the fastest decay rate of the probability sequence. chernoff’s bound (and hoeffding’s
inequality) offers a better decay rate. however, chernoff’s bound needs to be customized for
individual random variables. for example, chernoff’s bound for gaussian is different from
chernoff’s bound for exponential. this result makes chebyshev the most convenient bound
because it only requires the variance to be bounded.
what if we insist on using chernoff’s bound in proving the wlln? we can do that for
specific random variables. let’s consider two examples. the first example is the gaussian
random variable where xn∼ n(0, σ2). we know that xn∼ n(0, σ2/n). chernoff’s bound
shows that
p
|xn−µ|> ε
≤2 exp
−ε2n
2σ2
,
taking the limit on both sides, we have
lim
n→∞p
|xn−µ|> ε
= lim
n→∞2 exp
−ε2n
2σ2
= 0.
note that the rate of convergence here is exponential. the rate of convergence offered by
chebyshev is only linear. of course, you may argue that since xnis gaussian we have
closed-form expressions about the probability, so we do not need chernoff’s bound. this is
a legitimate point, and so here is an example where we do not have a closed-form expression
for the probability.
consider a sequence of arbitrary i.i.d. random variables x1, . . . , x nwith 0 ≤xn≤1.
then hoeffding’s inequality tells us that
p
|xn−µ|> ε
≤2 exp
−2ε2n	
.
taking the limit on both sides, we have
lim
n→∞p
|xn−µ|> ε
= lim
n→∞2 exp
−2ε2n	
= 0.
again, we obtain a wlln result, this time for i.i.d. random variables x1, . . . , x nwith
0≤xn≤1.
as you can see from these two examples, wlln can be proved in multiple ways
depending on how general the random variables need to be.
end of the discussions.
6.3.5 does the weak law of large numbers always hold?
the following discussion of the failure of the weak law of large numbers can be skipped if
this is your first time reading the book.
359chapter 6. sample statistics
the weak law of large numbers does not always hold. recall that when we prove the
weak law of large numbers using chebyshev’s inequality, we implicitly require that the
variance var[ xn] is finite. (look at the condition that e[x2]<∞.) thus for distributions
whose variance is unbounded, chebyshev’s inequality does not hold. one example is the
cauchy distribution. the pdf of a cauchy distribution is
fx(x) =γ
π(γ2+x2),
where γis a parameter. letting γ= 1,
e[x2] =z∞
−∞x2
π(1 +x2)dx=1
πz∞
−∞1−1
1 +x2dx
=1
πz∞
−∞dx−1
πz∞
−∞1
1 +x2dx=1
π
x−tan−1(x)∞
x=−∞=∞.
since the second moment is unbounded, the variance of xwill also be unbounded.
a perceptive reader may observe that even if e[x2] is unbounded, it does not mean
that the tail probability is unbounded. this is correct. however, for cauchy distributions,
we can show that the sample average xndoes not converge to the mean when n→ ∞
(and so the wlln fails). to see this, we note that the characteristic function of a cauchy
random variable xis
1
π(1 +x2)↔e−|ω|.
so for the sample average xn=1
npn
n=1xn, the characteristic function is
e[e−jωxn] =e[e−jω
npn
n=1xn] =ny
n=1e[e−jω
nxn] =h
e−|ω|
nin
=e−|ω|,
which remains a cauchy distribution with γ= 1. therefore, we have that
p[|xn| ≤ε] =zε
−∞1
π(1 +x2)dx
=z0
−∞1
π(1 +x2)dx+zε
01
π(1 +x2)dx=1
2+1
πtan−1(ε).
thus no matter how many samples we have, p[|xn| ≤ε] will never converge to 1 (so
p[|xn|> ε] will never converge to 0). therefore, wlln does not hold.
end of the discussion.
6.3.6 strong law of large numbers
since there is a “weak” law of large numbers, you will not be surprised to learn that there
is a strong law of large numbers. the strong law is more restrictive than the weak law. any
sequence satisfying the strong law will satisfy the weak law, but not vice versa. since the
strong law is “stronger”, the proof is more involved.
3606.3. law of large numbers
theorem 6.17 (strong law of large numbers ).letx1, . . . , x nbe a sequence of
i.i.d. random variables with common mean µand variance σ2. assume e[x4]<∞.
letxn=1
npn
n=1xnbe the sample average. then
ph
lim
n→∞xn=µi
= 1. (6.33)
the strong law flips the order of limit and probability . as you can see, the difference
between the strong law and the weak law is the order of the limit and the probability. in the
weak law, the limit is outside the probability, whereas, in the strong law, the limit is inside
the probability. this switch in order makes the interpretation of the result fundamentally
different. in the final analysis, the weak law concerns the limit of a sequence of probabilities
(which are just real numbers between 0 and 1). however, the strong law concerns the limit
of a sequence of random variables. the strong law answers the question, what is the limiting
object of the sample average as ngrows?
the strong law concerns the limiting object, not a sequence of numbers . what
is the “limiting object”? if we denote xnas the sample average using nsamples, then
we know that x1is a random variable, x2is a random variable, and all xn’s are random
variables. so we have a sequence of random variables. as ngoes to infinity, we can ask about
the limiting object lim n→∞xn. however, even without any deep analysis, you should be
able to see that lim n→∞xnis another random variable. the strong law says that this
limiting object will “successfully” become a deterministic number µ, after a finite number
of “failures”.
the strong law asserts that there are a finite number of failures . let us explain
“success” and “failure”. xnis a random variable, so it fluctuates. however, as ngoes to
infinity, the strong law says that the number of times where xn̸=µwill be zero. that
is, there is a finite number of times where xn̸=µ(i.e., fail), and afterward, you will be
perfectly fine (i.e., success). yes, perfectly fine means 100%. the weak law only guarantees
99.99%.
a good example for differentiating the weak law and the strong law is an electronic
dictionary that improves itself every time you use it. the weak law says that if you use
the dictionary for a long period, the probability of making an error will become small. you
will still get an error once in a while, but the probability is very small. this is a 99.99%
guarantee, and it is the weak law. the strong law says that the number of failures is finite.
after you have gone through this finite number of failures, you will be completely free of
error. this is a 100% guarantee by the strong law. when will you hit this magical number?
the strong law does not say when; it only asserts the existence of this number. however, this
existence is already good enough in many ways. it gives a certificate of assurance, whereas
the weak law still has uncertainty.
strong law ̸=deterministic. if the strong law offers a 100% guarantee, does it mean
that it is a deterministic guarantee? no, the strong law is still a probabilistic statement
because we are still using p[·] to measure an event. the event can include measure-zero
subsets, and the measure-zero subsets can be huge. for example, the set of rational numbers
on the real line is a measure-zero set when measuring the probability using an integration.
the strong law does not handle those measure-zero subsets.
361chapter 6. sample statistics
6.3.7 almost sure convergence
the discussion below can be skipped if this is your first time reading the book.
the type of convergence used by the strong law of large numbers is the almost sure
convergence . it is defined formally as follows.
definition 6.7. a sequence of random variables a1, . . . , a nconverges almost surely
toαif
ph
lim
n→∞an=αi
= 1. (6.34)
we write ana.s.→αto denote almost sure convergence.
to prove almost sure convergence, one needs to show that the sequence anwill demonstrate
an̸=αfor a finite number of times. afterward, anneeds to demonstrate an=α.
example 6.13 .aconstruct a sequence of events that converges almost surely.
solution . let x1, . . . , x nbe i.i.d. random variables such that xn∼uniform(0 ,1).
define an= min( x1, . . . , x n). since anis nonincreasing and is bounded below by
zero, it must have a limit. let us call this limit
adef= lim
n→∞an.
then we can show that
p[a≥ϵ] =p[min( x1, x2, . . .)≥ϵ]
(a)
≤p[min( x1, x2, . . . , x n)≥ϵ]
(b)=p[x1≥ϵandx2≥ϵand···andxn≥ϵ]
= (1−ϵ)n,
where ( a) holds because there are more elements in ( x1, x2, . . .) than in
(x1, x2, . . . , x n). therefore, the minimum value of the former is less than the mini-
mum value of the latter. ( b) holds because if min( x1, x2, . . . , x n)≥ϵ, then xn≥ϵ
for all n.
sincep[a≥ϵ]≤(1−ϵ)nfor any n, the statement still holds as n→ ∞ . thus,
p[a≥ϵ]≤lim
n→∞(1−ϵ)n= 0.
this shows p[a≥ϵ] = 0 for any positive ϵ. sop[a > ϵ ] = 0, and hence p[a= 0] = 1.
since ais the limit of an, we conclude that
ph
lim
n→∞an= 0i
=p[a= 0] = 1 .
3626.3. law of large numbers
soanconverges to 0 almost surely.
athis example is modified from bertsekas and tsitsiklis, introduction to probability , chapter 5.5.
example 6.14 .aconstruct an example where a sequence of events converges in prob-
ability but does not converge almost surely.
solution . consider a discrete time arrival process. the set of times is partitioned into
consecutive intervals of the form
i1={2,3},
i2={4,5,6,7},
i3={8,9,10, . . . , 15},
...
ik={2k,2k+ 1, . . . , 2k+1−1}.
therefore, the length of each interval is |i1|= 2,|i2|= 4, . . . , |ik|= 2k.
during each interval, there is exactly one arrival. define ynas a binary random
variable such that for every n∈ik,
yn=(
1, with probability1
|ik|,
0, with probability 1 −1
|ik|.
for example, if n∈ {2,3}, then p[yn= 1] =1
2. ifn∈ {4,5,6,7}, then p[yn= 1] =1
4.
in general, we have that
lim
n→∞p[yn= 1] = lim
n→∞1
|ik|= lim
n→∞1
2k= 0,
and hence
lim
n→∞p[yn= 0] = lim
n→∞1−1
2k= 1.
therefore, ynconverges to 0 in probability.
however, when we carry out the experiment, there is exactly one arrival per
interval according to the problem conditions. since we have an infinite number of
intervals i1, i2, . . ., we will have an infinite number of arrivals in total. as a result,
yn= 1 for infinitely many times. we do not know which ynwill equal 1 and which
ynwill equal to 0. however, we know that there are infinitely many ynthat are equal
to 1. therefore, in the sequence y1, y2, . . . , y n, . . ., we must have that the tail of the
sequence is 1. (if ynstops being 1 after some n, then we will not have an infinite
number of arrivals in total.)
since yn= 1 when nis large enough, it follows that
ph
lim
n→∞yn= 1i
= 1.
363chapter 6. sample statistics
equivalently, we can say that the sequence ynwill never take the value 0 when nis
large enough. thus,
ph
lim
n→∞yn= 0i
= 0.
therefore, yndoes not converge to 0 almost surely.
athis example is modified from bertsekas and tsitsiklis, introduction to probability , chapter 5.5.
end of the discussions.
6.3.8 proof of the strong law of large numbers
the strong law of large numbers can be proved in several ways. we present a proof based on
bertsekas and tsitsiklis, introduction to probability , problems 5.16 and 5.17, which require
a finite fourth moment e[x4
n]<∞. an alternative proof that requires only e[xn]<∞is
from billingsley, probability and measure , theorem 22.1.
the proof of the strong law of large numbers is beyond the scope of this book. this
section is optional.
lemma 6.4. consider non-negative random variables x1, . . . , x n. assume that
e"∞x
n=1xn#
<∞. (6.35)
then xna.s.→0.
proof . let s=pn
n=1xn. note that sis a random variable, and our assumption is that
e[s]<∞. thus, we argue that s <∞with probability 1. if not, then swill have a positive
probability of being ∞. but if this happens, we will have e[s] =∞because (by the law of
total expectation):
e[s] =e[s|s= infinite]| {z }
=∞p[s= infinite] + e[s|s= finite] p[s= finite] .
now, since sis finite, the sequence {x1, . . . , x n, . . .}must converge to zero. otherwise,
ifxnis converging to some constants c >0, then summing the tail of the sequence (which
contains infinitely many terms) gives infinity:
s=x1+···|{z}
=finite+xn+···+|{z}
=infinite.
since the probability of sbeing finite is 1, it follows that {x1, . . . , x n}is converging
to zero with probability 1.
□
3646.3. law of large numbers
theorem 6.18 (strong law of large numbers ).letx1, . . . , x nbe a sequence of
i.i.d. random variables with common mean µand variance σ2. assume e[x4
n]<∞.
letxn=1
npn
n=1xnbe the sample average. then
ph
lim
n→∞xn=µi
= 1. (6.36)
proof . we first prove the case where e[xn] = 0. to establish that xn→0 with probabil-
ity 1, we use the lemma to show that
e"∞x
n=1|xn|#
<∞.
but to show e[p∞
n=1|xn|]<∞, we note that |x| ≤1 +x4. therefore, e[p∞
n=1|xn|]≤
1 +e[p∞
n=1x4
n], and hence we just need to show that
e"∞x
n=1x4
n#
<∞.
let us expand the term e[x4
n] as follows:
e[x4
n] =1
n4nx
n1=1nx
n2=1nx
n3=1nx
n4=1e[xn1xn2xn3xn4].
there are five possibilities for e[xn1xn2xn3xn4]:
all indices are different. then
e[xn1xn2xn3xn4] =e[xn1]e[xn2]e[xn3]e[xn4] = 0·0·0·0 = 0 .
one index is different from other three indices. for example, if n1is different from
n2, n3, n4, then
e[xn1xn2xn3xn4] =e[xn1]e[xn2xn3xn4] = 0·e[xn2xn3xn4] = 0.
two indices are identical. for example, if n1=n3, and n2=n4, then
e[xn1xn2xn3xn4] =e[xn1xn3]e[xn2xn4] =e[x2
n1x2
n2].
there are altogether 3 n(n−1) of these cases: n(n−1) comes from choosing n
followed by choosing n−1, and 3 accounts for n1=n2̸=n3=n4,n1=n3̸=n2=n4,
andn1=n4̸=n2=n3.
two indices are identical, and two indices are different. for example, if n1=n3but
n2andn4are different. then
e[xn1xn2xn3xn4] =e[xn1xn3]e[xn2]e[xn4] =e[x2
n1]·0·0 = 0 .
365chapter 6. sample statistics
all indices are identical. if n1=n2=n3=n4, then
e[xn1xn2xn3xn4] =e[x4
n1].
there are altogether ncases of this.
therefore, it follows that
e[x4
n] =ne[x4
1] + 3n(n−1)e[x2
1x2
2]
n4.
since xy≤(x2+y2)/2, it follows that
e[x2
1x2
2]≤e[(x2
1)2+ (x2
2)2]/2 =e[x4
1+x4
2]/2 =e[x4
1].
substituting into the previous result,
e[x4
n]≤ne[x4
1] + 3n(n−1)e[x4
1]
n4≤3n2
n4e[x4
1] =3
n2e[x4
1].
now, let us complete the proof.
e"∞x
n=1x4
n#
≤e"∞x
n=13
n2e[x4
1]#
<∞,
becausep∞
n=1(1/n2) is the bassel problem with a solution thatp∞
n=1(1/n2) =π2/6.
consequently, we have shown that ehp∞
n=1x4
ni
<∞, which implies ep∞
n=1|xn|
<∞.
then, by the lemma, we have xnconverging to 0 with probability 1, which proves the result.
ife[xn] =µ, then just replace xnwith yn=xn−µin the above arguments. then we
can show that ynconverges to 0 with probability 1, which is equivalent to xnconverging
toµwith probability 1.
end of the proof of strong law of large numbers.
6.4 central limit theorem
the law of large numbers tells us the mean of the sample average xn= (1/n)pn
n=1xn.
however, if you recall our experiment of throwing ndice and inspecting the pdf of the
sum of the numbers, you may remember that the convolution of an infinite number of
uniform distributions gives us a gaussian distribution. for example, we show a sequence
of experiments in figure 6.15 . in each experiment, we throw ndice and count the sum.
therefore, if each face of the die is denoted as xn, then the sum is x1+···+xn. we plot
the pdf of the sum. as you can see in the figure, x1+···+xnconverges to a gaussian.
this phenomenon is explained by the central limit theorem (clt) .
what does the central limit theorem say? let xnbe the sample average, and let
zn=√
n
xn−µ
σ
be the normalized variable. the central limit theorem is as follows:
3666.4. central limit theorem
figure 6.15: pictorial illustration of the central limit theorem. suppose we throw a die and record the
face. [left] if we only have one die, then the distribution of the face is uniform. [middle] if we throw
two dice, the distribution is the convolution of two uniform distributions. this will give us a triangle
distribution. [right] if we throw five dice, the distribution is becoming similar to a gaussian. the central
limit theorem says that as ngoes to infinity, the distribution of the sum will converge to a gaussian.
central limit theorem :
the cdf of znis converging pointwise to the cdf of gaussian(0,1).
note that we are very careful here. we are not saying that the pdf of znis converging to
the pdf of a gaussian, nor are we saying that the random variable znis converging to a
gaussian random variable. we are only saying that the values of the cdf are converging
pointwise. the difference is subtle but important.
to understand the difficulty and the core ideas, we first present the concept of conver-
gence in distribution.
6.4.1 convergence in distribution
definition 6.8. letz1, . . . , z nbe random variables with cdfs fz1, . . . , f znrespec-
tively. we say that a sequence of z1, . . . , z nconverges in distribution to a random
variable zwith cdf fzif
lim
n→∞fzn(z) =fz(z), (6.37)
for every continuous point zoffz. we write znd→zto denote convergence in
distribution.
this definition involves many concepts, which we will discuss one by one. however, the
definition can be summarized in a nutshell as follows.
convergence in distribution = values of the cdf converge.
example 1 . (bernoulli ) consider flipping a fair coin ntimes. denote each coin flip as a
bernoulli random variable xn∼bernoulli( p), where n= 1,2, . . . , n . define znas the sum
367chapter 6. sample statistics
ofnbernoulli random variables, so that
zn=nx
n=1xn.
we know that the resulting random variable znis a binomial random variable with mean
npand variance np(1−p). let us plot the pdf fzn(z) as shown in figure 6.16 .
figure 6.16: convergence in distribution. the convergence in distribution concerns the convergence of
the values of the cdf (not the pdf). in this figure, we let zn=x1+···+xn, where xnis a
bernoulli random variable with parameter p. since a sum of bernoulli random variables is a binomial,
znis a binomial random variable with parameters (n, p). we plot the pdf of zn, which is a train of
delta functions, and compare it with the gaussian pdf. observe that the error, max z|fzn(z)−fz(z)|,
does notconverge to 0. the pdf of znis a binomial. a binomial is always a binomial. it will not turn
into a gaussian.
the first thing we notice in the figure is that as nincreases, the pdf of the binomial
has an envelope that is “very gaussian”. so one temptation is to say that the random
variable znis converging to another random variable z. in addition, we would think that
the pdfs converge in the sense that for allz,
fzn(z) =n
z
pz(1−p)n−z−→ fz(z) =1√
2πσ2exp
−(z−µ)2
2σ2
,
where µ=npandσ2=np(1−p).
unfortunately this argument does not work, because fz(z) is continuous but fzn(z)
is discrete. the sample space of znand the sample space of zare completely different. in
fact, if we write fznas an impulse train, we observe that
fzn(z) =nx
i=0n
i
pi(1−p)n−iδ(z−i).
clearly, no matter how big the nis, the difference |fzn(z)−fz(z)|will never go to zero
for non-integer values of z. mathematically, we can show that
max
z|fzn(z)−fz(z)| ̸−→ 0,
asn→ ∞ .znis a binomial random variable regardless of n. it will not become a gaussian.
3686.4. central limit theorem
iffzn(z) is not converging to a gaussian pdf, how do we explain the convergence?
the answer is to look at the cdf. for discrete pdfs such as a binomial random variable,
the cdf is a staircase function. what we can show is that
fzn(z) =zx
i=0n
i
pi(1−p)n−i−→ fz(z) =zz
−∞1√
2πσ2exp
−(t−µ)2
2σ2
dt.
the difference between the pdf convergence and the cdf convergence is that the pdf
does not allow a meaningful “distance” between a discrete function and continuous function.
for cdf, the distance is well defined by taking the difference between the staircase function
and the continuous function. for example, we can compute
|fzn(z)−fz(z)|, for all continuous points zoffz,
and show that
max
z|fzn(z)−fz(z)| −→ 0.
figure 6.17: convergence in distribution. this is the same as figure 6.16 , but this time we plot the
cdf of zn. the cdf is a staircase function. we compare it with the gaussian cdf. observe that the
error, max z|fzn(z)−fz(z)|, converges to zero as ngrows. convergence in distribution says that the
sequence of cdfs fzn(z)will converge to the limiting cdf fz(z), at all continuous points of fz(z).
we need to pay attention to the set of z’s. we do not evaluate all z’s but only the z’s
that are continuous points of fz. iffzis gaussian, this does not matter because all z’s
are continuous. however, for cdfs containing discontinuous points, our definition of con-
vergence in distribution will ignore these discontinuous points because they have a measure
zero.
example 2 . (poisson ) consider xn∼poisson( λ), and consider x1, . . . , x n. define zn=pn
n=1xn. it follows that e[zn] =pn
n=1e[xn] =nλand var[ zn] =pn
n=1var[xn] =nλ.
moreover, we know that the sum of poissons remains a poisson. therefore, the pdf of zn
is
fzn(z) =∞x
k=0(nλ)k
k!e−nλδ(z−k) and fz(z) =1√
2πσ2exp
−(z−µ)2
2σ2
,
369chapter 6. sample statistics
0 2 4 6 800.050.10.150.2
poisson
gaussian
0 5 10 15 2000.050.10.15
poisson
gaussian
0 20 40 60 80 10000.020.040.06
poisson
gaussian
0 2 4 6 800.20.40.60.81
poisson
gaussian
0 5 10 15 2000.20.40.60.81
poisson
gaussian
0 20 40 60 80 10000.20.40.60.81
poisson
gaussian
(a)n= 4 (b) n= 10 (c) n= 50
figure 6.18: convergence in distribution for a sum of poisson random variables. here we assume that
x1, . . . , x nare i.i.d. poisson with a parameter λ. we let zn=pn
n=1xnbe the sum, and compute the
corresponding pdf (top row) and cdfs (bottom row). just as with the binomial example, the pdfs of
the poisson do not converge but the cdfs of the poisson converge to the cdf of a gaussian.
where µ=nλandσ2=nλ. again, fzndoes not converge to fz. however, if we compare
the cdf, we can see from figure 6.18 that the cdf of the poisson is becoming better
approximated by the gaussian.
interpreting “convergence in distribution” . after seeing two examples, you should
now have some idea of what “convergence in distribution” means. this concept applies to
the cdfs. when we write
lim
n→∞fzn(z) =fz(z), (6.38)
we mean that fzn(z) is converging to the value fz(z), and this relationship holds for all
the continuous z’s offz. it does not say that the random variable znis becoming another
random variable z.
znd−→zis equivalent to lim n→∞fzn(z) =fz(z).
example 3 . (exponential ) so far, we have studied the sum of discrete random variables.
now, let’s take a look at continuous random variables. consider xn∼exponential( λ), and
letx1, . . . , x nbe i.i.d. copies. define zn=pn
n=1xn. then e[zn] =pn
n=1e[xn] =n/λ
and var[ zn] =n
λ2. how about the pdf of zn? using the characteristic functions, we know
that
fxn(x) =λe−λx f←→ φxn(jω) =λ
λ+jω.
3706.4. central limit theorem
therefore, the product is
φzn(jω) =ny
n=1φxn(jω) =λn
(λ+jω)n=λn
(λ+jω)n×(n−1)!
(n−1)!
=λn
(n−1)!·(n−1)!
(λ+jω)nf←→λn
(n−1)!zn−1e−λz=fzn(z).
this resulting pdf fzn(z) =λn
(n−1)!zn−1e−λzis known as the erlang distribution . the
cdf of the erlang distribution is
fzn(z) =zz
−∞fzn(t)dt
=zz
0λn
(n−1)!tn−1e−λtdt
= gamma function( z, n),
where the last integral is known as the incomplete gamma function, evaluated at z.
given all these, we can now compare the pdf and the cdf of znversus z.figure 6.19
shows the pdfs and the cdfs of znfor various nvalues. in this experiment we set λ= 1.
as we can see from the experiment, the erlang distribution’s pdf and cdf converge to
a gaussian. in fact, for continuous random variables such as exponential random variables,
we indeed have the random variable znconverging to the random variable z. this is quite
different from discrete random variables, where zndoes not converge to zbut only fzn
converges to fz.
0 2 4 6 800.050.10.150.20.25
sum of exponential
gaussian
0 5 10 15 2000.050.10.15
sum of exponential
gaussian
0 20 40 60 80 10000.020.040.06
sum of exponential
gaussian
0 2 4 6 800.20.40.60.81
sum of exponential
gaussian
0 5 10 15 2000.20.40.60.81
sum of exponential
gaussian
0 20 40 60 80 10000.20.40.60.81
sum of exponential
gaussian
(a)n= 4 (b) n= 10 (c) n= 50
figure 6.19: convergence in distribution for a sum of exponential random variables. here we assume
thatx1, . . . , x nare i.i.d. exponentials with a parameter λ. we define zn=pn
n=1xnbe the sum.
it is known that the sum of exponentials is an erlang. we compute the corresponding pdf (top row)
and cdfs (bottom row). unlike the previous two examples, in this example we see that both pdfs and
cdfs of the erlang distribution are converging to a gaussian.
371chapter 6. sample statistics
isd−→stronger thanp−→?convergence in distribution is actually weaker than con-
vergence in probability. consider a continuous random variable xwith a symmetric pdf
fx(x) such that fx(x) =fx(−x). it holds that the pdf of −xhas the same pdf. if
we define the sequence zn=xifnis odd and zn=−xifnis even, and let z=x,
then fzn(z) =fz(z) for every zbecause the pdf of xand−xare identical. there-
fore, znd→z. however, zn̸p→zbecause znoscillates between the random variables x
and−x. these two random variables are different (although they have the same cdf)
because p[x=−x] =p[{ω:x(ω) =−x(ω)}] =p[{ω:x(ω) = 0}] = 0.
6.4.2 central limit theorem
theorem 6.19 (central limit theorem ).letx1, . . . , x nbe i.i.d. random variables
of mean e[xn] =µand variance var[xn] =σ2. also, assume that e[|x3
n|]<∞. let
xn= (1/n)pn
n=1xnbe the sample average, and let zn=√
n
xn−µ
σ
. then
lim
n→∞fzn(z) =fz(z), (6.39)
where z=gaussian (0,1).
in plain words, the central limit theorem says that the sample average (which is
a random variable) has a cdf converging to the cdf of a gaussian. therefore, if we
want to evaluate probabilities associated with the sample average, we can approximate the
probability by the probability of a gaussian.
as we discussed above, the central limit theorem does not mean that the random
variable znis converging to a gaussian random variable, nor does it mean that the pdf
ofznis converging to the pdf of a gaussian. it only means that the cdf of znis
converging to the cdf of a gaussian. many people think that the central limit theorem
means “sample average converges to gaussian”. this is incorrect for the above reasons.
however, it is not completely wrong. for continuous random variables where both pdf
and cdf are continuous, we will not run into situations where the pdf is a train of delta
functions. in this case, convergence in cdf can be translated to convergence in pdf.
the power of the central limit theorem is that the result holds for anydistribution
ofx1, . . . , x n. that is, regardless of the distribution of x1, . . . , x n, the cdf of xnis
approaching a gaussian.
summary of the central limit theorem
x1, . . . , x nare i.i.d. random variables, with mean µand variance σ2. they are
not necessarily gaussians.
define the sample average as xn= (1/n)pn
n=1xn, and let zn=√
n
x−µ
σ
.
the central limit theorem says znd−→gaussian(0 ,1). equivalently, the the-
orem says that nxnd−→gaussian( µ, σ2).
so if we want to evaluate the probability of xn∈ a for some set a, we can
3726.4. central limit theorem
approximate the probability by evaluating the gaussian:
p[xn∈ a]≈z
a1p
2π(σ2/n)exp
−(y−µ)2
2(σ2/n)
dy.
clt does notsay that the pdf of xnis becoming a gaussian pdf.
clt only says that the cdf of xnis becoming a gaussian cdf.
if the set ais an interval, we can use the standard gaussian cdf to compute the
probability.
corollary 6.3. letx1, . . . , x nbe i.i.d. random variables with mean µand vari-
ance σ2. define the sample average as xn= (1/n)pn
n=1xn. then
p[a≤xn≤b]≈φ√
nb−µ
σ
−φ√
na−µ
σ
, (6.40)
where φ(z) =rz
−∞1√
2πe−x2
2dxis the cdf of the standard gaussian.
proof . by the central limit theorem, we know that xnd−→gaussian( µ,σ2
n). therefore,
p[a≤xn≤b]≈zb
a1p
2π(σ2/n)exp
−(y−µ)2
2(σ2/n)
dy
=z√
nb−µ
σ
√
na−µ
σ1√
2πe−y2
2dy= φ√
nb−µ
σ
−φ√
na−µ
σ
.
□
figure 6.20: the central limit theorem says that if we want to evaluate the probability p[a≤xn≤b],
where xn= (1/n)pn
n=1xnis the sample average of i.i.d. random variables x1, . . . , x n, we can
approximate the probability by integrating the gaussian pdf.
a graphical illustration of the clt is shown in figure 6.20 , where we use a binomial
random variable (which is the sum of i.i.d. bernoulli) as an example. the clt does not say
373chapter 6. sample statistics
that the binomial random variable is becoming a gaussian. it only says that the probability
covered by the binomial can be approximated by the gaussian.
the following proof of the central limit theorem can be skipped if this is your first time
reading the book.
proof of the central limit theorem . we now give a “proof” of the central limit
theorem. technically speaking, this proof does not prove the convergence of the cdf as the
theorem claims; it only proves that the moment-generating function converges. the actual
proof of the cdf convergence is based on the berry-esseen theorem, which is beyond the
scope of this book. however, what we prove below is still useful because it gives us some
intuition about why gaussian is the limiting random variable we should consider in the first
place.
letzn=√
n
xn−µ
σ
. it follows that e[zn] = 0 and var[ zn] = 1. therefore, if we
can show that znis converging to a standard gaussian random variable z∼gaussian(0 ,1),
then by the linear transformation property of gaussian, y=σ√
nz+µwill be gaussian( µ, σ2/n).
our proof is based on analyzing the moment-generating function of zn. in particular,
mzn(s)def=e[eszn] =e
es√
nxn−µ
σ
=ny
n=1eh
es
σ√
n(xn−µ)i
.
expanding the exponential term using the taylor expansion (chapter 1.2),
ny
n=1eh
es
σ√
n(xn−µ)i
=ny
n=1e
1 +s
σ√
n(xn−µ) +s2
2σ2n(xn−µ)2+o(xn−µ)3
σ3n√
n
=ny
n=1
1 +s
σ√
ne[xn−µ] +s2
2σ2ne
(xn−µ)2
=
1 +s2
2nn
.
it remains to show that
1 +s2
2nn
→es2/2. if we can show that, we have shown that the
mgf of znis also the mgf of gaussian(0 ,1). to this end, we consider log(1 + x). by the
taylor approximation, we have that
log(1 + x)≈log(1) +d
dxlogx|x=1
x+d2
dx2logx|x=1x2
2+o(x3).
therefore, we have log
1 +s2
2n
≈s2
2n−s4
4n2. asn→ ∞ , the limit becomes
lim
n→∞nlog
1 +s2
2n
≈s2
2−lim
n→∞s4
4n=s2
2,
and so taking the exponential on both sides yields lim n→∞
1 +s2
2nn
=es2
2. therefore,
we conclude that lim n→∞mzn(s) =es2
2, and so znis converging to a gaussian.
3746.4. central limit theorem
□
limitation of our proof . the limitation of our proof lies in the issue of whether the
integration and the limit are interchangeable:
lim
n→∞mzn(s) = lim
n→∞z
fzn(z)eszdz
?=z
lim
n→∞fzn(z)
eszdz.
if they were, then proving lim n→∞mzn(s) =mz(s) is sufficient to claim fzn(z)→fz(z).
however, we know that the latter is not true in general. for example, if fzn(z) is a train of
delta functions, then the limit and the integration are not interchangeable.
berry-esseen theorem . the formal way of proving the central limit theorem is to
prove the berry-esseen theorem. the theorem states that
sup
z∈rfzn(z)−fz(z)≤cβ
σ3√
n,
where βandcare universal constants. here, you can more or less treat the supremum
operator as the maximum. the left-hand side represents the worst-case error of the cdf
fzncompared to the limiting cdf fz. the right-hand side involves several constants c,
β, and σ, but they are fixed.
asngoes to infinity, the right-hand side will converge to zero. therefore, if we can
prove this result, then we have proved the actual central limit theorem. in addition,
we have found the rate of convergence since the right-hand side tells us that the error
drops at the rate of 1 /√
n, which is not particularly fast but is sufficient for our purpose.
unfortunately, proving the berry-esseen theorem is not easy. one of the difficulties, for
example, is that one needs to deal with the infinite convolutions in the time domain or the
frequency domain.
interpreting our proof . if our proof is not completely valid, why do we mention it?
for one thing, it provides us with some useful intuition. for most of the (well-behaving)
random variables whose moments are finite, the exponential term in the moment-generating
function can be truncated to the second-order polynomial. since a second-order polynomial
is a gaussian, it naturally concludes that as long as we can perform such truncation the
truncated random variable will be gaussian.
to convince you that the gaussian mgf is the second-order approximation to other
mgfs, we use bernoulli as an example. let x1, . . . , x nbe i.i.d. bernoulli with a parame-
terp. then the moment-generating function of xn= (1/n)pn
n=1xnwould be:
mxn(s) =e[esx] =e[es1
npn
n=1xn] =ny
n=1e[es
nxn]
= (1−p+pes
n)n≈
1−p+p
1 +s
n+s2
2n2n
=
1 +sp
n+s2p
2n2n
.
375chapter 6. sample statistics
using the logarithmic approximation, it follows that
logmxn(s) =nlog
1 +sp
n+s2p
2n2
≈nsp
n+s2p
2n2
−n
2sp
n+s2p
2n22
≈sp+s2p(1−p)
2ndef= log my(s).
taking the exponential on both sides, we have that
my(s) = exp
sp+s2p(1−p)
2n
,
which is the mgf of a gaussian random variable y∼gaussian
p,p(1−p)
n
.
figure 6.21 shows several mgfs. in each of the subfigures we plot the exact mgf
mxn(s) = (1 −p+pes
n)nas a function of s. (the parameter pin this example is p= 0.5.) we
vary the number n, and we inspect how the shape of mxn(s) changes. on top of the exact
mgfs, we plot the gaussian approximations my(s) = expn
sp+s2p(1−p)
2no
. according to
our calculation, this gaussian approximation is the second-order approximation to the exact
mgf. the figures show the effect of the second-order approximation. for example, in (a)
when n= 2 the gaussian is a quadratic approximation of the exact mgf. for (b) and (c),
asnincreases, the approximation improves.
-10 -5 0 5 1010-210-1100101102103104105
binomial mgf
gaussian mgf
-10 -5 0 5 1010-210-1100101102103104105
binomial mgf
gaussian mgf
-10 -5 0 5 1010-210-1100101102103104105
binomial mgf
gaussian mgf
(a)n= 2 (b) n= 4 (c) n= 10
figure 6.21: explanation of the central limit theorem using the function. in this set of plots, we show
the mgf of the random variable xn= (1/n)pn
n=1xn, where x1, . . . , x nare i.i.d. bernoulli random
variables. the exact mgf of xnis the binomial, whereas the approximated mgf is the gaussian. we
observe that as nincreases, the gaussian approximation to the exact mgf improves.
the reason why the second-order approximation works for gaussian is that when n
increases, the higher order moments of xnvanish and only the leading first two moments
survive. the mgfs are becoming flat because my(s) = expn
sp+s2p(1−p)
2no
converges to
exp{sp}when n→ ∞ . taking the inverse laplace transform, my(s) = exp {sp}corresponds
to a delta function. this makes sense because as ngrows, the variance of the xshrinks.
end of the discussion.
3766.4. central limit theorem
6.4.3 examples
example 6.15 . prove the equivalence of a few statements.
√
n
xn−µ
σd→gaussian(0 ,1)
√
n(xn−µ)d→gaussian(0 , σ2)
√
nxnd→gaussian( µ, σ2)
solution . the proof is based on the linear transformation property of gaussian ran-
dom variables. for example, if the first statement is true, then the second statement
is also true because
lim
n→∞f√
n(xn−µ)(z) = lim
n→∞p[√
n(xn−µ)≤z]
= lim
n→∞p√
nxn−µ
σ
≤z
σ
=zz/σ
−∞1√
2πe−t2
2dt
=zz
−∞1√
2πσ2e−t2
2σ2dt.
the other results can be proved similarly.
example 6.16 . suppose xn∼poisson(10) for n= 1, . . . , n , and let xnbe the
sample average. use the central limit theorem to approximate p[9≤xn≤11] for
n= 20.
solution . we first show that
e[xn] =e"
1
nnx
n=1xn#
=1
nnx
n=1e[xn] = 10 ,
var[xn] =1
n2nx
n=1var [xn] =1
nvar[xn] =10
20=1
2.
therefore, the central limit theorem implies that xnd−→gaussian 
10,1
2
. the
probability is
p[9≤xn≤11]≈φ 
11−10p
1/2!
−φ 
9−10p
1/2!
= φ1√
0.5
−φ
−1√
0.5
= 0.9214−0.0786 = 0 .8427.
377chapter 6. sample statistics
we can also do an exact calculation to verify our approximation. let sn=pn
n=1xnso that xn=sn
n. since a sum of poisson remains a poisson, it follows that
sn∼poisson(10 n) = poisson(200) .
consequently,
p[9≤xn≤11] =p[180≤sn≤220]
=220x
ℓ=0200ℓe−200
ℓ!−180x
ℓ=0200ℓe−200
ℓ!= 0.9247−0.0822 = 0 .8425.
note that this is an exact calculation subject to numerical errors when evaluating the
finite sums. the proximity to the gaussian approximation shows the convenience of
the central limit theorem.
example 6.17 . suppose you have collected n= 100 data points from an unknown
distribution. the only thing you know is that the true population mean is µ= 500
and the standard deviation is σ= 80. (note that this distribution is not necessarily a
gaussian.)
(a) find the probability that the sample mean will be inside the interval (490 ,510).
(b) find an interval such that 95% of the sample average is covered.
solution . to solve (a), we note that xnd→gaussian
500,
80√
1002
. therefore,
p[490≤xn≤510] = φ 
510−500
80√
100!
−φ 
490−500
80√
100!
= φ(1 .25)−φ(−1.25) = 0 .7888.
to solve (b), we know that φ( x) = 0 .025 implies that x=−1.96, and φ( x) = 0 .975
implies that x= +1 .96. so
y−500
80√
100=±1.96⇒ y= 484 .32 or y= 515 .68.
therefore, p[484.32≤xn≤515.68] = 0 .95.
6.4.4 limitation of the central limit theorem
if we recall the statement of the central limit theorem (berry-esseen), we observe that
the theorem states only that
lim
n→∞p√
nxn−µ
σ
≤ε
= lim
n→∞fzn(ε) =fz(ε) = φ( ε).
3786.4. central limit theorem
rearranging the terms,
lim
n→∞p
xn≤µ+σε√
n
= φ(ε).
this implies that the approximation is good only when the deviation εissmall .
let us consider an example to illustrate this idea. consider a set of i.i.d. exponential
random variables x1, . . . , x n, where xn∼exponential( λ). let sn=x1+···+xnbe
the sum, and let x=sn/nbe the sample average. then, according to chapter 6.4.1, sn
is an erlang distribution sn∼erlang( n, λ) with a pdf
fsn(x) =λn
(n−1)!xn−1e−λx.
practice exercise 6.10 . let sn∼erlang( n, λ) with a pdf fsn(x). show that if
yn=asn+bfor any constants aandb, then
fyn(y) =1
afsny−b
a
.
solution : this is a simple transformation of random variables:
fyn(y) =p[y≤y] =p[asn+b≤y] =p
sn≤y−b
a
=zy−b
a
−∞fsn(x)dx.
hence, using the fundamental theorem of calculus,
fyn(y) =d
dyzy−b
a
−∞fsn(x)dx=1
afsny−b
a
.
we are interested in knowing the statistics of xnand comparing it with a gaussian.
to this end, we construct a normalized variable
zn=xn−µ
σ/√
n,
where µ=e[xn] =1
λandσ2= var[ xn] =1
λ2. then
zn=sn/n−µ
σ/√
n=sn−nµ
σ√
n=λ√
nsn−√
n
using the result of the practice exercise, by mapping a=λ√
nandb=−√
n, it follows that
fzn(z) =√
n
λfsn 
z+√
n
λ√
n!
.
now we compare znwith the standard gaussian z∼gaussian(0 ,1). according to the
central limit theorem, the standard gaussian is a good approximation to the normalized
379chapter 6. sample statistics
sample average zn. to compare the two results, we conduct a numerical experiment. we
letλ= 1 and we vary n. we plot the pdf fzn(z) as a function of z, for different n’s, in
figure 6.22 . in addition, we plot the pdf fz(z), which is the standard gaussian.
the plot in figure 6.22 shows that while the central limit theorem provides a good
approximation, the approximation is only good for values that are close to the mean. for
thetails, the gaussian approximation is not as good.
-1 0 1 2 3 4 510-610-410-2100
n = 1
n = 10
n = 100
n = 1000
gaussian
figure 6.22: clt fails at the tails. we note that x1, . . . , x nare i.i.d. exponential with a parameter
λ= 1. we plot the pdfs of the normalized sample average zn=xn−µ
σ/√
nby varying n. we plot the pdf
of the standard gaussian z∼gaussian (0,1)on the same grid. note that the gaussian approximation
is good for values that are close to the mean. for the tails, the gaussian approximation is not very
accurate.
the limitation of the central limit theorem is attributable to the fact that gaussian
is a second-order approximation. if a random variable has a very large third moment, the
second-order approximation may not be sufficient. in this case, we need a much larger nto
drive the third moment to a small value and make the gaussian approximation valid.
when will the central limit theorem fail?
the central limit theorem fails when nis small.
the central limit theorem fails if the third moment is large. as an extreme
case, a cauchy random variable does not have a finite third moment. the central
limit theorem is not valid for this case.
the central limit theorem can only approximate the probability for input val-
ues near the mean. it does not approximate the tails, for which we need to use
chernoff’s bound.
6.5 summary
why do we need to study the sample average? because it is the summary of the dataset. in
machine learning, one of the most frequently asked questions is about the number of training
3806.6. references
samples required to train a model. the answer can be found by analyzing the average number
of successes and failures as the number of training samples grows. for example, if we define
fas the classifier that takes a data point xnand predicts a label f(xn), we hope that it
will match with the true label yn. if we define an error
en=(
1, f (xn) =yn correct classification ,
0, f (xn)̸=yn incorrect classification ,
then enis a bernoulli random variable, and the total loss e=1
npn
n=1enwill be the
training loss. but what is1
npn
n=1en? it is exactly the sample average of en. therefore, by
analyzing the sample average ewe will learn something about the generalization capability
of our model.
how should we study the sample average? by understanding the law of large numbers
and the central limit theorem, as we have seen in this chapter.
law of large numbers: xconverges to the true mean µasngrows.
central limit theorem: the cdf of xcan be approximated by the cdf of a
gaussian, as ngrows.
performance guarantee? the other topic we discussed in this chapter is the concept
of convergence type. there are essentially four types of convergence, ranked in the order of
restrictions.
deterministic convergence : a sequence of deterministic numbers converges to
another deterministic number. for example, the sequence 1 ,1
2,1
3,1
4, . . .converges
to 0 deterministically. there is nothing random about it.
almost sure convergence : randomness exists, and there is a probabilistic con-
vergence. almost sure convergence means that there is zero probability of failure
after a finite number of failures.
convergence in probability : the sequence of probability values converges, i.e.,
the chance of failure is going to zero. however, you can still fail even if your n
is large.
convergence in distribution : the probability values can be approximated by
the cdf of a gaussian.
6.6 references
moment-generating and characteristic functions
6-1 dimitri p. bertsekas and john n. tsitsiklis, introduction to probability , athena sci-
entific, 2nd edition, 2008. chapter 4.4.
381chapter 6. sample statistics
6-2 alberto leon-garcia, probability, statistics, and random processes for electrical en-
gineering , prentice hall, 3rd edition, 2008. chapters 4.5 and 4.7.
6-3 athanasios papoulis and s. unnikrishna pillai, probability, random variables and
stochastic processes , mcgraw-hill, 4th edition, 2001. chapters 5.5 and 7.2.
6-4 henry stark and john woods, probability and random processes with applications
to signal processing , prentice hall, 3rd edition, 2001. chapters 4.5 and 4.7.
6-5 sheldon ross, a first course in probability , prentice hall, 8th edition, 2010. chapter
7.7.
6-6 john a. gubner, probability and random processes for electrical and computer en-
gineers , cambridge university press, 2006. chapter 4.3.
basic probability inequality
6-7 dimitri p. bertsekas and john n. tsitsiklis, introduction to probability , athena sci-
entific, 2nd edition, 2008. chapter 5.1.
6-8 alberto leon-garcia, probability, statistics, and random processes for electrical en-
gineering , prentice hall, 3rd edition, 2008. chapters 6 and 8.
6-9 athanasios papoulis and s. unnikrishna pillai, probability, random variables and
stochastic processes , mcgraw-hill, 4th edition, 2001. chapter 7.4.
6-10 sheldon ross, a first course in probability , prentice hall, 8th edition, 2010. chapter
8.2.
6-11 larry wasserman, all of statistics , springer 2003. chapter 4.
concentration inequalities
6-12 larry wasserman, all of statistics , springer 2003. chapter 4.
6-13 martin wainwright, high-dimensional statistics , cambridge university press, 2019.
chapter 2.1.
6-14 stephane boucheron, gabor lugosi and pascal massart, concentration inequalities ,
oxford university press, 2013. chapters 2.1 and 2.2.
law of large numbers
6-15 dimitri p. bertsekas and john n. tsitsiklis, introduction to probability , athena sci-
entific, 2nd edition, 2008. chapters 5.2, 5.3, 5.5.
6-16 alberto leon-garcia, probability, statistics, and random processes for electrical en-
gineering , prentice hall, 3rd edition, 2008. chapters 7.1, 7.2, 7.4
6-17 athanasios papoulis and s. unnikrishna pillai, probability, random variables and
stochastic processes , mcgraw-hill, 4th edition, 2001. chapter 7.4.
3826.7. problems
6-18 sheldon ross, a first course in probability , prentice hall, 8th edition, 2010. chapter
8.2, 8.4.
6-19 john a. gubner, probability and random processes for electrical and computer en-
gineers , cambridge university press, 2006. chapters 3.3, 14.1, 14.3.
6-20 larry wasserman, all of statistics , springer 2003. chapter 5.1 - 5.3.
6-21 patrick billingsley, probability and measure , wiley 1995. section 22.
central limit theorem
6-22 dimitri p. bertsekas and john n. tsitsiklis, introduction to probability , athena sci-
entific, 2nd edition, 2008. chapter 5.4.
6-23 alberto leon-garcia, probability, statistics, and random processes for electrical en-
gineering , prentice hall, 3rd edition, 2008. chapter 7.3.
6-24 athanasios papoulis and s. unnikrishna pillai, probability, random variables and
stochastic processes , mcgraw-hill, 4th edition, 2001. chapter 7.4.
6-25 sheldon ross, a first course in probability , prentice hall, 8th edition, 2010. chapter
8.3.
6-26 john a. gubner, probability and random processes for electrical and computer en-
gineers , cambridge university press, 2006. chapters 5.6, 14.2.
6-27 larry wasserman, all of statistics , springer 2003. chapter 5.4.
6-28 patrick billingsley, probability and measure , wiley 1995. section 27.
6.7 problems
exercise 1. (video solution)
letx,y,zbe three independent random variables:
x∼bernoulli( p), y ∼exponential( α), z ∼poisson( λ)
find the function for the following random variables.
(a)u=y+z
(b)u= 2z+ 3
(c)u=xy
(d)u= 2xy+ (1−x)z
383chapter 6. sample statistics
exercise 2. (video solution)
two random variables xandyhave the joint pmf
p(x=n, y=m) =λn+m
1λm
2
(n+m)!m!e−(λ1+λ2), m = 0,1,2, . . . , n ≥ −m.
letz=x+y. find the function mz(s) and the pmf of z.
exercise 3. (video solution)
letx0, x1, . . .be a sequence of independent random variables with pdf
fxk(x) =ak
π(a2
k+x2), a k=1
2k+1,
fork= 0,1, . . .. find the pdf of y, where
y=∞x
k=0xk.
hint: you may find the characteristic function useful.
exercise 4.
the random variables xandyare independent and have pdfs
fx(x) =(
e−x, x ≥0,
0, x < 0,and fy(y) =(
0, y > 0,
et, y ≤0.
find the pdf of z=x+y. (hint: use the characteristic function and the moment-
generating function.)
exercise 5.
a discrete random variable xhas a pmf
px(k) =1
2k, k = 1,2, . . . .
find the characteristic function φ x(jω).
exercise 6.
lett1, t2, . . .be i.i.d. random variables with pdf
ftk(t) =(
λe−λt, t ≥0,
0, t < 0,
fork= 1,2,3, . . .. let sn=pn
k=1tk. find the pdf of sn.
exercise 7. (video solution)
in this exercise we will prove a variant of chebyshev when the variance σ2is unknown but
xis bounded between a≤x≤b.
3846.7. problems
(a) let γ∈r. find a γthat minimizes e[(x−γ)2]. hence, show that e[(x−γ)2]≥var[x]
for any γ.
(b) let γ= (a+b)/2. show that
e[(x−γ)2] =e[(x−a)(x−b)] +(b−a)2
4.
(c) from (a) and (b), show that var[ x]≤(b−a)2
4.
(d) show that for any ε >0,
p[|x−µ|> ε]≤(b−a)2
4ε2.
exercise 8.
the random variables xandyare independent with pdfs
fx(x) =1
π(1 +x2)and fy(y) =1
π(1 +y2),
respectively. find the pdf of z=x−y. (hint: use the characteristic function.)
exercise 9.
a random variable xhas the characteristic function
φx(jω) =e−jω/(1−jω).
find the mean and variance of x.
exercise 10.
show that for any random variables xandy,
p[|x−y|> ϵ]≤1
ϵ2e[(x−y)2].
exercise 11.
letxbe an exponential random variable with a parameter λ. let µ=e[x] and σ2=
var[x]. compute p[|x−µ| ≥kσ] for any k >1. compare this to the bound obtained by
chebyshev’s inequality.
exercise 12.
letx1, . . . , x nbe i.i.d. bernoulli with a parameter p. let α >0 and define
ϵ=s
1
2nlog2
α
.
385chapter 6. sample statistics
letxn=1
npn
n=1xn. define an interval
i=
xn−ϵ,xn+ϵ
.
use hoeffding’s inequality to show that
p[icontains p]≥1−α.
exercise 13.
letz∼gaussian(0 ,1). prove that for any ϵ >0,
p[|z|> ϵ]≤r
2
πe−ϵ2
2
ϵ.
hint: note that ϵp[|z|> ϵ] = 2 ϵp[z > ϵ ], and then follow the procedure we used to prove
markov’s inequality.
exercise 14.
(a) give a non-negative random variable x≥0 such that markov’s inequality is met with
equality. hint: consider a discrete random variable.
(b) give a random variable xsuch that chebyshev’s inequality is met with equality.
exercise 15.
consider a random variable xsuch that
e[esx]≤es2σ2
2.
(a) show that for any t,
p[x≥t]≤exp
−t2
2σ2
.
hint: use chernoff’s bound.
(b) show that
e[x2]≤4σ2.
hint: first prove that e[x2] =r∞
0p[x2≥t]dt. then use part (a) above.
exercise 16.
letx1, . . . , x nbe i.i.d. uniform random variables distributed over [0 ,1]. suppose y1, . . . , y n
are defined as follows.
(a)yn=xn/n
(b)yn= (xn)n
(c)yn= max( x1, . . . , x n)
3866.7. problems
(d)yn= min( x1, . . . , x n)
for (a), (b), (c), and (d), show that ynconverges in probability to some limit. identify the
limit in each case.
exercise 17.
letλn=1
nforn= 1,2, . . .. let xn∼poisson( λn). show that xnconverges in probability
to 0.
exercise 18.
lety1, y2, . . .be a sequence of random variables such that
yn=(
0, with probability 1 −1
n,
2n, with probability1
n.
does ynconverge in probability to 0?
exercise 19. (video solution)
a laplace random variable has a pdf
fx(x) =λ
2e−λ|x|, λ > 0,
and the variance is var[ x] =2
λ2. let x1, . . . , x 500be a sequence of i.i.d. laplace random
variables. let
m500=x1+···+x500
500.
(a) find e[x]. express your answer in terms of λ.
(b) let λ= 10. using chebyshev’s inequality, find a lower bound of
p[−0.1≤m500≤0.1].
(c) let λ= 10. using the central limit theorem, find the probability
p[−0.1≤m500≤0.1].
you may leave your answer in terms of the φ( ·) function.
exercise 20. (video solution)
letx1, . . . , x nbe a sequence of i.i.d. random variables such that xi=±1 with equal
probability. let
yn=1√nnx
i=1xi.
prove the central limit theorem for this particular sequence of random variables by showing
that
387chapter 6. sample statistics
(a)e[yn] = 0, var[ yn] = 1.
(b) the function of ynismyn(s)→es2
2asn→ ∞ .
exercise 21. (video solution)
letx1, . . . , x nbe a sequence of i.i.d. random variables with mean and variance
e[xn] =µand var[ xn] =σ2, n = 1, . . . , n.
the distribution of xnis, unknown. let
mn=1
nnx
n=1xn.
use the central limit theorem to estimate the probability p[mn>2µ].
388chapter 7
regression
starting with this chapter, we will discuss several combat skills — techniques that we use
to do the actual data analysis. the theme of this topic is learning andinference , which are
both at the core of modern data science. the word “learning” can be broadly interpreted
as seeking the best model to explain the data, and the word “inference” refers to prediction
and recovery. here, prediction means that we use the observed data to forecast or generalize
to unseen situations, whereas recovery means that we try to restore the missing data in our
current observations. in this chapter we will learn regression , one of the most widely used
learning and inference techniques.
regression is a process for finding the relationship between the inputs and the outputs.
in a regression problem, we consider a set of input data {x1, . . . , x n}and a set of output
data{y1, . . . , y n}. we call the set of these input-output pairs ddef={(x1, y1), . . . , (xn, yn)}
thetraining data . the true relationship between an xnand a ynis unknown. we do not
know, you do not know, only god knows. we denote this unknown relationship as a mapping
f(·) that takes xnand maps it to yn,
yn=f(xn),
as illustrated in figure 7.1 .
figure 7.1: a regression problem is about finding the best approximation to the input-output relationship
of the data.
since we do not know f(·), finding it from a set of finite number of data points d=
{(x1, y1), . . . , (xn, yn)}is infeasible — there are infinitely many ways we can make yn=
f(xn) for every n= 1, . . . , n . the idea of regression is to add a structure to the problem.
instead of looking for f(·), we find a proxy gθ(·). this proxy gθ(·) takes a certain parametric
form. for example, we can postulate that ( xn, yn) has a linear relationship, and so
gθ(xn) = θ1|{z}
parameterxn+ θ0|{z}
parameter, n = 1, . . . , n.
389chapter 7. regression
this equation is a straight line with a slope θ1and a y-intercept θ0. we call θ= [θ1, θ0]
theparameter of the model f(·). to emphasize that the function we are using here is
parameterized byθ, we denote the function by gθ(·).
of course, any model we choose is our guess . it will never be the true model. there is
always a difference between what our model tells us and what we have observed. we denote
this “difference” or “error” by enand define it as:
en=yn−gθ(xn), n = 1, . . . , n.
the purpose of regression is to find the best θsuch that the error is minimized. for example,
consider a minimization of the sum-square error:
bθ= argmin
θ∈rdnx
n=1(yn−gθ(xn))2
| {z }
training loss etrain(θ).
the sum of the squared error is just one of the many possible ways we can define the training
lossetrain(θ). we will discuss different ways to define the training loss in this chapter, but the
point should be evident. for a given dataset d={(x1, y1), . . . , (xn, yn)}, regression tries
to find a function gθ(·) such that the training loss is minimized. the optimization variable
is the parameter θ. if the function gθ(·) is a linear function in θ, we call the regression a
linear regression .
figure 7.2: a regression problem involves several steps: picking a model gθ, defining the training loss
etrain(θ), and solving the optimization to update θ.
a summary of the regression process is shown in figure 7.2 . given the training data
d={(x1, y1), . . . , (xn, yn)}, the user picks a model gθ(·) to make a prediction. we com-
pare the predicted value gθ(xn) with the observed value yn, and compute the training loss
etrain(θ). the training loss etrain(θ) is a function of the model parameter θ. different model
parameters θgive different training loss. we solve an optimization problem to find the best
model parameter. in practice, we often iterate the process for a few times until the training
loss is settled down.
390what is regression?
given the data points ( x1, y1), . . . , (xn, yn), regression is the process of finding
the parameter θof a function gθ(·) such that the training loss is minimized:
bθ= argmin
θ∈rdnx
n=1l(yn, gθ(xn))
| {z }
training loss etrain(θ), (7.1)
where l(·,·) is the loss between a pair of true observation ynand the prediction gθ(xn).
one common choice of l(·,·) isl(gθ(xn), yn) = (gθ(xn)−yn)2.
example 1. fitting the data
suppose we have a set of data points ( x1, y1), (x2, y2), . . . , ( xn, yn), where xn’s are the
inputs and yn’s are the outputs. these pairs of data points can be plotted in a scatter plot,
as shown in figure 7.3 . we want to find the curve that best fits the data.
to solve this problem, we first need to choose a model, for example
gθ(xn) =θ0+θ1xn+θ2x2
n+θ3x3
n+θ4x4
n.
we call the coefficients θ= [θ0, θ1, θ2, θ3, θ4] the regression coefficients . they can be found
by solving the optimization problem
minimize
θ0,θ1,θ2,θ3,θ4nx
n=1
yn−(θ0+θ1xn+θ2x2
n+θ3x3
n+θ4x4
n)2
.
-1 -0.5 0 0.5 1-3-2-101234
data
fitted curve
figure 7.3: regression can be used to fit the dataset using curves. in this example, we use a fourth-th
order polynomial gθ(x) =p4
p=0θpxp
nto fit a 50-point dataset.
this optimization asks for the best θ= [θ0, . . . , θ 4]tsuch that the training loss is
minimized. solving the minimization problem would require some effort, but if we imagine
that we have solved it we can find the best curve, which is gθ(x) =p4
p=0θpxp
nwith the
optimal θplugged in. the red curve in figure 7.3 shows an example in which we have used
a fourth-order polynomial to fit a dataset comprising 50 data points. we will learn how to
solve the problem in this chapter.
391chapter 7. regression
example 2. predicting the stock market
imagine that you have bought some shares in the stock market. you have looked at the past
data, and you want to predict the price of the shares over the next few days. how would
you do it besides just eyeballing the data?
first, you would plot the data points on a graph. mathematically, we can denote these
data points as {x1, x2, . . . , x n}, where the indices n= 1,2, . . . , n can be treated as time
stamps. we assume a simple model to describe the relationship between the xn’s, say
xn≈axn−1+bxn−2,
for some parameters θ= (a, b).1this model assumes that the current value xncan be
approximated by a linear combination of two previous values xn−1andxn−2. therefore, if
we have x1andx2we should be able to predict x3, and if we have x2andx3we should be
able to predict x4, etc. the magic of this prediction comes from the parameters aandb. if
we know aandb, the prediction can be done by simply plugging in the numbers.
the regression problem here is to estimate the parameters aandbfrom the data. since
we are given a set of training data {x1, x2, . . . , x n}, we can check whether our predicted
valuebx3is close to the true x3, and whether our predicted value bx4is close to the true x4,
etc. this leads to the optimization
(ba,bb) = argmin
a,bnx
n=1
xn−(axn−1+bxn−2)| {z }
=prediction2
,
where we use initial conditions that x0=x−1= 0. the optimization problem requires us
to minimize the disparity between xnand the predicted value axn−1+bxn−2, for all n.
by finding the ( a, b) that minimizes this objective function, we will accomplish our goal of
estimating the best ( a, b).
figure 7.4 shows an example of predicting a random process using the above model.
if the parameters aandbare properly determined, we will obtain a reasonably well-fitted
curve to the data. a simple extrapolation to the future timestamp would suffice for the
forecast task.
plan for this chapter
what are the key ingredients of regression?
learning : formulate the regression problem as an optimization problem, and
solve it by finding the best parameters.
inference : use the estimated parameters and models to predict the unseen data
points.
regression is too broad a topic to be covered adequately in a single chapter. accord-
ingly, we will present a few principles and a few practical algorithmic techniques that are
broadly applicable to many (definitely not all) regression tasks. these include the following.
1caution: if you lose money in the stock market by following this naive model, please do not cry. this
model is greatly oversimplified and probably wrong.
3920 0.2 0.4 0.6 0.8 1-1-0.500.511.5
data
best fit
candidatefigure 7.4: an autoregression model aims at learning the model parameters based on the previous
samples. this example illustrates fitting the data using the model xn=axn−1+bxn−2, forn= 1, . . . , n .
theprinciple of regression (section 7.1). we explain the formulation of a regression
problem via optimization. there are a few steps involved in developing this concept.
first, we will exclusively focus on linear models because these models are easier to
analyze than nonlinear models but are still rich enough for many practical problems.
we will discuss how to solve the linear regression problem and some applications of
the solutions. we then address the issue of outliers using a concept called the robust
linear regression .
overfitting (section 7.2). the biggest practical challenge of regression is overfitting .
overfitting occurs when a model fits too closely to the training samples so that it
fails to generalize . we will delve deeply into the roots of overfitting and show that
overfitting depends on three factors: the number of training samples n, the model
complexity d, and the magnitude of noise σ2.
bias-variance trade-off (section 7.3). we will present one of the most fundamental
results in learning theory, known as the bias-variance trade-off. it applies to allregres-
sion problems, not just to linear models. understanding this trade-off will help you
understand the fundamental limits of your problem so that you know what to expect
from the model.
regularization (section 7.4). in this section we discuss a technique for combatting
overfitting known as regularization . regularization is carried out by adding an extra
term to the regression objective function. by solving the modified optimization, the
regression solution is improved in two ways: (i) regularization makes the regression
solution less sensitive to noise perturbations, and (ii) it alleviates the fitting difficulty
when we have only a few training samples. we will discuss two regularization strategies:
theridge regression and the lasso regression .
much of this chapter deals with optimization. if this is your first time reading this
book, we encourage you to have a reference book on linear algebra at hand.
393chapter 7. regression
7.1 principles of regression
we start by recalling our discussion in the introduction. the purpose of regression can be
summarized in a simple statement:
given the data points ( x1, y1), . . . , (xn, yn), find the parameter θof a function gθ(·)
such that the training loss is minimized:
bθ= argmin
θ∈rdnx
n=1l(yn, gθ(xn))
| {z }
training loss etrain(θ), (7.2)
where l(·,·) is the loss between a pair of true observation ynand the prediction gθ(xn).
when the context makes it clear, we will drop the subscript θingθ(·) with the understanding
that the function g(·) is parameterized by θ.
as you can see, regression finds a function g(·) that best approximates the input-output
relationship between xnandyn. there are two choices we need to make when formulating
a regression problem:
function g(·): what is the family of functions we want to use? this could be a line, a
polynomial, or a set of basis functions. if it is a polynomial, what is its order? we need
to make all these decisions before running the regression. a poor choice of function
family can lead to a poor regression result.
loss “l(·,·)”: how do we measure the closeness between ynandg(xn)? are we measur-
ing in terms of the squared error ( yn−g(xn))2, or the absolute difference |yn−g(xn)|,
or something else? again, a poor choice of distance function can create a false sense
of closeness because you might be optimizing for a wrong objective.
before we delve into the details, we need to discuss briefly the connection between
regression and probability. a regression problem can be solved without knowing probability,
so why is regression discussed in a book on probability?
this question is related to how much we know about the statistical model and what
kind of optimality we are seeking. a full answer requires some understanding of maximum
likelihood estimation and maximum a posteriori estimation, which will be explained in
chapter 8. as a quick preview of our results, we summarize the key ideas below:
how is regression related to probability?
if you know the statistical relationship between xnandyn, then we can construct
a regression problem that maximizes the likelihood of the underlying distribu-
tion. such regression solution is optimal with respect to the likelihood.
we can construct a regression problem that can minimize the expectation of the
3947.1. principles of regression
squared error. this regression solution is mean-squared optimal .
if you are a bayesian and you know the prior distribution of xn, then we can
construct a regression problem that maximizes the posterior distribution. the
solution to this regression problem is bayesian optimal .
if you know nothing about the statistics of xnandyn, you can still run the
regression and get something, and this “something” can be very useful. however,
you cannot claim statistical optimality of this “something”.
see chapter 8 for additional discussion.
it is important to understand that a regression problem is at the intersection of op-
timization andstatistics . the need for optimization is clear because we need to minimize
the error. the statistical need is to generalize to unknown data. if there is no statistical
relationship between xnandyn(for all n), whatever model we obtain from the regression
will only work for the ntraining samples. the model will not generalize because knowing
xnwill not help us know yn. in other words, if there is no statistical relationship between
xnandyn, you can fit perfectly to the training data but you will fail miserably to fit the
testing data.
7.1.1 intuition: how to fit a straight line?
in this subsection we want to give you the basic idea of how regression is formulated. to
keep things simple, we will discuss how to fit data using a straight line.
consider a collection of data points d={(x1, y1), . . . , (xn, yn)}, where xn’s are the
inputs and yn’s are the observations, for example, in the table below.
n x n yn
1 0.6700 3.0237
2 0.3474 2.3937
3 0.6695 3.5548
.........
n−1 0.2953 2.6396
n 0.6804 3.2536
let us consider the linear regression problem. the goal of linear regression is to find
thestraight line that best fits the datasets. all straight lines on a 2d graph are plots of the
equation
g(x) =ax+b,
where ais the slope of the line and bis the y-intercept of the line. we denote this line
byg(·). note that this function gis characterized by two parameters ( a, b) because once
(a, b) are known the line is determined. if we change ( a, b), the line will change as well.
therefore, by finding the bestline we are essentially searching for the best ( a, b) such that
the training error is minimized.
the pictorial meaning of linear regression can easily be seen in figure 7.5 , which
shows n= 50 data points according to some latent distributions. given these 50 data
points, we construct several possible candidates for the regression model. these candidates
395chapter 7. regression
are characterized by the parameters ( a, b). for example, the parameters ( a, b) = (1 ,2) and
(a, b) = (−2,3) represent two different straight lines in the candidate pool. the goal of the
regression is to find the best line from these candidates. note that since we limit ourselves
to straight lines, the candidate set will not include polynomials or trigonometric functions.
these functions are outside the family we are considering.
0 0.2 0.4 0.6 0.8 11.522.533.544.5
data
best fit
candidate
figure 7.5: the objective of least squares fitting (or linear regression) is to find a line that best fits the
dataset.
given these candidate functions, we need to measure the the training loss. this can
be defined in multiple ways, such as
sum-squared loss etrain(θ) =pn
n=1(yn−g(xn))2.
sum-absolute loss etrain(θ) =pn
n=1|yn−g(xn)|.
cross-entropy loss etrain(θ) =−pn
n=1(ynlogg(xn) + (1 −yn) log(1 −g(xn))).
perceptual loss etrain(θ) =pn
n=1max(−yng(xn),0), when ynandg(xn) are binary
taking values ±1. this is a reasonable training error because if ynmatches with g(xn),
then yng(xn) = 1 and so max( −yng(xn),0) = 0. but if yndoes not match with g(xn),
then yng(xn) =−1 and hence max( −yng(xn),0) = 1. thus, the loss captures the sum
of all the mismatched pairs.
choosing the loss function is problem-specific. it is also where probability enters the picture
because, without any knowledge about the distributions of xnandyn, there is no way to
choose the best training loss. you can still pick one, as we will do, but it will not be granted
any probabilistic guarantees.
among these possible choices of the training error, we are going to focus on the sum-
squared loss because it is convex anddifferentiable . this makes the computation easy,
since we can run any textbook optimization algorithm. the regression problem under the
sum-squared loss is:

ba,bb
= argmin
(a,b)nx
n=1
yn−(axn+b)|{z}
=g(xn)2
. (7.3)
in this equation, the symbol “argmin” means “argument minimize”, which returns the ar-
gument that minimizes the cost function on the right. the interpretation of the equation is
3967.1. principles of regression
that we seek the ( a, b) that minimize the sumpn
n=1(yn−(axn+b))2. since we are mini-
mizing the squared error, this linear regression problem is also known as the least squares
fitting problem. the idea is summarized in the following box.
what is linear least squares fitting?
find a line g(x) =ax+bthat best fits the training data {(xn, yn)}n
n=1.
the optimality criterion is to minimize the squared error
etrain(θ) =nx
n=1
yn−g(xn)2
, (7.4)
where θ= (a, b) is the model parameter.
there exist other optimality criteria. squared error is convex and differentiable.
7.1.2 solving the linear regression problem
let’s consider how to solve the linear regression problem given by equation (7.3). the
problem is the following:
ba,bb
= argmin
(a,b)etrain(a, b). (7.5)
as with any two-dimensional optimization problem, the optimal point ( ba,bb) should
have a zero gradient, meaning that
∂
∂aetrain(a, b) = 0 and∂
∂betrain(a, b) = 0 .
this should be familiar to you, even if you have only learned basic calculus. this pair of
equations says that, at a minimum point, the directional slopes should be zero no matter
which direction you are looking at.
the derivative with respect to ais
∂
∂aetrain(a, b)
=∂
∂anx
n=1
yn−(axn+b)2
=∂
∂a
y1−(ax1+b)2
+
y2−(ax2+b)2
+···+
yn−(axn+b)2
= 2
y1−(ax1+b)
(−x1) +···+ 2
yn−(axn+b)
(−xn)
= 2 
−nx
n=1xnyn+anx
n=1x2
n+bnx
n=1xn!
.
397chapter 7. regression
similarly, the derivative with respect to bis
∂
∂betrain(a, b) =∂
∂bnx
n=1
yn−(axn+b)2
= 2
y1−(ax1+b)
(−1) +···+ 2
yn−(axn+b)
(−1)
= 2 
−nx
n=1yn+anx
n=1xn+bnx
n=11!
.
setting these two equations to zero, we have that
2 
−nx
n=1ynxn+anx
n=1x2
n+bnx
n=1xn!
= 0,
2 
−nx
n=1yn+anx
n=1xn+bnx
n=11!
= 0.
rearranging the terms, the pair can be equivalently written as

np
n=1x2
nnp
n=1xn
np
n=1xn n
a
b
=
np
n=1xnyn
np
n=1yn
.
therefore, if we can solve this system of linear equations, we will have the linear regression
solution.
remark . it is easy to see that the solution achieves the minimum instead of the maximum,
since the second-order derivatives are positive:
∂2
∂a2etrain(a, b) =nx
n=1x2
n≥0 and∂2
∂b2etrain(a, b) =nx
n=11>0.
the following theorem summarizes this intermediate result.
theorem 7.1. the solution of the problem equation (7.5)

ba,bb
=argmin
(a,b)nx
n=1
yn−(axn+b)2
satisfies the equation

np
n=1x2
nnp
n=1xn
np
n=1xn n
ba
bb
=
np
n=1xnyn
np
n=1yn
. (7.6)
3987.1. principles of regression
matrix-vector form of linear regression
solving this linear regression requires some basic linear algebra. the regression can be
written as 
y1
...
yn

|{z}
y=
x11
......
xn1

|{z}
xa
b
|{z}
θ+
e1
...
en

|{z}
e.
with x,y,θande, we can write the linear regression problem compactly as
y=xθ+e.
therefore, the training loss etrain(θ) can be defined as
etrain(θ) =∥y−xθ∥2
=
y1
...
yn
−
x11
......
xn1
a
b2
=nx
n=1
yn−(axn+b)2
.
now, taking the gradient with respect to θyields2
∇θetrain(θ) =∇θ
∥y−xθ∥2
=−2xt(y−xθ).
equating this to zero, we obtain
xt(y−xθ) = 0 ⇐⇒ xtxθ=xty. (7.7)
equation (7.7) is called the normal equation .
the normal equation is a convenient way of constructing the system of linear equations.
using the 2-by-2 system shown in equation (7.6) as an example, we note that
xtx=
x1···xn
1··· 1
x11
......
xn1
=
np
n=1x2
nnp
n=1xn
np
n=1xn n
,
xty=
x1···xn
1··· 1
y1
...
yn
=
np
n=1xnyn
np
n=1yn
.
therefore, as long as you can construct the xmatrix, forming the 2-by-2 system in equa-
tion (7.6) is straightforward: start with y=xθand then multiply the matrix transpose
xtto both sides. the resulting system is what you need. there is nothing to memorize.
2this is a basic vector calculus result. for details, you may consult standard texts such as the university
of waterloo’s matrix cookbook. https://www.math.uwaterloo.ca/ ~hwolkowi/matrixcookbook.pdf
399chapter 7. regression
running linear regression on a computer
on a computer, solving the linear regression for a line is straightforward. let us look at the
matlab code first.
% matlab code to fit data points using a straight line
n = 50;
x = rand(n,1)*1;
a = 2.5; % true parameter
b = 1.3; % true parameter
y = a*x + b + 0.2*rand(size(x)); % synthesize training data
x = [x(:) ones(n,1)]; % construct the x matrix
theta = x\y(:); % solve y = x theta
t = linspace(0, 1, 200); % interpolate and plot
yhat = theta(1)*t + theta(2);
plot(x,y,’o’,’linewidth’,2); hold on;
plot(t,yhat,’r’,’linewidth’,4);
in this piece of matlab code, we need to define the data matrix x. here, x(:) is the
column vector that stores all the values ( x1, . . . , x n). the all-one vector ones(n,1) is the
second column in our xmatrix. the command x\y(:) is equivalent to solving the normal
equation
xtxθ=xty.
the last few lines are used to plot the predicted curve. note that theta(1) andtheta(2)
are the entries of the solution θ. the result of this program is exactly the plot shown in
figure 7.5 above.
in python, the program is quite similar. the command we use to solve the inversion
isnp.linalg.lstsq .
# python code to fit data points using a straight line
import numpy as np
import matplotlib.pyplot as plt
n = 50
x = np.random.rand(n)
a = 2.5 # true parameter
b = 1.3 # true parameter
y = a*x + b + 0.2*np.random.randn(n) # synthesize training data
x = np.column_stack((x, np.ones(n))) # construct the x matrix
theta = np.linalg.lstsq(x, y, rcond=none)[0] # solve y = x theta
t = np.linspace(0,1,200) # interpolate and plot
yhat = theta[0]*t + theta[1]
plt.plot(x,y,’o’)
plt.plot(t,yhat,’r’,linewidth=4)
4007.1. principles of regression
7.1.3 extension: beyond a straight line
regression is a powerful technique. although we have discussed its usefulness for fitting
straight lines, the same concept can fit other curves.
to generalize the regression formulation, we consider a d-dimensional regression coef-
ficient vector θ= [θ0, . . . , θ d−1]t∈rdand a general linear model
gθ(xn) =d−1x
p=0θpϕp(xn).
here, the mappings {ϕp(·)}d−1
p=0can be considered as a nonlinear transformation that takes
the input xnand maps it to another value. for example, ϕp(·) = (·)pwill map an input x
to apth power xp.
we can now write the system of linear equations as

y1
y2
...
yn

|{z}
y=
ϕ0(x1)ϕ1(x1)··· ϕd−1(x1)
ϕ0(x2)ϕ1(x2)··· ϕd−1(x2)
... ···......
ϕ0(xn)ϕ1(xn)···ϕd−1(xn)

| {z }
x
θ0
θ1
...
θd−1

|{z}
θ+
e1
e2
...
en

|{z}
e. (7.8)
let us look at some examples.
example 7.1 . (quadratic fitting ) consider the linear regression problem using a
quadratic equation:
yn=ax2
n+bxn+c, n = 1, . . . , n.
express this equation in matrix-vector form.
solution . the matrix-vector expression is

y1
y2
...
yn
=
x2
1x11
x2
2x21
.........
x2
nxn1

a
b
c
+
e1
e2
...
en
.
this is again in the form of y=xθ+e.
the matlab and python programs for example 7.1 are shown below. a numerical
example is illustrated in figure 7.6 .
% matlab code to fit data using a quadratic equation
n = 50;
x = rand(n,1)*1;
a = -2.5;
b = 1.3;
c = 1.2;
401chapter 7. regression
0 0.2 0.4 0.6 0.8 100.511.522.5
data
fitted curve
figure 7.6: example: our goal is to fit the dataset of 50 data points shown above. the model we use
isgθ(xn) =ax2
n+bxn+c, forn= 1, . . . , n .
y = a*x.^2 + b*x + c + 1*rand(size(x));
n = length(x);
x = [ones(n,1) x(:) x(:).^2];
beta = x\y(:);
t = linspace(0, 1, 200);
yhat = theta(3)*t.^2 + theta(2)*t + theta(1);
plot(x,y, ’o’,’linewidth’,2); hold on;
plot(t,yhat,’r’,’linewidth’,6);
# python code to fit data using a quadratic equation
import numpy as np
import matplotlib.pyplot as plt
n = 50
x = np.random.rand(n)
a = -2.5
b = 1.3
c = 1.2
y = a*x**2 + b*x + c + 0.2*np.random.randn(n)
x = np.column_stack((np.ones(n), x, x**2))
theta = np.linalg.lstsq(x, y, rcond=none)[0]
t = np.linspace(0,1,200)
yhat = theta[0] + theta[1]*t + theta[2]*t**2
plt.plot(x,y,’o’)
plt.plot(t,yhat,’r’,linewidth=4)
the generalization to polynomials of arbitrary order is to replace the model with
gθ(xn) =d−1x
p=0θpxp,
4027.1. principles of regression
where p= 0,1, . . . , d −1 represent the orders of the polynomials and θ0, . . . , θ d−1are the
regression coefficients . in this case, the matrix system is

y1
y2
...
yn
=
1x1···xd−1
1
1x2···xd−1
2...···......
1xn···xd−1
n

θ0
θ1
...
θd−1
+
e1
e2
...
en
,
which again is in the form of y=xθ+e.
example 7.2 . (legendre polynomial fitting ) let {lp(·)}d−1
p=0be a set of legendre
polynomials (see discussions below), and consider the linear regression problem using
yn=d−1x
p=0θplp(x), n = 1, . . . , n.
express this equation in matrix-vector form.
solution . the matrix-vector expression is

y1
y2
...
yn
=
l0(x1)l1(x1)··· ld−1(x1)
l0(x2)l1(x2)··· ld−1(x2)
... ···......
l0(xn)l1(xn)···ld−1(xn)

θ0
θ1
...
θd−1
+
e1
e2
...
en
.
legendre polynomials are orthogonal polynomials. in conventional polynomials, the
functions {x, x2, x3, . . . , xp}are not orthogonal. as we increase p, the set of functions
{x, x2, x3, . . . , xp}will have redundancy, which will eventually result in the matrix xbeing
noninvertible.
thepth-order legendre polynomial is denoted by lp(x). using the legendre polyno-
mials as the building block of the regression problem, the model is expressed as
gθ(x)def=d−1x
p=0θplp(x)
=θ0l0(x) +θ1l1(x)|{z}
=x+θ2l2(x)|{z}
=1
2(3x2−1)+···+θd−1ld−1(x),
where l0(·),l1(·) and l2(·) are the legendre polynomials of order 0, 1 and 2, respectively.
as an example, the first few leading legendre polynomials are
l0(x) = 1 ,
l1(x) =x,
l2(x) =1
2(3x2−1),
l3(x) =1
2(5x3−3x).
403chapter 7. regression
the order of the legendre polynomials is always the same as that of the ordinary polyno-
mials. the shapes of these polynomials are shown in figure 7.7 (a).
-1 -0.5 0 0.5 1-1-0.500.51
l0(x)
l1(x)
l2(x)
l3(x)
l4(x)
-1 -0.5 0 0.5 1-2-101234
data
legendre basis
polynomial basis
(a) (b)
figure 7.7: (a) the first 5 leading legendre polynomials plotted in the range of −1≤x≤1. (b) fitting
the data using an ordinary polynomial and a legendre polynomial.
figure 7.7 (b) demonstrates a fitting problem using the legendre polynomials. you
can see that the fitting is just as good as that of the ordinary polynomials (which should
be the case). however, if we compare the coefficients, we observe that the magnitude of
the legendre coefficients is smaller (see table 7.1 ). in general, as the order of polynomials
increases and the noise grows, the ordinary polynomials will become increasingly difficult to
fit the data.
θ4 θ3 θ2 θ1 θ0
ordinary polynomials 5.3061 3.3519 −3.6285 −1.8729 0.1540
legendre polynomials 1.2128 1.3408 0.6131 0.1382 0.0057
table 7.1: the regression coefficients of an ordinary polynomial and a legendre polynomial. note that
while both polynomials can fit the data, the legendre polynomial coefficients have smaller magnitudes.
calling legendre polynomials for regression is not difficult in matlab and python.
specifically, one can call legendrep in matlab and scipy.special.eval_legendre in
python.
% matlab code to fit data using legendre polynomials
n = 50;
x = 1*(rand(n,1)*2-1);
a = [-0.001 0.01 +0.55 1.5 1.2];
y = a(1)*legendrep(0,x) + a(2)*legendrep(1,x) + ...
+ a(3)*legendrep(2,x) + a(4)*legendrep(3,x) + ...
+ a(5)*legendrep(4,x) + 0.5*randn(n,1);
x = [legendrep(0,x(:)) legendrep(1,x(:)) ...
legendrep(2,x(:)) legendrep(3,x(:)) ...
4047.1. principles of regression
legendrep(4,x(:))];
beta = x\y(:);
t = linspace(-1, 1, 200);
yhat = beta(1)*legendrep(0,t) + beta(2)*legendrep(1,t) + ...
+ beta(3)*legendrep(2,t) + beta(4)*legendrep(3,t) + ...
+ beta(5)*legendrep(4,t);
plot(x,y,’ko’,’linewidth’,2,’markersize’,10); hold on;
plot(t,yhat,’linewidth’,6,’color’,[0.9 0 0]);
import numpy as np
import matplotlib.pyplot as plt
from scipy.special import eval_legendre
n = 50
x = np.linspace(-1,1,n)
a = np.array([-0.001, 0.01, 0.55, 1.5, 1.2])
y = a[0]*eval_legendre(0,x) + a[1]*eval_legendre(1,x) + \
a[2]*eval_legendre(2,x) + a[3]*eval_legendre(3,x) + \
a[4]*eval_legendre(4,x) + 0.2*np.random.randn(n)
x = np.column_stack((eval_legendre(0,x), eval_legendre(1,x), \
eval_legendre(2,x), eval_legendre(3,x), \
eval_legendre(4,x)))
theta = np.linalg.lstsq(x, y, rcond=none)[0]
t = np.linspace(-1, 1, 50);
yhat = theta[0]*eval_legendre(0,t) + theta[1]*eval_legendre(1,t) + \
theta[2]*eval_legendre(2,t) + theta[3]*eval_legendre(3,t) + \
theta[4]*eval_legendre(4,t)
plt.plot(x,y,’o’,markersize=12)
plt.plot(t,yhat, linewidth=8)
plt.show()
the idea of fitting a set of data using the legendre polynomials belongs to the larger
family of basis functions . in general, we can use a set of basis functions to model the data:
gθ(x)def=d−1x
p=0θpϕp(x),
where {ϕp(x)}d−1
p=0are the basis functions and {θp}d−1
p=0are the regression coefficients. the
constant θ0is often called the biasof the regression.
choice of the ϕp(x) can be extremely broad. one can choose the ordinary polynomials
ϕp(x) =xpor the legendre polynomial ϕp(x) =lp(x). other choices are also available:
fourier basis: ϕp(x) =ejωpx, where ωpis the pth carrier frequency.
sinusoid basis: ϕp(x) = sin( ωpx), which is same as the fourier basis but taking the
imaginary part.
405chapter 7. regression
gaussian basis: ϕp(x) =1√
2πσ2pexpn
−(x−µp)2
2σ2po
, where ( µp, σp) are the model param-
eters.
evidently, by choosing different basis functions we have different ways to fit the data. there
is no definitive answer as to which functions are better. statistical techniques such as model
selections are available, but experience will tell you to align with one and not the other. it
is frequently more useful to have some domain knowledge rather than resorting to various
computational techniques.
how to fit data using basis functions
construct this equation:

y1
y2
...
yn

|{z}
y=
ϕ0(x1)ϕ1(x1)··· ϕd−1(x1)
ϕ0(x2)ϕ1(x2)··· ϕd−1(x2)
... ···......
ϕ0(xn)ϕ1(xn)···ϕd−1(xn)

| {z }
x
θ0
θ1
...
θd−1

|{z}
θ+
e1
e2
...
en

|{z}
e, (7.9)
the functions ϕp(x) are the basis functions, e.g., ϕp(x) =xpfor ordinary poly-
nomials.
you can replace the polynomials with the legendre polynomials.
you can also replace the polynomials with other basis functions.
solve for θby
bθ= argmin
θ∥y−xθ∥2.
example 7.3 . (autoregressive model ) consider a two-tap autoregressive model:
yn=ayn−1+byn−2, n = 1,2, . . . , n
where we assume y0=y−1= 0. express this equation in the matrix-vector form.
solution . the matrix-vector form of the equation is

y1
y2
...
yn

|{z}
=y=
y0 y−1
y1 y0
......
yn−1yn−2

| {z }
=xa
b
|{z}
=θ+
e1
e2
...
en
.
in general, we can append more previous samples to predict the future. the general
4067.1. principles of regression
expression is
yn=lx
ℓ=1θℓyn−ℓ, n = 1,2, . . . , n,
where ℓ= 1,2, . . . , l denote the previous lsamples of the data and {θ1, . . . , θ l}are the
regression coefficients. if we do this we see that the matrix expression is

y1
y2
y3
y4
...
yn

|{z}
=y=
y0 y−1y−2··· y1−l
y1 y0 y−1··· y2−l
y2 y1 y0··· y3−l
y3 y2 y1··· y4−l
...............
yn−1yn−2yn−3...yn−l

| {z }
=x
θ1
θ2
...
θl

|{z}
=θ+
e1
e2
e3
e4
...
en
.
observe the pattern associated with this matrix x. each column is a one-entry shifted
version of the previous column. this matrix is called a toeplitz matrix .
the matlab (and python) code for calling and using the toeplitz matrix is shown
below.
% matlab code for auto-regressive model
n = 500;
y = cumsum(0.2*randn(n,1)) + 0.05*randn(n,1); % generate data
l = 100; % use previous 100 samples
c = [0; y(1:400-1)];
r = zeros(1,l);
x = toeplitz(c,r); % toeplitz matrix
theta = x\y(1:400); % solve y = x theta
yhat = x*theta; % prediction
plot(y(1:400), ’ko’,’linewidth’,2);hold on;
plot(yhat(1:400),’r’,’linewidth’,4);
# python code for auto-regressive model
import numpy as np
import matplotlib.pyplot as plt
from scipy.linalg import toeplitz
n = 500
y = np.cumsum(0.2*np.random.randn(n)) + 0.05*np.random.randn(n)
l = 100
c = np.hstack((0, y[0:400-1]))
r = np.zeros(l)
x = toeplitz(c,r)
theta = np.linalg.lstsq(x, y[0:400], rcond=none)[0]
yhat = np.dot(x, theta)
407chapter 7. regression
plt.plot(y[0:400], ’o’)
plt.plot(yhat[0:400],linewidth=4)
the plots generated by the above programs are shown in figure 7.8 (a). note that we
are doing an interpolation , because we are predicting the values within the training dataset.
0 100 200 300 400 500-6-4-202
0 100 200 300 400 500-6-4-202
(a) (b)
figure 7.8: autoregressive model on a simulated dataset, using l= 100 coefficients. (a) training data.
note that the model trains very well on this dataset. (b) testing data. when tested on future data, the
autoregressive model can still predict for a few samples but loses track when the time elapsed grows.
we now consider extrapolation . given the training data, we can find the regression
coefficients by solving the above linear equation. this gives us θ. to predict the future
samples we need to return to the equation
byn=lx
ℓ=1θℓ byn−ℓ|{z}
=previous estimate, n = 1,2, . . . , n,
wherebyn−ℓare the previous estimates. for example, if we are given 100 days of stock prices,
then predicting the 101st day’s price should be based on the ldays before the 101st. a
simple for-loop suffices for such a calculation.
figure 7.8 (b) shows a numerical example of extrapolating data using the autoregressive
model. in this experiment we use n= 400 samples to train an autoregressive model of order
l= 100. we then predict the data for another 100 data points. as you can see from the
figure, the first few samples still look reasonable. however, as time increases, the model
starts to lose track of the real trend.
is there any way we can improve the autoregressive model? a simple way is to increase
the memory lso that we can use a long history to predict the future. this boils down to
the long-term running average of the curve, which works well in many cases. however, if
the testing data does not follow the same distribution as the training data (which is often
the case in the real stock market because unexpected news can change the stock price),
then even the long-term average will not be a good forecast. that is why data scientists on
wall street make so much money: they have advanced mathematical tools for modeling the
stock market. nevertheless, we hope that the autoregressive model provides you with a new
perspective for analyzing data.
the summary below highlights the main ideas of the autoregressive model.
4087.1. principles of regression
what is the autoregressive model?
it solves this problem

y1
y2
y3
...
yn

|{z}
=y=
y0 y−1y−2··· y1−l
y1 y0 y−1··· y2−l
y2 y1 y0··· y3−l
...............
yn−1yn−2yn−3...yn−l

| {z }
=x
θ1
θ2
...
θl

|{z}
=θ+
e1
e2
e3
...
en

|{z}
=e. (7.10)
the number of taps in the past history would affect the memory and hence the
long-term forecast.
solve for θby
bθ= argmin
θ∈rd∥y−xθ∥2. (7.11)
7.1.4 overdetermined and underdetermined systems
the sub-section requires knowledge of some concepts in linear algebra that can be found
in standard references.a
acarl meyer, matrix analysis and applied linear algebra , siam, 2000.
let us now consider the theoretical properties of the least squares linear regression
problem, which is an optimization:
bθ= argmin
θ∈rd∥y−xθ∥2. (p1)
we observe that the objective value of this optimization problem can go to zero if and only
if the minimizer bθis the solution of the system of linear equations
findθsuch that y=xθ. (p2)
we emphasize that problem (p1) and problem (p2) are two different problems. even if we
cannot solve problem (p2), problem (p1) is still well defined, but the objective value will
not go to zero. this subsection aims to draw the connection between the two problems and
discuss the respective solutions. we will start with problem (p2) by considering two shapes
of the matrix x.
overdetermined system
problem (p2) is called overdetermined ifx∈rn×dis tall and skinny, i.e., n > d . this hap-
pens when you have more rows than columns, or equivalently when you have more equations
than unknowns. when n > d , problem (p2) has a unique solution bθ= (xtx)−1xtyif
409chapter 7. regression
and only if xtxis invertible, or equivalently if and only if the columns of xare linearly in-
dependent. a technical description of this is that xhas a full rank , denoted by rank( x) =d.
when rank( x) =d, problem (p1) has a unique global minimizer bθ= (xtx)−1xty, which
is the same as the unique solution of problem (p2).
figure 7.9: hierarchy of the solutions of an overdetermined system. an overdetermined system uses
a tall and skinny matrix x. the rank of a matrix xis defined as the largest number of independent
columns we can find in x. if rank (x) =d, the matrix xtxis invertible, and problem (p2) will have
a unique solution. if rank (x)< d, then the solution depends on whether the particular observation y
lives in the range space of x. if yes, problem (p2) will have infinitely many solutions because there is
a nontrivial null space. if no, problem (p2) will have no solution because the system is incompatible.
if the columns of xare linearly dependent so that xtxis not invertible, we say
thatxisrank-deficient (denoted as rank( x)< d). in this case, problem (p2) may not
have a solution. we say that it may not have a solution because it is still possible to have a
solution. it all depends on whether ycan be written as a linear combination of the linearly
independent columns of x.
if yes, we say that ylives in the range space ofx. the range space of xis defined
as the set of vectors {z|z=xα,for some α}. if rank( x) =d, allywill live in the range
space of x. but if rank( x)< d, only some of the ywill live in the range space of x.
when this happens, the matrix xmust have a nontrivial null space . the null space of x
is defined as the set of vectors {z|xz= 0}. a nontrivial null space will give us infinitely
many solutions to problem (p2). this is because if αis the solution found in the range
space so that y=xα, then we can pick any zfrom the null space such that xz= 0.
this will lead to another solution α+zsuch that x(α+z) =xα+ 0 = y. since we have
infinitely many choices of such z’s, there will be infinitely many solutions to problem (p2).
although there are infinitely many solutions to problem (p2), all of them are the global
minimizers of problem (p1). they can make the objective value equal to zero because the
equality y=xθholds. however, the solutions to problem (p2) are not unique since the
objective function is convex but not strictly convex.
ifydoes not live in the range space of x, we say that problem (p2) is incompatible .
if a system of linear equations is incompatible, there is no solution. however, even when
this happens, we can still solve the optimization problem (p1), but the objective value will
not reach 0. the minimizer is a global minimizer because the objective function is convex,
4107.1. principles of regression
but the minimizer is not unique.
underdetermined system
problem (p2) is called underdetermined ifxis fat and short, i.e., n < d . this happens
when you have more columns than rows, or equivalently when you have more unknowns than
equations. in this case, xtxis not invertible, and so we cannot use bθ= (xtx)−1xty
as the solution. however, if rank( x) =n, then anyywill live in the range space of x. but
because xis fat and short, there exists a nontrivial null space. therefore, problem (p2)
will have infinitely many solutions, attributed to the vectors generated by the null space.
for this set of infinitely many solutions, the corresponding problem (p1) will have a global
minimizer, and the objective value will be zero. however, the minimizer is not unique. this
is the first case in figure 7.10 .
figure 7.10: hierarchy of the solutions of an underdetermined system. an underdetermined system uses
a fat and short matrix x. the rank of a matrix xis defined as the largest number of independent
columns we can find in x. if rank (x) =n, we will have infinitely many solutions. if rank (x)< n ,
then the solutions depends on whether the particular observation ylives in the range space of x. if yes,
problem (p2) will have infinitely many solutions because there is a nontrivial null space. if no, problem
(p2) will have no solution because the system is incompatible.
there are two other cases in figure 7.10 , which occur when rank( x)< n:
(i) ifyis in the range space of x, problem (p2) will have infinitely many solutions.
since problem (p2) remains feasible, the objective function of problem (p1) will go
to zero.
(ii) if yis not in the range space of x, the system in problem (p2) is incompatible
and there will be no solution. the objective value of problem (p1) will not go to zero.
if an underdetermined system has infinitely many solutions, we need to pick and choose.
one of the possible approaches is to consider the optimization
bθ= argmin
θ∈rd∥θ∥2subject to xθ=y. (p3)
this optimization is different from problem (p1), which is an unconstrained optimization.
our goal is to minimize the deviation between xθandy. problem (p3) is constrained . since
411chapter 7. regression
we assume that problem (p2) has infinitely many solutions, the constraint set y=xθ
is feasible. among all the feasible choices, we pick the one that minimizes the squared
norm. therefore, the solution to problem (p3) is called the minimum-norm least squares.
theorem 7.2 below summarizes the solution. if ydoes not live in the range space of x,
then problem (p2) does not have a solution. therefore, the constraint in p3 is infeasible,
and hence the optimization problem does not have a minimizer.
theorem 7.2. consider the underdetermined linear regression problem where n < d :
bθ=argmin
θ∈rd∥θ∥2subject to y=xθ,
where x∈rn×d,θ∈rd, and y∈rn. if rank (x) =n, then the linear regression
problem will have a unique global minimum
bθ=xt(xxt)−1y. (7.12)
this solution is called the minimum-norm least-squares solution.
proof . the proof of the theorem requires some knowledge of constrained optimization.
consider the lagrangian of the problem:
l(θ,λ) =∥θ∥2+λt(xθ−y),
where λis called the lagrange multiplier. the solution of the constrained optimization is
the stationary point of the lagrangian. to find the stationary point, we take the derivatives
with respect to θandλ. this yields
∇θl= 2θ+xtλ= 0,
∇λl=xθ−y= 0.
the first equation gives us θ=−xtλ/2. substituting it into the second equation, and
assuming that rank( x) =nso that xtxis invertible, we have
x
−xtλ/2
−y= 0,
which implies that λ=−2(xxt)−1y. therefore, θ=xt(xxt)−1y. □
the end of this subsection. please join us again.
7.1.5 robust linear regression
this subsection is optional for a first reading of the book.
the linear regression we have discussed so far is based on an important criterion,
namely the squared error criterion. we chose the squared error as the training loss because
4127.1. principles of regression
it is differentiable and convex. differentiability allows us to take the derivative and locate
the minimum point. convexity allows us to claim a global minimizer (also unique if the
objective function is strictly convex). however, such a nice criterion suffers from a serious
drawback: the issue of outliers .
consider figure 7.11 . infigure 7.11 (a), we show a regression problem for n= 50
data points. our basis functions are the ordinary polynomials in the fourth order. everything
looks fine in the figure. we intervene in the data by randomly altering a few of them so that
their values are off. there are only a handful of these outliers. we run the same regression
analysis again, but we observe (see figure 7.11 (b)) that our fitted curve has been distorted
quite significantly.
-1 -0.5 0 0.5 1-2-101234
data
fitted curve
-1 -0.5 0 0.5 1-2-1012345
data
fitted curve
(a) (·)2without outlier (b) ( ·)2with outlier
figure 7.11: linear regression using the squared error as the training loss suffers from outliers. (a) the
regression performs well when there is no outlier. (b) by adding only a few outliers, the regression curve
has already been distorted.
this occurs because of the squared error. by the definition of a squared error, our
training loss is
etrain(θ) =nx
n=1
yn−gθ(xn)2
.
without loss of generality, let us assume that one of these error terms is large because of an
outlier. then the training loss becomes
etrain(θ) =
y1−gθ(x1)2
| {z }
small+
y2−gθ(x2)2
| {z }
small+
y3−gθ(x3)2
| {z }
large+···+
yn−gθ(xn)2
| {z }
small.
here is the daunting fact: if one or a few of these individual error terms are large, the
square operation will amplify them. as a result, the error you see is not just large but large2.
moreover, since we put the squares to the small errors as well, we have small2instead of
small. when you try to weigh the relative significance between the outliers and the normal
data points, the outliers suddenly have a very large contribution to the error. since the goal
of linear regression is to minimize the total loss, the presence of the outliers will drive the
optimization solution to compensate for the large error.
413chapter 7. regression
one possible solution is to replace the squared error by the absolute error , such that
etrain(θ) =nx
n=1yn−gθ(xn).
this is a simple modification, but it is very effective. the reason is that the absolute error
keeps the small just as small, and keeps the large just as large. there is no amplification.
therefore, while the outliers still contribute to the overall loss, their contributions are less
prominent. (if you have a lot of strong outliers, even the absolute error will fail. if this
happens, you should go back to your data collection process and find out what has gone
wrong.)
when we use the absolute error as the training loss, the resulting regression problem is
theleast absolute deviation regression (or simply the robust regression ). the tricky thing
about the least absolute deviation is that the training loss is not differentiable. in other
words, we cannot take the derivative and find the optimal solution. the good news is that
there exists an alternative approach for solving this problem: using linear programming
(implemented via the simplex method ).
solving the robust regression problem
let us focus on the linear model
gθ(xn) =xt
nθ,
where xn= [ϕ0(xn), . . . , ϕ d−1(xn)]t∈rdis the nth input vector for some basis functions
{ϕp}d−1
p=0, and θ= [θ0, . . . , θ d−1]t∈rdis the parameter. substituting this into the training
loss, the optimization problem is
minimize
θ∈rdnx
n=1yn−xt
nθ.
here is an important trick. the idea is to express the problem as an equivalent problem
minimize
θ∈rd,u∈rnnx
n=1un
subject to un=|yn−xt
nθ|, n = 1, . . . , n.
there is a small but important difference between this problem and the previous one. in the
first problem, there is only one optimization variable θ. in the new problem, we introduce an
additional variable u= [u1, . . . , u n]tand add a constraint un=|yn−xt
nθ|forn= 1, . . . , n .
we introduce uso that we can have some additional degrees of freedom. at the optimal
solution, unmust equal to |yn−xt
nθ|, and so the corresponding θis the solution of the
original problem.
now we note that x=|a|is equivalent to x≥aandx≥ −a. therefore, the constraint
can be equivalently written as
minimize
θ∈rd,u∈rnnx
n=1un, (7.13)
subject to un≥ −(yn−xt
nθ), n = 1, . . . , n
un≥(yn−xt
nθ), n = 1, . . . , n.
4147.1. principles of regression
in other words, we have rewritten the equality constraint as a pair of inequality constraints
by removing the absolute signs.
the optimization in equation (7.13) is in the form of a standard linear programming
problem. a linear programming problem takes the form of
minimize
x∈rkctx (7.14)
subject to ax≤b,
for some vectors c∈rk,b∈rm, and matrix a∈rm×k. linear programming is a stan-
dard optimization problem that you can find in most optimization textbooks. on a com-
puter, if we know c,banda, solving the linear programming problem can be done using
built-in commands. for matlab, the command is linprog . for python, the command is
scipy.optimize.linprog . we will discuss a concrete example shortly.
% matlab command for linear programming
x = linprog(c, a, b);
# python command for linear programming
linprog(c, a, b, bounds=(none,none), method="revised simplex")
given equation (7.13), the question becomes how to convert it into the standard linear
programming format. this requires two steps. the first step uses the objective function :
nx
n=1un=d−1x
p=0(0)(θp) +nx
n=1(1)(un)
=0 0 ··· 0 1 1 ··· 1
| {z }
=ct
θ
u
.
therefore, the vector chasd0’s followed by n1’s.
the second step concerns the constraint . it can be shown that un≥ −(yn−xt
nθ) is
equivalent to xt
nθ−un≤yn. written in the matrix form, we have

xt
1−1 0 ··· 0
xt
20−1··· 0
.........···...
xt
n0 0 ··· − 1

θ
u1
...
un
≤
y1
y2
...
yn
,
which is equivalent to

x−iθ
u
≤y, (7.15)
where i∈rn×nis the identity matrix.
similarly, the other constraint un≥(yn−xt
nθ) is equivalent to −xt
nθ−un≤ −yn.
written in the matrix form, we have

−xt
1−1 0 ··· 0
−xt
20−1··· 0
.........···...
−xt
n0 0 ··· − 1

θ
u1
...
un
≤
−y1
−y2
...
−yn
,
415chapter 7. regression
which is equivalent to
−x−iθ
u
≤ −y
putting everything together, we have finally arrived at the linear programming problem
minimize
θ∈rd,u∈rn0d1nθ
u
subject to
x−i
−x−i
θ
u
≤
y
−y
,
where 0d∈rdis an all-zero vector, and 1n∈rnis an all-one vector. it is this problem
that solves the robust linear regression.
let us look at how to implement linear programming to solve the robust regression
optimization. as an example, we continue with the polynomial fitting problem in which
there are outliers. we choose the ordinary polynomials as the basis functions. to construct
the linear programming problem, we need to define the matrix aand the vectors cand
baccording to the linear programming form. this is done using the following matlab
program.
% matlab code to demonstrate robust regression
n = 50;
x = linspace(-1,1,n)’;
a = [-0.001 0.01 0.55 1.5 1.2];
y = a(1)*legendrep(0,x) + a(2)*legendrep(1,x) + ...
a(3)*legendrep(2,x) + a(4)*legendrep(3,x) + ...
a(5)*legendrep(4,x) + 0.2*randn(n,1);
idx = [10, 16, 23, 37, 45];
y(idx) = 5;
x = [x(:).^0 x(:).^1 x(:).^2 x(:).^3 x(:).^4];
a = [x -eye(n); -x -eye(n)];
b = [y(:); -y(:)];
c = [zeros(1,5) ones(1,n)]’;
theta = linprog(c, a, b);
t = linspace(-1,1,200)’;
yhat = theta(1) + theta(2)*t(:) + ...
theta(3)*t(:).^2 + theta(4)*t(:).^3 + ...
theta(5)*t(:).^4;
plot(x,y, ’ko’,’linewidth’,2); hold on;
plot(t,yhat,’r’,’linewidth’,4);
in this set of commands, the basis vectors are defined as xt
n= [ϕ4(xn), . . . , ϕ 0(xn)]t, for
n= 1, . . . , n . the matrix iis constructed by using the command eye(n) , which constructs
the identity matrix of size n×n. the rest of the commands are self-explanatory. note that
the solution to the linear programming problem consists of both θandu. to squeeze θwe
need to locate the first dentries. the remainder is u.
commands for python are similar, although we need to call np.hstack andnp.vstack
to construct the matrices and vectors. the main routine is linprog in the scipy.optimize
4167.1. principles of regression
library. note that for this particular example, the bounds are bounds=(none,none) , or
otherwise python will search in the positive quadrant.
# python code to demonstrate robust regression
import numpy as np
import matplotlib.pyplot as plt
from scipy.special import eval_legendre
from scipy.optimize import linprog
n = 50
x = np.linspace(-1,1,n)
a = np.array([-0.001, 0.01, 0.55, 1.5, 1.2])
y = a[0]*eval_legendre(0,x) + a[1]*eval_legendre(1,x) + \
a[2]*eval_legendre(2,x) + a[3]*eval_legendre(3,x) + \
a[4]*eval_legendre(4,x) + 0.2*np.random.randn(n)
idx = [10,16,23,37,45]
y[idx] = 5
x = np.column_stack((np.ones(n), x, x**2, x**3, x**4))
a = np.vstack((np.hstack((x, -np.eye(n))), np.hstack((-x, -np.eye(n)))))
b = np.hstack((y,-y))
c = np.hstack((np.zeros(5), np.ones(n)))
res = linprog(c, a, b, bounds=(none,none), method="revised simplex")
theta = res.x
t = np.linspace(-1,1,200)
yhat = theta[0]*np.ones(200) + theta[1]*t + theta[2]*t**2 + \
theta[3]*t**3 + theta[4]*t**4
plt.plot(x,y,’o’,markersize=12)
plt.plot(t,yhat, linewidth=8)
plt.show()
the result of this experiment is shown in figure 7.12 . it is remarkable to see that the
robust regression result is almost as good as the result would be without outliers.
if robust linear regression performs so well, why don’t we use it all the time? why
is least squares regression still more popular? the answer has a lot to do with the com-
putational complexity and the uniqueness of the solution. linear programming requires an
algorithm for a solution. while we have very fast linear programming solvers today, the com-
putational cost of solving a linear program is still much higher than solving a least-squares
problem (which is essentially a matrix inversion).
the other issue with robust linear regression is the uniqueness of the solution. lin-
ear programming is known to have degenerate solutions when the constraint set (a high-
dimensional polygon) touches the objective function (which is a line) at one of its edges.
the least-squares fitting does not have this problem because the optimization surface is a
parabola. unless the matrix xtxis noninvertible, the solution is guaranteed to be the
unique global minimum. linear programming does not have this convenient property. we
can have multiple solutions θthat give the same objective value. if you try to interpret your
result by inspecting the magnitude of the θ’s, the nonuniqueness of the solution would cause
problems because your interpretation can be swiped immediately if the linear programming
gives you a nonunique solution.
417chapter 7. regression
-1 -0.5 0 0.5 1-2-1012345
-1 -0.5 0 0.5 1-2-1012345
(a) ordinary ( ·)2regression with outliers (b) robust | · |regression with outliers
figure 7.12: (a) ordinary linear regression using (·)2as the training loss. in the absence of any outlier,
the regression performs well. (b) robust linear regression using | · |as the training loss. note that even
in the presence of outliers, the robustness regression perform reasonably well.
end of this subsection. please join us again.
closing remark . the principle of linear regression is primarily to set up a function to fit
the data. this, in turn, is about finding a set of good basis functions and minimizing the
appropriate training loss. selecting the basis is usually done in several ways:
the problem forces you to choose certain basis functions. for example, suppose you
are working on a disease dataset. the variates are height, weight, and bmi. you do
not have any choice here because your goal is to see which factor contributes the most
to the cause of the disease.
there are known basis functions that work. for example, suppose you are working on
a speech dataset. physics tells us that fourier bases are excellent representations of
these sinusoidal functions. so it would make more sense to use the fourier basis than
the polynomials.
sometimes the basis can be learned from the data. for example, you can run principal-
component analysis (pca) to extract the basis. then you can run the linear regression
to compute the coefficients. this is a data-driven approach and could apply to some
problems.
7.2 overfitting
the regression principle we have discussed in the previous section is a powerful technique
for data analysis. however, there are many ways in which things can fall apart. we have
seen the problem of outliers, where perturbations of one or a few data points would result
in a big change in the regression result, and we discussed some techniques to overcome the
4187.2. overfitting
outlier problem, e.g., using robust regression. in addition to outliers, there are other causes
of the failure of the regression.
in this section, we examine the relationship between the number of training samples
and the complexity of the model. for example, if we decide to use polynomials as the basis
functions and we have only n= 20 data points, what should be the order of the polynomials?
shall we use the 5th-order polynomial, or shall we use the 20th-order? our goal in this section
is to acquire an understanding of the general problem known as overfitting . then we will
discuss methods for mitigating overfitting in section 7.4.
7.2.1 overview of overfitting
imagine that we have a dataset containing n= 20 training samples. we know that the data
are generated from a fourth-order polynomial with legendre polynomials as the basis. on
top of these samples, we also know that a small amount of noise corrupts each sample, for
example, gaussian noise of standard deviation σ= 0.1.
we have two options here for fitting the data:
option 1: h(x) =p4
p=0θplp(x), which is a 4th-order polynomial.
option 2: g(x) =p50
p=0θplp(x), which is a 50th-order polynomial.
model 2 is more expressive because it has more degrees of freedom. let us fit the data using
these two models. figure 7.13 shows the results. however, what is going on with the 50th-
order polynomial? it has gone completely wild. how can the regression ever choose such a
terrible model?
-1 -0.5 0 0.5 1-3-2-10123
data
fitted curve
-1 -0.5 0 0.5 1-3-2-10123
data
fitted curve
(a) 4th-order polynomial (b) 50th-order polynomial
figure 7.13: fitting data using a 4th-order polynomial and a 50th-order polynomial.
here is an even bigger surprise: if we compute the training loss, we get
etrain(h) =1
nnx
n=1
yn−h(xn)2
= 0.0063,
etrain(g) =1
nnx
n=1
yn−g(xn)2
= 5.7811×10−24.
419chapter 7. regression
thus, while model 2 looks wild in the figure, it has a much lower training loss than model 1.
so according to the training loss, model 2 fits better.
any sensible person at this point will object, since model 2 cannot possibly be better,
for the following reason. it is not because it “looks bad”, but because if you test the model
with an unseen sample it is almost certain that the testing error will explode. for example,
infigure 7.13 (a) if we look at x= 0, we would expect the predicted value to be close
toy= 0. however, figure 7.13 (b) suggests that the predicted value is going to negative
infinity. it would be hard to believe that the negative infinity is a better prediction than the
other one. we refer to this general phenomenon of fitting very well to the training data but
generalizing poorly to the testing data as overfitting .
what is overfitting?
overfitting means that a model fits too closely to the training samples so that it
fails to generalize.
overfitting occurs as a consequence of an imbalance between the following three factors:
number of training samples n. if you have many training samples, you should learn
very well, even if the model is complex. conversely, if the model is complex but does
not have enough training samples, you will overfit it. the most serious problem in
regression is often insufficient training data.
model order d. this refers to the complexity of the model. for example, if your model
uses a polynomial, drefers to the order of the polynomial. if your training set is too
small, you need to use a less complex model. the general rule of thumb is: “less is
more”.
noise variance σ2. this refers to the variance of the error enyou add to the data.
the model we assumed in the previous numerical experiment is that
yn=g(xn) +en, n = 1, . . . , n.
where en∼gaussian(0 , σ2). if σincreases, it is inevitable that the fitting will be-
come more difficult. hence it would require more training samples, and perhaps a less
complex model would work better.
7.2.2 analysis of the linear case
let us spell out the details of these factors one by one. to make our discussion concrete, we
will use linear regression as a case study. the general analysis will be presented in the next
section.
notations
ground truth model . to start with, we assume that we have a population set d
containing infinitely many samples ( x, y) drawn according to some latent distributions.
the relationship between xandyis defined through an unknown target function
y=f(x) +e,
4207.2. overfitting
where e∼gaussian(0 , σ2) is the noise. for our analysis, we assume that f(·) is linear,
so that
f(x) =xtθ∗,
where θ∗∈rdis the ground truth model parameter. notice that f(·) is deterministic,
buteis random. therefore, any randomness we see in yis due to e.
training and testing set . from d, we construct two datasets: the training data set
dtrainthat contains training samples {(x1, y1), . . . , (xn, yn)}and the testing dataset
dtestthat contains {(x1, y1), . . . , (xm, ym)}. both dtrainanddtestare subsets of d.
predictive model . we consider a predictive model gθ(·). for simplicity, we assume
thatgθ(·) is also linear:
gθ(x) =xtθ.
given the training dataset d={(x1, y1), . . . , (xn, yn)}, we construct a linear regres-
sion problem:
bθ= argmin
θ∈rd∥xθ−y∥2.
throughout our analysis, we assume that n≥dso that we have more training data
than the number of unknowns. we further assume that xtxis invertible, and so
there is a unique global minimizer
bθ= (xtx)−1xty.
training error . given the estimated model parameter bθ, we define the in-sample
prediction as
bytrain=xtrainbθ,
where xtrain=xis the training data matrix. the in-sample prediction is the pre-
dicted value using the trained model for the training data. the corresponding error
with respect to the ground truth is called the training error :
etrain(bθ) =ee1
n∥bytrain−y∥2
,
where nis the number of training samples in the training dataset. note that the
expectation is taken with respect to the noise vector e, which follows the distribution
gaussian(0 , σ2i).
testing error . during testing, we construct a testing matrix xtest. this gives us the
estimated values bytest:
bytest=xtestbθ.
the out-sample prediction is the predicted value using the trained model for the testing
data. the corresponding error with respect to the ground truth is called the testing
error:
etest(bθ) =ee1
m∥bytest−y∥2
,
where mis the number of testing samples in the testing dataset.
421chapter 7. regression
analysis of the training error
we first analyze the training error, which we defined as
etrain=ee1
n∥by−y∥2
def= mse( by,y). (7.16)
for this particular choice of the training error, we call it the mean squared error (mse). it
measures the difference between byandy.
theorem 7.3. letθ∗∈rdbe the ground truth linear model parameter, and x∈
rn×dbe a matrix such that n≥dandxtxis invertible. assume that the data
follows the linear model y=xθ∗+ewhere e∼gaussian (0, σ2i). consider the linear
regression problem bθ=argmin
θ∈rd∥xθ−y∥2, and the predicted value by=xbθ. the
mean squared training error of this linear model is
etraindef=mse(by,y) =ee1
n∥by−y∥2
=σ2
1−d
n
. (7.17)
the proof below depends on some results from linear algebra that may be difficult for
first-time readers. we recommend you read the proof later.
proof . recall that the least squares linear regression solution is bθ= (xtx)−1xty. since
y=xθ∗+e, we can substitute this into the predicted value byto show that
by=xbθ=x(xtx)−1xt
| {z }
=hy=x(xtx)−1xt(xθ∗+e) =xθ∗+he.
therefore, substituting by=xθ∗+heinto the mse,
mse(by,y)def=ee1
n∥by−y∥2
=ee1
n∥xθ∗+he−xθ∗−e∥2
=ee1
n∥(h−i)e∥2
.
at this point we need to use a tool from linear algebra. one useful identity3is that for any
v∈rn,
∥v∥2= tr(vvt).
3the reason for this identity is that
v=nx
n=1v2
n= tr


v2
1v1v2··· v1vn
v2v1 v2
2··· v2vn
............
vnv1vnv2··· v2
n


= trn
vvto
.
4227.2. overfitting
using this identity, we have that
ee1
n∥(h−i)e∥2
=1
nee
tr
(h−i)eet(h−i)t
=1
ntr
(h−i)ee
eet
(h−i)t
=σ2
ntr
(h−i)(h−i)t
,
where we used the fact that e[eet] =σ2i. the special structure of htells us that ht=h
andhth=h. thus, we have ( h−i)t(h−i) =i−h. in addition, using the cyclic
property of trace tr( ab) = tr( ba), we have that
tr(h) = tr( x(xtx)−1xt)
= tr(( xtx)−1xtx) = tr( i) =d.
consequently,
σ2
ntr
(h−i)(h−i)t
=σ2
ntr
i−h
=σ2
1−d
n
.
this completes the proof.
□
the end of the proof. please join us again.
practice exercise 1 . in the theorem above, we proved the mse of the prediction y.
in this example, we would like to prove the mse for the parameter . prove that
mse(bθ,θ∗)def=eebθ−θ∗2
=σ2tr
(xtx)−1
.
solution . let us start with the definition:
mse(bθ,θ∗) =ee(xtx)−1xty−θ∗2
=ee(xtx)−1xt(xθ∗+e)−θ∗2
=eeθ∗+ (xtx)−1xte−θ∗2
=ee(xtx)−1xte2
.
423chapter 7. regression
continuing the calculation,
ee(xtx)−1xte2
=ee
tr
(xtx)−1xte etx(xtx)−1
= tr
(xtx)−1xtee
eet
x(xtx)−1
= tr
(xtx)−1xt·σ2i·x(xtx)−1
=σ2tr
(xtx)−1xt·x(xtx)−1
=σ2tr
(xtx)−1
.
analysis of the testing error
similarly to the training error, we can analyze the testing error. the testing error is defined
as
etest= mse( by,y′)def=ee,e′1
m∥by−y′∥2
, (7.18)
whereby= [by1, . . . ,bym]tis a vector of mpredicted values and y′= [y′
1, . . . , y′
m]tis a vector
ofmtrue values in the testing data.4
we would like to derive something concrete. to make our analysis simple, we consider
a special case in which the testing set contains ( x1, y′
1), . . . , (xn, y′
n). that is, the inputs
x1, . . . , x nare identical for both training and testing (for example, suppose that you measure
the temperature on two different days but at the same time stamps.) in this case, we have
m=n, and we have xtest=xtrain=x. however, the noise added to the testing data is
still different from the noise added to the training data.
with these simplifications, we can derive the testing error as follows.
theorem 7.4. letθ∗∈rdbe the ground truth linear model parameter, and x∈
rn×dbe a matrix such that n≥dandxtxis invertible. assume that the training
data follows the linear model y=xθ∗+e, where e∼gaussian (0, σ2i). consider
the linear regression problem bθ= (xtx)−1xty, and let by=xbθ. letxtest=x
be the testing input data matrix, and define y′=xtestθ∗+e′∈rn, with e′∼
gaussian (0, σ2i), be the testing output. then, the mean squared testing error of this
linear model is
etestdef=mse(by,y′) =ee,e′1
n∥by−y′∥2
=σ2
1 +d
n
. (7.19)
in this definition, the expectation is taken with respect to a joint distribution of ( e,e′).
this is because, in testing, the trained model is based on yof which the randomness is e.
however, the testing data is based on y′, where the randomness comes from e′. we assume
thateande′are independent i.i.d. gaussian vectors.
4in practice, the number of testing samples mcan be much larger than the number of training samples n.
this probably does not agree with your experience, in which the testing dataset is often much smaller than
the training dataset. the reason for this paradox is that the practical testing data set is only a finite subset
of all the possible testing samples available. so the “testing error” we compute in practice approximates the
true testing error. if you want to compute the true testing error, you need a very large testing dataset.
4247.2. overfitting
as with the previous proof, we recommend you study this proof later.
proof . the mse can be derived from the definition:
mse(by,y′) =ee,e′1
n∥by−y′∥2
=1
nee,e′
∥xθ∗+he−xθ∗−e′∥2
=1
nee,e′
∥he−e′∥2
.
since each noise term enande′
nis an i.i.d. copy of the same gaussian random variable, by
using the fact that
tr(h) = tr( x(xtx)−1xt)
= tr(( xtx)−1xtx) = tr( i) =d,
we have that
ee,e′h
∥he−e′∥2i
=ee
∥he∥2
−ee,e′h
2ethte′i
| {z }
=0+ee′
∥e′∥2
=eeh
trn
heethtoi
+ee′
tr
e′e′t	
= trn
hee
eet
hto
+ tr{ee′
e′e′t
}
= trn
h·σ2in×n·hto
+ tr
σ2in×n	
=σ2trn
hhto
+ tr
σ2in×n	
=σ2tr(id×d) +σ2tr{in×n}=σ2(d+n).
combining all the terms,
mse(by,y′) =ee,e′1
n∥by−y′∥2
=σ2
1 +d
n
,
which completes the proof.
□
the end of the proof.
7.2.3 interpreting the linear analysis results
let us summarize the two main theorems. they state that, for n≥d,
etraindef= mse( by,y) =ee1
n∥by−y∥2
=σ2
1−d
n
, (7.20)
etestdef= mse( by,y′) =ee,e′1
n∥by−y′∥2
=σ2
1 +d
n
. (7.21)
this pair of equations tells us everything about the overfitting issue.
425chapter 7. regression
how do etrainandetestchange w.r.t. σ2?
etrain↑asσ2↑. thus noisier data are harder to fit.
etest↑asσ2↑. thus a noiser model is more difficult to generalize.
the reasons for these results should be clear from the following equations:
etrain=σ2
1−d
n
,
etest=σ2
1 +d
n
.
asσ2increases, the training error etraingrows linearly w.r.t. σ2. since the training error
measures how good your model is compared with the training data, a larger etrainmeans it
is more difficult to fit. for the testing case, etestalso grows linearly w.r.t. σ2. this implies
that the model would be more difficult to generalize if the model were trained using noisier
data.
how do etrainandetestchange w.r.t. n?
etrain↑asn↑. thus more training samples make fitting harder.
etest↓asn↑. thus more training samples improve generalization.
the reason for this should also be clear from the following equations:
etrain=σ2
1−d
n
,
etest=σ2
1 +d
n
.
asnincreases, the model sees more training samples. the goal of the model is to minimize
the error with all the training samples. thus the more training samples we have, the harder
it will be to make everyone happy, so the training error grows as ngrows. for testing, if the
model is trained with more samples it is more resilient to noise. hence the generalization
improves.
how do etrainandetestchange w.r.t. d?
etrain↓asd↑. thus a more complex model makes fitting easier.
etest↑asd↑. thus a more complex model makes generalization harder.
these results are perhaps less obvious than the others. the following equations tell us that
etrain=σ2
1−d
n
,
etest=σ2
1+d
n
. (7.22)
4267.2. overfitting
for this linear regression model to work, dhas to be less than n; otherwise, the matrix
inversion ( xtx)−1is invalid. however, as dgrows while nremains fixed, we ask the
linear regression to fit a larger and larger model while not providing any additional training
samples. equation (7.22) says that etrainwill drop as dincreases but etestwill increase as d
increases. therefore, a larger model will not generalize as well if nis fixed.
ifd > n , then the optimization
bθ= argmin
θ∈rd∥xθ−y∥2
will have many global minimizers (see figure 7.10 ), implying that the training error can go
to zero. our analysis of etrainandetestdoes not cover this case because our proofs require
(xtx)−1to exist. however, we can still extrapolate what will happen. when the training
error is zero, it only means that we fit perfectly into the training data. since the testing
error grows as dgrows (though not in the particular form shown in equation (7.22)), we
should expect the testing error to become worse.
learning curve
the results we derived above can be summarized in the learning curve shown in figure 7.14 .
in this figure we consider a simple problem where
yn=θ0+θ1xn+en,
foren∼gaussian(0 ,1). therefore, according to our theoretical derivations, we have σ= 1
andd= 2. for every n, we compute the average training error etrainand the average testing
erroretest, and then mark them on the figure. these are our empirical training and testing
errors. on the same figure, we calculate the theoretical training and testing error according
to equation (7.22).
the matlab and python codes used to generate this learning curve are shown below.
nset = round(logspace(1,3,20));
e_train = zeros(1,length(nset));
e_test = zeros(1,length(nset));
a = [1.3, 2.5];
for j = 1:length(nset)
n = nset(j);
x = linspace(-1,1,n)’;
e_train_temp = zeros(1,1000);
e_test_temp = zeros(1,1000);
x = [ones(n,1), x(:)];
for i = 1:1000
y = a(1) + a(2)*x + randn(size(x));
y1 = a(1) + a(2)*x + randn(size(x));
theta = x\y(:);
yhat = theta(1) + theta(2)*x;
e_train_temp(i) = mean((yhat(:)-y(:)).^2);
e_test_temp(i) = mean((yhat(:)-y1(:)).^2);
end
e_train(j) = mean(e_train_temp);
427chapter 7. regression
e_test(j) = mean(e_test_temp);
end
semilogx(nset, e_train, ’kx’, ’linewidth’, 2, ’markersize’, 16); hold on;
semilogx(nset, e_test, ’ro’, ’linewidth’, 2, ’markersize’, 8);
semilogx(nset, 1-2./nset, ’k’, ’linewidth’, 4);
semilogx(nset, 1+2./nset, ’r’, ’linewidth’, 4);
import numpy as np
import matplotlib.pyplot as plt
nset = np.logspace(1,3,20)
nset = nset.astype(int)
e_train = np.zeros(len(nset))
e_test = np.zeros(len(nset))
for j in range(len(nset)):
n = nset[j]
x = np.linspace(-1,1,n)
a = np.array([1, 2])
e_train_tmp = np.zeros(1000)
e_test_tmp = np.zeros(1000)
for i in range(1000):
y = a[0] + a[1]*x + np.random.randn(n)
x = np.column_stack((np.ones(n), x))
theta = np.linalg.lstsq(x, y, rcond=none)[0]
yhat = theta[0] + theta[1]*x
e_train_tmp[i] = np.mean((yhat-y)**2)
y1 = a[0] + a[1]*x + np.random.randn(n)
e_test_tmp[i] = np.mean((yhat-y1)**2)
e_train[j] = np.mean(e_train_tmp)
e_test[j] = np.mean(e_test_tmp)
plt.semilogx(nset, e_train, ’kx’)
plt.semilogx(nset, e_test, ’ro’)
plt.semilogx(nset, (1-2/nset), linewidth=4, c=’k’)
plt.semilogx(nset, (1+2/nset), linewidth=4, c=’r’)
the training error curve and the testing error curve behave in opposite ways as n
increases. the training error etrain increases as nincreases, because when we have more
training samples it becomes harder for the model to fit all the data. by contrast, the testing
erroretestdecreases as nincreases, because when we have more training samples the model
becomes more robust to noise and unseen data. therefore, the testing error improves.
asngoes to infinity, both the training error and the testing error converge. this is
due to the law of large numbers, which says that the empirical training and testing errors
should converge to their respective expected values. if the training error and the testing error
converge to the same value, the training can generalize to testing. if they do not converge to
the same value, there is a mismatch between the training samples and the testing samples.
it is important to pay attention to the gap between the converged values. we often
assume that the training samples and the testing samples are drawn from the same distri-
bution, and therefore the training samples are good representatives of the testing samples.
4287.3. bias and variance trade-off
101102103
number of training samples, n0.80.850.90.9511.051.11.151.2errortraining error
testing error
figure 7.14: the learning curve is a pair of functions representing the training error and the testing
error. as nincreases we expect the training error to increase and the testing error to decrease. the two
functions will converge to the same value as ngoes to infinity. if they do not converge to the same
value, there is an intrinsic mismatch between the training samples and the testing samples, e.g., the
training samples are not representative enough for the dataset.
if the assumption is not true, there will be a gap between the converged training error and
the testing error. thus, what you claim in training cannot be transferred to the testing.
consequently, the learning curve provides you with a useful debugging tool to check how
well your training compares with your testing.
closing remark . in this section we have studied a very important concept in regression,
overfitting. we emphasize that overfitting is not only caused by the complexity of the model
but a combination of the three factors σ2,n, and d. we close this section by summarizing
the causes of overfitting:
what is the source of overfitting?
overfitting occurs because you have an imbalance between σ2,nandd.
selecting the correct complexity for your model is the key to avoid overfitting.
7.3 bias and variance trade-off
our linear analysis has provided you with a rough understanding of what we experience in
overfitting. however, for general regression problems where the models are not necessarily
linear, we need to go deeper. the goal of this section is to explain the trade-off between
bias and variance. this analysis requires some patience as it involves many equations. we
recommend skipping this section on a first reading and then returning to it later.
429chapter 7. regression
if it is your first time reading it, we recommend you go through it slowly.
7.3.1 decomposing the testing error
notations
as we did at the beginning of section 7.2, we consider a ground truth model that relates
an input xand an output y:
y=f(x) +e,
where e∼gaussian(0 , σ2) is the noise. for example, if we use a linear model, then fcould
bef(x) =θtx, for some regression coefficients θ.
during training , we pick a prediction model gθ(·) and try to predict the output when
given a training sample x:
by=gθ(x).
for example, we may choose gθ(x) =θtx, which is also a linear model. we may also choose
a linear model in another basis, e.g., gθ(x) =θtϕ(x) for some transformations ϕ(·). in any
case, the goal of training is to minimize the training error:
bθ= argmin
θ1
nnx
n=1(gθ(xn)−yn)2,
where the sum is taken over the training samples dtrain={(x1, y1), . . . , (xn, yn)}. because
the model parameter bθis learned from the training dataset dtrain, the prediction model
depends on dtrain. to emphasize this dependency, we write
g(dtrain)= the model trained from
(x1, y1), . . . , (xn, yn)
.
during testing , we consider a testing dataset dtest={(x′
1, y′
1), . . . , (x′
m, y′
m)}. we put
these testing samples into the trained model to predict an output:
by′
m=g(dtrain)(x′
m), m = 1, . . . , m. (predicted value)
since the goal of regression is to make g(dtrain)as close to fas possible, it is natural to
expect by′
mto be close to y′
m.
testing error decomposition (noise-free)
so we can now compute the testing error — the error that we ultimately care about. in the
noise-free condition, i.e., e= 0, the testing error is defined as
e(dtrain)
test =ex′h 
g(dtrain)(x′)−f(x′)2i
(7.23)
≈1
mmx
m=1
g(dtraing )(x′
m)−f(x′
m)2
.
there are several components in this equation. first, x′is a testing sample drawn from a
certain distribution. you can think of dtestas a finite subset drawn from this distribution.
4307.3. bias and variance trade-off
second, the error 
g(dtrain)(x′)−f(x′)2measures the deviation between our predicted value
and the true value. note that this error term is specific to one testing sample x′. therefore,
we take expectation ex′to find the average of the error for the distribution of x′.
the testing error e(dtrain)
test is a function that is dependent on the training set dtrain,
because the model g(dtrain)is trained from dtrain. therefore, as we change the training
set, we will have a different model gand hence a different testing error. to eliminate the
randomness of the training set, we define the overall testing error as
etest=edtrain
e(dtrain)
test
=edtrain
ex′h 
g(dtrain)(x′)−f(x′)2i
. (7.24)
note that this definition of the testing error is consistent with the special case in equa-
tion (7.18), in which the testing error involves a joint expectation over eande′. the ex-
pectation over eaccounts for the training samples, and the expectation over e′accounts for
the testing samples.
let us try to extract some meaning from the testing error. our method will be to
decompose the testing error into biasandvariance .
theorem 7.5. assume a noise-free condition. the testing error of a regression prob-
lem is given by
etest=ex′
(g(x′)−f(x′))2
| {z }
=bias(x′)+edtrain[(g(dtrain)(x′)−g(x′))2]| {z }
=var(x′)
, (7.25)
where g(x′)def=edtrain[g(dtrain)(x′)].
proof . to simplify our notation, we will drop the subscript “train” in dtrain when the
context is clear. we have that
etest=edh
ex′h
(g(d)(x′)−f(x′))2ii
=ex′h
edh
(g(d)(x′)−f(x′))2ii
.
continuing the calculation,
etest=ex′h
edh
(g(d)(x′)−g(x′) +g(x′)−f(x′))2ii
=ex′
edh
(g(d)(x′)−g(x′))2i
+ 2edh
(g(d)(x′)−g(x′))(g(x′)−f(x′))i
+edh
(g(x′)−f(x′))2i
.
since g(x′)def=ed[g(d)(x′)], it follows that
2edh
(g(d)(x′)−g(x′))(g(x′)−f(x′))i
= 0
431chapter 7. regression
because g(x′)−f(x′) is independent of d, and
edh
(g(x′)−f(x′))2i
= (g(x′)−f(x′))2.
therefore,
etest=ex′
edh
(g(d)(x′)−g(x′))2i
+h
(g(x′)−f(x′))2i
.
thus, by defining two following terms we have proved the theorem.
bias(x′)def= (g(x′)−f(x′))2,
var(x′)def=ed[(g(d)(x′)−g(x′))2].
□
let’s consider what this theorem implies. this result is a decomposition of the testing
error into bias andvariance . it is a universal result that applies to allregression models,
not only linear cases. to summarize the meanings of bias and variance:
what are bias and variance?
bias = how far your average is from the truth.
variance = how much fluctuation you have around the average.
figure 7.15 gives a pictorial representation of bias and variance. in this figure, we
construct four scenarios of bias and variance. each cross represents the predictor g(dtrain),
with the true predictor fat the origin. figure 7.15 (a) shows the case with a low bias and
a low variance. all these predictors g(dtrain)are very close to the ground truth, and they
have small fluctuations around their average. figure 7.15 (b) shows the case of a high bias
and a low variance. it has a high bias because the entire group of g(dtrain)is shifted to the
corner. the bias, which is the distance from the truth to the average, is therefore large. the
variance remains small because the fluctuation around the average is small. figure 7.15 (c)
shows the case of a low bias but high variance. in this case, the fluctuation around the
average is large. figure 7.15 shows the case of high bias and high variance. we want to
avoid this case.
bias low bias high bias low bias high
var low var low var high var high
(a) (b) (c) (d)
figure 7.15: imagine that you are throwing a dart with a target at the center. the four subfigures show
the levels of bias and variance.
4327.3. bias and variance trade-off
testing error decomposition (noisy case)
let us consider a situation when there is noise. in the presence of noise, the training and
testing samples will follow the relationship
y=f(x) +e,
where e∼gaussian(0 , σ2). we assume that the noise is gaussian to make the proof easier.
we can consider other types of noise in theory, but the theoretical results will need to be
modified.
in the presence of noise, the testing error is
etest(x′)def=edtrain,e
g(dtrain)(x′)−f(x′) +e2
=edtrain,e
g(dtrain)(x′)−g(x′) +g(x′)−f(x′) +e2
,
where we take the joint expectation over the training dataset dtrainand the error e. con-
tinuing the calculation, and using the fact that dtrainandeare independent (and e[e] = 0),
it follows that
etest(x′) =edtrain,e
g(dtrain)(x′)−g(x′) +g(x′)−f(x′) +e2
=edtrain,e
g(d)(x′)−g(x′)2
+
g(x′)−f(x′)2
+e2
=edtrain
g(dtrain)(x′)−g(x′)2
| {z }
=var(x′)+
g(x′)−f(x′)2
| {z }
=bias( x′)+eeh
e2i
|{z}
=noise.
taking the expectation of x′over the entire testing distribution gives us
etest=ex′[etest(x′)] =ex′[var(x′)]|{z}
var+ex′[bias(x′)]|{z}
bias+σ2.
the theorem below summarizes the results:
theorem 7.6. assume a noisy condition where y=f(x)+efor some i.i.d. gaussian
noise e∼gaussian (0, σ2). the testing error of a regression problem is given by
etest=ex′
(g(x′)−f(x′))2
| {z }
=bias(x′)
+ex′
edtrain[(g(dtrain)(x′)−g(x′))2]| {z }
=var(x′)
+σ2,(7.26)
where g(x′)def=edtrain[g(dtrain)(x′)].
7.3.2 analysis of the bias
let us examine the bias and variance in more detail. to discuss bias we must first understand
the quantity
g(x′)def=edtrain[g(dtrain)(x′)], (7.27)
433chapter 7. regression
which is known as the average predictor . the average predictor, as the equation suggests, is
the expectation of the predictor g(dtrain). remember that g(dtrain)is a predictor constructed
from a specific training set dtrain. if tomorrow our training set dtraincontains other data
(that come from the same underlying distribution), g(dtrain)will be different. the average
predictor gis the average across these random fluctuations of the dataset dtrain. here is an
example:
suppose we use a linear model with the ordinary polynomials as the bases. the data
points are generated according to
yn=d−1x
p=0θpxp
n
|{z}
def=f(xn)=θtxn+en. (7.28)
if we use a particular training set dtrainand run the regression, we will be able to obtain
one of the regression lines, as shown in figure 7.16 . let us call this line g(1). we repeat the
experiment by drawing another dataset, and call it g(2). we continue and eventually we will
find a set of regression lines g(1), g(2), . . . , g(k), where kdenotes the number of training sets
you are using to generate all the gray curves. the average predictor gis defined as
g(x′) =edtrain[g(dtrain)]≈1
kkx
k=1g(k)(x′).
thus if we take the average of all these gray curves we will obtain the average predictor,
which is the red curve shown in figure 7.16 .
-1 -0.5 0 0.5 1-10123
figure 7.16: we run linear regression many times for different training datasets. each one consists of
different random realizations of noise. the gray curves are the regression lines returned by each of the
training datasets. we then take the average of these gray curves to obtain the red curve, which is the
average predictor.
if you are curious about how this plot was generated, the matlab and python codes
are given below.
% matlab code to visualize the average predictor
n = 20;
4347.3. bias and variance trade-off
a = [5.7, 3.7, -3.6, -2.3, 0.05];
x = linspace(-1,1,n);
yhat = zeros(100,50);
for i=1:100
x = [x(:).^0, x(:).^1, x(:).^2, x(:).^3, x(:).^4];
y = x*a(:) + 0.5*randn(n,1);
theta = x\y(:);
t = linspace(-1, 1, 50);
yhat(i,:) = theta(1) + theta(2)*t(:) + theta(3)*t(:).^2 ...
+ theta(4)*t(:)^3 + theta(5)*t(:).^4;
end
figure;
plot(t, yhat, ’color’, [0.6 0.6 0.6]); hold on;
plot(t, mean(yhat), ’linewidth’, 4, ’color’, [0.8 0 0]);
axis([-1 1 -2 2]);
import numpy as np
import matplotlib.pyplot as plt
from scipy.special import eval_legendre
np.set_printoptions(precision=2, suppress=true)
n = 20
x = np.linspace(-1,1,n)
a = np.array([0.5, -2, -3, 4, 6])
yhat = np.zeros((50,100))
for i in range(100):
y = a[0] + a[1]*x + a[2]*x**2 + \
a[3]*x**3 + a[4]*x**4 + 0.5*np.random.randn(n)
x = np.column_stack((np.ones(n), x, x**2, x**3, x**4))
theta = np.linalg.lstsq(x, y, rcond=none)[0]
t = np.linspace(-1,1,50)
xhat = np.column_stack((np.ones(50), t, t**2, t**3, t**4))
yhat[:,i] = np.dot(xhat, theta)
plt.plot(t, yhat[:,i], c=’gray’)
plt.plot(t, np.mean(yhat, axis=1), c=’r’, linewidth=4)
we now show an analytic calculation to verify figure 7.16 .
example 7.4 . consider a linear model such that
y=xtθ+e. (7.29)
what is the predictor g(dtrain)(x′)? what is the average predictor g(x′)?
solution . first, consider a training dataset dtrain ={(x1, y1), . . . , (xn, yn)}. we
assume that the xn’s are deterministic and fixed. therefore, the source of randomness
in the training set is caused by the noise e∼gaussian(0 , σ2) and hence by the noisy
435chapter 7. regression
observation y.
the training set gives us the equation y=xθ+e, where xis the matrix
constructed from xn’s. the regression solution to this dataset is
bθ= (xtx)−1xty,
which should actually be bθ(dtrain)because yis a dataset-dependent vector.
consequently,
g(dtrain)(x′) =bθtx′= (x′)t(xtx)−1xty
= (x′)t(xtx)−1xt(xθ+e)
= (x′)tθ+ (x′)t(xtx)−1xte.
since the randomness of dtrainis caused by the noise, it follows that
g(x′) =edtrain[g(dtrain)(x′)] =ee[(x′)tθ+ (x′)t(xtx)−1xte]
= (x′)tθ+ (x′)t(xtx)−1xtee[e]
= (x′)tθ+ 0 = f(x′).
so the average predictor will return the ground truth. however, note that not all
predictors will return the ground truth.
in the above example, we obtained an interesting result, namely that g(x′) =f(x′).
that is, the average predictor equals the true predictor. however, in general, g(x′) does
not necessarily equal f(x′). if this occurs, we have a deviation ( g(x′)−f(x′))2>0. this
deviation is called the bias. bias is independent of the number of training samples because
we have taken the average of the predictors. therefore, bias is more of an intrinsic (or
systematic) error due to the choice of the model.
what is bias?
bias is defined as bias = ex′[(g(x′)−f(x′))2], where x′is a testing sample.
it is the deviation from the average predictor to the true predictor.
bias is not necessarily a bad thing. a good predictor can have some bias as long
as it helps to reduce the variance.
7.3.3 variance
the other quantity in the game is the variance . variance at a testing sample x′is defined
as
var(x′)def=edtrain[(g(dtrain)(x′)−g(x′))2]. (7.30)
as the equation suggests, the variance measures the fluctuation between the predictor
g(dtrain)and the average predictor g.figure 7.17 illustrates the polynomial-fitting prob-
lem we discussed above. in this figure we consider two levels of variance by varying the
4367.3. bias and variance trade-off
noise strength of en. the figure shows that as the observation becomes noisier, the predictor
g(dtrain)will have a larger fluctuation for the average predictor.
-1 -0.5 0 0.5 1-2-1012
-1 -0.5 0 0.5 1-2-1012
(a) small variance (b) large variance
figure 7.17: variance measures the magnitude of fluctuation between the particular predictor g(dtrain)
and the average predictor g.
example 7.5 . continuing with example 7.4, we ask: what is the variance?
solution . we first determine the predictor and its average:
g(dtrain)= (xtx)−1xty=θ+ (xtx)−1xte
g=e[g(dtrain)] =ee[θ+ (xtx)−1xte] =θ,
so the prediction at a testing sample x′is
g(dtrain)(x′) = (x′)tθ+ (x′)t(xtx)−1xte
g(x′) = (x′)tθ,
consequently, the variance is
edtrain
g(dtrain)(x′)−g(x′)2
=ee
(x′)tθ+ (x′)t(xtx)−1xte−(x′)tθ2
=ee
(x′)t(xtx)−1xte2
.
continuing the calculation,
edtrain
g(dtrain)(x′)−g(x′)2
= (x′)t(xtx)−1xtee[eet]x(xtx)−1x′
= (x′)t(xtx)−1xtσ2ix(xtx)−1x′
=σ2(x′)t(xtx)−1x′
=σ2trn
(xtx)−1(x′)(x′)to
.
437chapter 7. regression
what will happen if we use more samples so that ngrows? as ngrows, the matrix xwill
have more rows. assuming that the magnitude of the entries remains unchanged, more rows
inxwill increase the magnitude of xtxbecause we are summing more terms. consider
a 2×2 ordinary polynomial system where
xtx=
pn
n=1x2
npn
n=1xn
pn
n=1xn n
.
asngrows, all the entries in the matrix grow. as a result, ( xtx)−1will shrink in mag-
nitude and thus drive the variance σ2trn
(xtx)−1(x′)(x′)to
to zero.
what is variance?
variance is the deviation between the predictor g(dtrain)and its average g.
it can be reduced by using more training samples.
7.3.4 bias and variance on the learning curve
the decomposition of the testing error into bias and variance is portrayed visually by the
learning curve shown in figure 7.18 . this figure shows the testing error and the training
error as functions of the number of training samples. as nincreases, we observe that both
testing and training errors converge to the same value. at any fixed n, the testing error is
composed of bias and variance:
the bias is the distance from the ground to the steady-state level. this value is fixed
and is a constant w.r.t. n. in other words, regardless of how many training samples
you have, the bias is always there. it is the best outcome you can achieve.
the variance is the fluctuation from the steady-state level to the instantaneous state.
it drops as nincreases.
figure 7.18: the learning curve can be decomposed into the sum of the bias and the variance. the bias
is the testing error when n=∞. for finite n, the difference between the testing error and the bias is
the variance.
4387.3. bias and variance trade-off
figure 7.19 compares the learning curve of two models. the first case requires us to
fit the data using a simple model (marked in purple). the training error and the testing
error have small fluctuations around the steady-state because, for simple models, you need
only a small number of samples to make the model happy. the second case requires us to
fit the data using a complex model (marked in green). this set of curves has a much wider
fluctuation because it is harder to train and harder to generalize. however, when we have
enough training samples, the training error and the testing error will converge to a lower
steady-state value. therefore, you need to pay the price of using a complex model, but if
you do, you will enjoy a lower testing error.
101102103
number of training samples, n00.511.522.5errorsimple model - training error
simple model - testing error
complex model - training error
complex model - testing error
figure 7.19: the generalization capability of a model is summarized by the training and testing errors
of the model. if we use a simple model we will have an easier time with the training but the steady-state
testing error will be high. in contrast, if we use a complex model we need to have a sufficient number
of training samples to train the model well. however, when the complex model is well trained, the
steady-state error will be lower.
the implication of all this is that you should choose the model by considering the
number of data points. never buy an expensive toy when you do not have the money! if
you insist on using a complex model while you do not have enough training data, you will
suffer from a poor testing error even if you feel good about it.
closing remark . we close this section by revisiting the bias-variance trade-off:
etest=ex′
(g(x′)−f(x′))2
| {z }
=bias( x′)
+ex′
edtrain[(g(dtrain)(x′)−g(x′))2]| {z }
=var(x′)
+σ2. (7.31)
the relationship among the three terms is summarized below:
what is the trade-off offered by the bias-variance analysis?
overfitting improves if n↑: variance drops as ngrows. bias is unchanged.
overfitting worsens if σ2↑. if training noise grows, g(dtrain)will have more fluc-
tuations, so variance will grow. if testing noise grows, e2grows.
439chapter 7. regression
overfitting worsens if the target function fis too complicated to be approximated
byg.
end of the section. please join us again.
7.4 regularization
having discussed the source of the overfitting problem, we now discuss methods to allevi-
ate overfitting. the method we focus on here is regularization . regularization means that
instead of seeking the model parameters by minimizing the training loss alone, we add a
penalty term to force the parameters to“behave better”. as a preview of the technique, we
change the original training loss
etrain(θ) =nx
n=1
yn−d−1x
p=0θpϕp(xn)2
| {z }
data fidelity, (7.32)
which consists of only the data fidelity term, to a modified training loss
etrain(θ) =nx
n=1
yn−d−1x
p=0θpϕp(xn)2
| {z }
f(θ),data fidelity+ λ·d−1x
p=0θ2
p
|{z}
λ·r(θ),regularization. (7.33)
putting this into the matrix form, we define the data fidelity term as
f(θ) =∥xθ−y∥2. (7.34)
the newly added term r(θ) is called the regularization function or the penalty function .
it can take a variety of forms, e.g.,
ridge regression: r(θ) =pd−1
p=0θ2
p=∥θ∥2.
lasso regression: r(θ) =pd−1
p=0|θp|=∥θ∥1.
in this section we aim to understand the role of the regularization functions by studying
these two examples of r(θ).
7.4.1 ridge regularization
to explain the meaning of equation (7.33) we write it in terms of matrices and vectors:
minimize
θ∈rd∥xθ−y∥2+λ∥θ∥2, (7.35)
where λis called the regularization parameter .it needs to be tuned by the user. we refer
to equation (7.35) as the ridge regression .5
5in signal processing and optimization, equation (7.35) is called the tikhonov regularization. we follow
the statistics community in calling it the ridge regression.
4407.4. regularization
how can the regularization function help to mitigate the overfitting problem? first
let’s find the solution to this problem.
practice exercise 1 . prove that the solution to equation (7.35) is
bθ= (xtx+λi)−1xty. (7.36)
solution . take the derivative with respect to θ.athis yields
∇θ
∥xθ−y∥2+λ∥θ∥2
= 2xt(xθ−y) + 2λθ= 0.
rearranging the terms gives
(xtx+λi)θ=xty.
taking the inverse of the matrix on both sides yields the solution.
athe solution here requires some basic matrix calculus. you may refer to the university of water-
loo’s matrix cookbook https://www.math.uwaterloo.ca/ ~hwolkowi/matrixcookbook.pdf .
let us compare the ridge regression solution with the vanilla regression solutions:
bθvanilla = (xtx)−1xty,
bθridge(λ) = (xtx+λi)−1xty.
clearly, the only difference is the presence of the parameter λ:
ifλ→0, then bθridge(0) =bθvanilla . this is because
etrain(θ) =∥xθ−y∥2+λ∥θ∥2
|{z}
=0.
hence, when λ→0, the regression problem goes back to the vanilla version, and so
does the solution.
λ→ ∞ , then bθridge(∞) = 0. this happens because
etrain(θ) =1
λ∥xθ−y∥2
|{z}
=0+∥θ∥2.
since we are now minimizing ∥θ∥2, the solution will be θ= 0 because zero is the
smallest value a squared function can achieve.
for any 0 < λ < ∞, the net effect of ( xtx+λi) is the constant λadded to all the
eigenvalues of xtx. by taking the eigendecomposition of xtx,
[u,s] =eig(xtx),
we have that
xtx+λi=usut+λi
=usut+λuut=u(s+λi)ut.
441chapter 7. regression
therefore, if the eigenvalue matrix shas a zero eigenvalue it will be offset by λ:
s=
♣
♡
♠
0
−→ s+λi=
♣+λ
♡+λ
♠+λ
λ

as a result, even if xtxis not invertible (or close to not invertible), the new matrix
xtx+λiis guaranteed to be invertible.
practice exercise 2. you may be wondering what happens if xtxhas a negative
eigenvalue so that when we add a positive λ, the resulting matrix may have a zero
eigenvalue. prove that xtxwill never have a negative eigenvalue, and xtx+λi
always has positive eigenvalues.
solution . eigenvalues of a matrix aare nonnegative if and only if vtav≥0 for
anyv. thus we need to check whether vtxtxv≥0 for all v. however, this is easy:
vtxtxv=∥xv∥2,
which must be nonnegative for any v. matrices satisfying this property are called
positive semidefinite . therefore, xtxis positive semidefinite.
implementation
solving the ridge regression is easy. first, we observe that the regularization function r(θ) =
∥θ∥2is a quadratic function. therefore, it can be combined with the data fidelity term as
bθ= argmin
θ∈rd∥xθ−y∥2+λ∥θ∥2
= argmin
θ∈rd∥xθ−y∥2+∥√
λiθ−0∥2
= argmin
θ∈rdx√
λi
θ−y
02
.
therefore, all we need to do is to concatenate the matrix xwith a d×didentity operator√
λi, and concatenate ywith a d×1 all-zero vector.
in matlab and python, the implementation of the ridge regression is done by defining
a new matrix aand a new vector b, as shown below:
% matlab command for ridge regression
a = [x; sqrt(lambda)*eye(d)];
b = [y(:); zeros(d,1)];
theta = a\b;
% matlab command for ridge regression
a = np.vstack((x, np.sqrt(lambd)*np.eye(d)))
b = np.hstack((y, np.zeros(d)))
theta = np.linalg.lstsq(a, b, rcond=none)[0]
4427.4. regularization
example 7.6 . consider a dataset of n= 20 data points. these data points are
constructed from the model
yn= 0.5−2xn−3x2
n+ 4x3
n+ 6x4
n+en, n = 1, . . . , n,
where en∼gaussian(0 ,0.252) is the noise. fit the data using
(a) vanilla linear regression with a 4th-order polynomial.
(b) vanilla linear regression with a 20th-order polynomial.
(c) ridge regression with a 20th-order polynomial, by considering three choices of λ:
λ= 10−6,λ= 10−3, and λ= 10.
solution .
(a) we first fit the data using a 4th-order polynomial. this fitting is relatively
straightforward. in the matlab / python programs below, set d= 4 and
λ= 0. the result is shown in figure 7.20 (a).
-1 -0.5 0 0.5 1-101234
data
fitted curve
-1 -0.5 0 0.5 1-101234
data
fitted curve
(a) vanilla, 4th-order polynomial (b) vanilla, 20th-order polynomial
figure 7.20: overfitting occurs when the model is too complex for the number of training samples.
when using a vanilla regression with a 20th-order polynomial, the curve overfits the data and
causes a catastrophic fitting error.
(b) suppose we use a 20th-order polynomial g(x) =p20
p=0θpxpto fit the data. we
plot the result in figure 7.20 (b). since the order of the polynomial is very high
relative to the number of training samples, it comes as no surprise that the fitting
is poor. this is overfitting, and we know the reason.
(c) next, we consider a ridge regression using three choices of λ. the result is shown
infigure 7.21 . ifλis too small, we observe that some overfitting still occurs. if
λis too large, then the curve underfits the data. for an appropriately chosen λ,
it can be seen that the fitting is reasonably good.
443chapter 7. regression
-1 -0.5 0 0.5 1-101234
data
fitted curve
-1 -0.5 0 0.5 1-101234
data
fitted curve
-1 -0.5 0 0.5 1-101234
data
fitted curve
(a) ridge, λ= 10−6(b) ridge, λ= 10−3(c) ridge, λ= 10
figure 7.21: ridge regression addresses the overfitting problem by adding a regularization term
to the training loss. depending on the strength of the parameter λ, the fitted curve can vary from
overfitting to underfitting.
the matlab and python codes used to generate the above plots are shown below.
% matlab code to demonstrate a ridge regression example
% generate data
n = 20;
x = linspace(-1,1,n);
a = [0.5, -2, -3, 4, 6];
y = a(1)+a(2)*x(:)+a(3)*x(:).^2+a(4)*x(:).^3+a(5)*x(:).^4+0.25*randn(n,1);
% ridge regression
lambda = 0.1;
d = 20;
x = zeros(n, d);
for p=0:d-1
x(:,p+1) = x(:).^p;
end
a = [x; sqrt(lambda)*eye(d)];
b = [y(:); zeros(d,1)];
theta = a\b;
% interpolate and display results
t = linspace(-1, 1, 500);
xhat = zeros(length(t), d);
for p=0:d-1
xhat(:,p+1) = t(:).^p;
end
yhat = xhat*theta;
plot(x,y, ’ko’,’linewidth’,2, ’markersize’, 10); hold on;
plot(t,yhat,’linewidth’,4,’color’,[0.2 0.2 0.9]);
# python code to demonstrate a ridge regression example
import numpy as np
import matplotlib.pyplot as plt
from scipy.special import eval_legendre
np.set_printoptions(precision=2, suppress=true)
4447.4. regularization
n = 20
x = np.linspace(-1,1,n)
a = np.array([0.5, -2, -3, 4, 6])
y = a[0] + a[1]*x + a[2]*x**2 + \
a[3]*x**3 + a[4]*x**4 + 0.25*np.random.randn(n)
d = 20
x = np.zeros((n, d))
for p in range(d):
x[:,p] = x**p
lambd = 0.1
a = np.vstack((x, np.sqrt(lambd)*np.eye(d)))
b = np.hstack((y, np.zeros(d)))
theta = np.linalg.lstsq(a, b, rcond=none)[0]
t = np.linspace(-1, 1, 500)
xhat = np.zeros((500,d))
for p in range(d):
xhat[:,p] = t**p
yhat = np.dot(xhat, theta)
plt.plot(x,y,’o’,markersize=12)
plt.plot(t,yhat, linewidth=4)
plt.show()
why does ridge regression work?
the penalty term ∥θ∥2in
bθridge= argmin
θ∈rd∥xθ−y∥2+λ∥θ∥2
does not allow solutions with very ∥θ∥2.
the penalty term adds a positive offset to the eigenvalues of xtx.
since the denominator in ( xtx+λi)−1xtybecomes larger than that of
(xtx)−1xty, noise in yis less amplified.
choosing the parameter
how should we choose the parameter λ? the honest answer is that there is no answer
because the optimal λcan only be found if we have access to the testing samples. if we do,
we can plot the mse (the testing error) with respect to λ, as shown in figure 7.22 (a).
of course in reality we do not have access to the testing data. however, we can reserve
a small portion of the training samples and treat them as validation samples . then we
run the ridge regression for different choices of λ. the λthat minimizes the error on these
validation samples is the one that you should deploy. if the training set is small, we can
445chapter 7. regression
10-1010-510010-310-210-1
10010500.050.10.150.20.250.3
(a) testing error vs λ (b)f(bθλ) vsr(bθλ)
figure 7.22: (a) determining the optimal λrequires knowledge of the testing samples. in practice, we
can replace the testing samples with the validation samples, which are subsets of the training data. then
by plotting the validation error as a function of λwe can determine the optimal λ. (b) the alternative
is to plot f(bθλ)versus r(bθλ). the optimal λcan be found by locating the elbow point.
shuffle the validation samples randomly and compute the average. this scheme is known as
cross-validation .
for some problems, there are “tactics” you may be able to employ for determining
the optimal λ. the first approach is to ask yourself what would be the reasonable range
of∥θ∥2or∥xθ−y∥2? are you expecting them to be large or small? approximately in
what order of magnitude? if you have some clues about this, then you can plot the function
f(bθλ) =∥xbθλ−y∥2as a function of r(bθλ) =∥bθλ∥2, where bθλis a shorthand notation
forbθridge(λ), which is the estimated parameter using a specific value of λ.figure 7.22 (b)
shows an example of such a plot. as you can see, by varying λwe have different values of
f(bθλ) and r(bθλ).
if you have some ideas about what ∥θ∥2should be, say you want ∥θ∥2≤τ, you can go
to the f(bθλ) versus r(bθλ) curve and find a point such that r(bθλ)≤τ. on the other hand,
if you want ∥xθ−y∥2≤ϵ, you can also go to the f(bθλ) versus r(bθλ) curve and find a
point such that ∥xθ−y∥2≤ϵ. in either case, you have the freedom to shift the difficulty
of finding λto that of finding τorϵ. note that τandϵhave better physical interpretations.
the quantity ϵtells us the upper bound of the prediction error, and τtells us the upper
bound of the parameter magnitude. if you have been working on your dataset long enough,
the historical data (and your experience) will help you determine these values.
another feasible option suggested in the literature is finding the anchor point of the
f(bθλ) and r(bθλ). the idea is that if the curve has a sharp elbow, the turning point would
indicate a rapid increase/decrease in f(bθλ) (or r(bθλ)).
how to determine λ
cross-validation: reserve a few training samples as validation samples. check
the prediction error w.r.t. these validation samples. the λthat minimizes the
validation error is the one you deploy.
∥θ∥2≤τ: plot the f(bθλ) and r(bθλ). then go along the r-axis to find the
4467.4. regularization
position where r(bθλ)≤τ.
∥xθ−y∥2≤τ: plot the f(bθλ) and r(bθλ). then go along the f-axis to find
the position where f(bθλ)≤ϵ.
find the elbow point of f(bθλ) and r(bθλ).
bias and variance trade-off for ridge regression
we now discuss the bias and variance trade-off of the ridge regression.
theorem 7.7. lety=xθ+ebe the training data, where eis zero-mean and has a
covariance σ2i. consider the ridge regression
bθλ=argmin
θ∈rd∥xθ−y∥2+λ∥θ∥2. (7.37)
then the estimate has the properties that
bθλ= (xtx+λi)−1xtxθ+ (xtx+λi)−1xte,
e[bθλ] = (xtx+λi)−1xtxθ=wλθ,
cov[bθλ] =σ2(xtx+λi)−1xtx(xtx+λi)−1,
mse(bθλ,θ) =σ2tr
wλ(xtx)−1wt
λ
+θt(wλ−i)t(wλ−i)θ,
where wλ= (xtx+λi)−1xtx.
proof . the proof of this theorem involves some tedious matrix operations that will be
omitted here. if you are interested in the proof you can consult van wieringen’s “lecture
notes on ridge regression”, https://arxiv.org/pdf/1509.09169.pdf .
□
the results of this theorem provide a way to assess the bias and variance. specifically,
from the mse we know that
mse(bθλ,θ) =eeh
∥bθλ−θ∥2i
=∥ee[bθλ]−θ∥2+ trn
cov[bθλ]o
=θt(wλ−i)t(wλ−i)θ| {z }
bias+σ2tr
wλ(xtx)−1wt
λ
| {z }
variance.
the bias and variance are defined respectively as
bias(bθλ,θ) =θt(wλ−i)t(wλ−i)θ,
var(bθλ,θ) =σ2tr
wλ(xtx)−1wt
λ
.
we can then plot the bias and variance as a function of λ. an example is shown in fig-
ure 7.23 .
447chapter 7. regression
10-410-310-210-110-1100101102103
mse
bias
variance
figure 7.23: the bias and variance of the ridge regression behave in opposite ways as λincreases. the
mse is the sum of bias and variance.
the result in figure 7.23 can be summarized in three points:
bias↑asλ↑. this is because a large λpushes the solution towards θ= 0. therefore,
the bias with respect to the ground truth θwill increase.
variance ↓asλ↑. since variance is caused by noise, increasing λforces the solution
θto be small. hence, it becomes less sensitive to noise.
mse reaches a minimum point somewhere in the middle. the mse is the sum of bias
and variance. therefore, it drops to the minimum and then rises again as λincreases.
with appropriate choice of λ, we can show that the ridge regression can have a
lower mean squared error than the vanilla regression. the following result is due to c. m.
theobald:6
theorem 7.8. forλ <2σ2∥θ∥−2,
mse
bθridge(λ),θ
<mse
bθvanilla ,θ
. (7.38)
this theorem says that as long as λis small enough, the ridge regression will have a lower
mse than the vanilla regression. thus ridge regression is almost always helpful. of course,
the optimal λis not provided by the theorem, which only tells us where to search for a
good λ.
why does ridge regression reduce the testing error?
the regularization reduces the variance (see figure 7.23 when λ >0)
it pays the price of increasing the bias.
6theobald, c. m. (1974). generalizations of mean square error applied to ridge regression. journal of
the royal statistical society . series b (methodological), 36(1), 103-106.
4487.4. regularization
usually, the drop in variance outweighs the increase in bias. so the overall mse
drops.
bias is not always a bad thing.
7.4.2 lasso regularization
the ridge regression we discussed in the previous subsection is just one of the many possible
ways of doing regularization. one alternative is to replace ∥θ∥2by∥θ∥1, where
∥θ∥1=d−1x
p=0|θp|. (7.39)
this change from the sum-squares to sum-absolute-values has been main driving force in
data science, machine learning, and signal processing for at least the past two decades. the
optimization associated with ∥θ∥1is
minimize
θ∈rd∥xθ−y∥2+λ∥θ∥1, (7.40)
or
etrain(θ) =nx
n=1
yn−d−1x
p=0θpϕp(xn)2
| {z }
f(θ),data fidelity+ λ·d−1x
p=0|θp|
|{z}
λ·r(θ),regularization. (7.41)
seeking a sparse solution
to understand the choice of ∥ · ∥ 1, we need to introduce the concept of sparsity .
definition 7.1. a vector θis called sparse if it has only a few non-zero elements.
as illustrated in figure 7.24 , a sparse θensures that only a very few columns of the data
matrix xare active. this is an attractive property because, in some of the regression
problems, it is indeed possible to have just a few dominant factors. the lasso regression
says that if our problem possesses this sparse solution, then the ∥ · ∥ 1can help us find the
sparse solution.
figure 7.24: a vector θis sparse if it only contains a few non-zero elements. if θis sparse, then the
observation yis determined by a few active components.
449chapter 7. regression
how can ∥θ∥1promote sparsity? if we consider the sets
ω1={θ| ∥θ∥1≤τ}={(θ1, θ2)| |θ1|+|θ2| ≤τ},
ω2={θ| ∥θ∥2≤τ}={(θ1, θ2)|θ2
1+θ2
2≤τ},
we note that ω 1has a diamond shape whereas ω 2has a circular shape. since the data
fidelity term ∥xθ−y∥2is an ellipsoid, seeking the optimal value in the presence of the
regularization term can be viewed as moving the ellipsoid until it touches the set defined
by the regularization. as illustrated in figure 7.25 , since {θ| ∥θ∥2≤τ}is a circle, the
solution will be somewhere in the middle. on the other hand, since {θ| ∥θ∥1≤τ}is a
diamond, the solution will be one of the vertices. the difference between “somewhere in
the middle” and “a vertex” is that the vertex is a sparse solution, since by the definition of
a vertex one coordinate must be zero and the other coordinate must be non-zero. we can
easily extrapolate this idea to the higher-dimensional spaces. in this case, we will see that
the solution for the ∥ · ∥ 1problem has only a few non-zero entries.
figure 7.25: a vector θis sparse if it contains only a few non-zero elements. if θis sparse, then the
observation yis determined by a few active components.
the optimization formulated in equation (7.41) is known as the least absolute shrink-
age and selection operator (lasso). lasso problems are difficult, but over the past two
decades we have increased our understanding of the problem. the most significant break-
through is that we now have algorithms to solve the lasso problem efficiently. this is
important because, unlike the ridge regression, where we have a (very simple) closed-form
solution, the lasso problem can only be solved using iterative algorithms.
what is so special about lasso?
lasso regularization promotes a sparse solution.
if the underlying model has a sparse solution, e.g., you choose a 50th-order
polynomial, but the underlying model is a third-order polynomial, then there
should only be three non-zero regression coefficients in your 50th-order polyno-
mial. lasso will help in this case.
4507.4. regularization
if the underlying model has a dense solution, then lasso is of limited value. a
ridge regression could be better.
while ∥θ∥1is not differentiable (at 0), there exist polynomial-time convex algo-
rithms to solve the problem, e.g., interior-point methods.
solving the lasso problem
today, there are many open-source packages to solve the lasso problem. they are mostly
developed in the convex optimization literature. one of the most user-friendly packages is
thecvxpackage developed by s. boyd and colleagues at stanford university.7once you
have downloaded and installed the package, solving the optimization can be done literally
by typing in the data fidelity term and the regularization term. an example is given below.
cvx_begin
variable theta(d)
minimize(sum_square(x*theta-y) + lambda*norm(theta,1))
cvx_end
as you can see, the program is extremely simple. you start by calling cvx_begin
and end it with cvx_end . inside the box we create a variable beta(d) , where ddenotes
the dimension of the vector theta . the main command is minimize . however, this line is
almost self-explanatory. as long as you follow the syntax given by the user guidelines, you
will be able to set it up properly.
in python, we can call the cvxpy library.
import cvxpy as cvx
theta = cvx.variable(d)
objective = cvx.minimize( cvx.sum_squares(x*theta-y) \
+ lambd*cvx.norm1(theta) )
prob = cvx.problem(objective)
prob.solve()
to see a concrete example, we use the crime rate data obtained from https://web.
stanford.edu/ ~hastie/statlearnsparsity/data.html . a snapshot of the data is shown
in the table below. in this dataset, the vector yis the crime rate, which is the last column
of the table. the feature/basis vectors are funding ,hs,not-hs ,college .
city crime rate funding hs no-hs college
1 478 40 74 11 31
2 494 32 72 11 43
3 643 57 71 18 16
4 341 31 71 11 25
..................
50 940 66 67 26 18
7the matlab version is here: http://cvxr.com/cvx/ . the python version is here: https://cvxopt.
org/. follow the instructions to install the package.
451chapter 7. regression
we consider two optimizations:
bθ1(λ) = argmin
θe1(θ)def=∥xθ−y∥2+λ∥θ∥1,
bθ2(λ) = argmin
θe2(θ)def=∥xθ−y∥2+λ∥θ∥2.
as we have discussed, the first optimization uses the ∥·∥1regularized least squares, which is
the lasso problem. the second optimization is the standard ∥·∥2regularized least squares.
since both solutions depend on the parameter λ, we parameterize the solutions in terms of
λ. note that the optimal λforbθ1is not necessarily the optimal λforbθ2.
one thing we would like to demonstrate in this example is visualizing the linear re-
gression coefficients bθ1(λ) andbθ2(λ) asλchanges. to solve the optimization, we use cvx
with the matlab and python implementation is shown below.
data = load(’./dataset/data_crime.txt’);
y = data(:,1); % the observed crime rate
x = data(:,3:end); % feature vectors
[n,d]= size(x);
lambdaset = logspace(-1,8,50);
theta_store = zeros(d,50);
for i=1:length(lambdaset)
lambda = lambdaset(i);
cvx_begin
variable theta(d)
minimize( sum_square(x*theta-y) + lambda*norm(theta,1) )
% minimize( sum_square(x*theta-y) + lambda*sum_square(theta) )
cvx_end
theta_store(:,i) = theta(:);
end
figure(1);
semilogx(lambdaset, theta_store, ’linewidth’, 4);
legend(’funding’,’% high’, ’% no high’, ’% college’, ...
’% graduate’, ’location’,’nw’);
xlabel(’lambda’);
ylabel(’feature attribute’);
import cvxpy as cvx
import numpy as np
import matplotlib.pyplot as plt
data = np.loadtxt("/content/data_crime.txt")
y = data[:,0]
x = data[:,2:7]
n,d = x.shape
lambd_set = np.logspace(-1,8,50)
4527.4. regularization
theta_store = np.zeros((d,50))
for i in range(50):
lambd = lambd_set[i]
theta = cvx.variable(d)
objective = cvx.minimize( cvx.sum_squares(x*theta-y) \
+ lambd*cvx.norm1(theta) )
# objective = cvx.minimize( cvx.sum_squares(x*theta-y) \
+ lambd*cvx.sum_squares(theta) )
prob = cvx.problem(objective)
prob.solve()
theta_store[:,i] = theta.value
for i in range(d):
plt.semilogx(lambd_set, theta_store[i,:])
10-2100102104106108
lambda-202468101214feature attributefunding
% high
% no high
% college
% graduate
10-2100102104106108
lambda-202468101214feature attributefunding
% high
% no high
% college
% graduate
(a) lasso (b) ridge
figure 7.26: ridge and lasso regression on the crime-rate dataset. (a) the lasso regression suggests
that there are only a few active components as we change λ. (b) the ridge regression returns a set of
dense solutions for all choices of λ.
figure 7.26 shows some interesting differences between the two regression models.
trajectory . for the ∥ · ∥2estimate bθ2(λ), the trajectory of the regression coefficients
is smooth. this is attributable to the fact that the training loss e2(θ) is continuously
differentiable in θ, and so the solution trajectory is smooth. by contrast, the ∥ · ∥ 1
estimate bθ1(λ) has a more disruptive trajectory.
active members . for the lasso problem, bθ1(λ) switches the active member as λ
changes. for example, the feature high-school is the first one being activated when
λ↓. this implies that if we limit ourselves to only onefeature, then high-school is
the feature we should select. the ridge regression does not have this feature-selection
property. how about when λ= 106? in this case, the lasso has two active members:
funding and high-school . this suggests that if there are two contributing factors,
funding andhigh-school are the two. as λ= 104, we see that in lasso, the green
curve goes to zero but then the red curve rises. this means a correlation between
453chapter 7. regression
high school andno high school , which should not be a surprise because they are
complementary to each other.
magnitude of solutions . the magnitude of the solutions does not necessarily convey
a clear conclusion because the feature vectors (e.g., high school ) and the observable
crime rate have different units.
limiting solutions . asλ→0, both bθ1(λ) andbθ2(λ) reach the same solution, because
the training losses are identical when λ= 0.
lasso for overfitting
does lasso help to mitigate the overfitting problem? not always, but it often does. in
figure 7.27 we consider fitting a dataset of n= 20 data points. the ground truth model
we use is
yn=l0(xn) + 0.5l1(xn) + 0.5l2(xn) + 1.5l3(xn) +l4(xn) +en,
where en∼gaussian(0 , σ2) for σ= 0.25. when fitting the data, we purposely choose a
20th-order legendre polynomial as the regression model. with only n= 20 data points, we
can be almost certain that there is overfitting.
the matlab and python codes for solving this lasso problem are shown below.
% matlab code to demonstrate overfitting and lasso
% generate data
n = 20;
x = linspace(-1,1,n)’;
a = [1, 0.5, 0.5, 1.5, 1];
y = a(1)*legendrep(0,x)+a(2)*legendrep(1,x)+a(3)*legendrep(2,x)+ ...
a(4)*legendrep(3,x)+a(5)*legendrep(4,x)+0.25*randn(n,1);
% solve lasso using cvx
d = 20;
x = zeros(n, d);
for p=0:d-1
x(:,p+1) = reshape(legendrep(p,x),n,1);
end
lambda = 2;
cvx_begin
variable theta(d)
minimize( sum_square( x*theta - y ) + lambda * norm(theta , 1) )
cvx_end
% plot results
t = linspace(-1, 1, 200);
xhat = zeros(length(t), d);
for p=0:d-1
xhat(:,p+1) = reshape(legendrep(p,t),200,1);
end
yhat = xhat*theta;
4547.4. regularization
plot(x,y, ’ko’,’linewidth’,2, ’markersize’, 10); hold on;
plot(t,yhat,’linewidth’,6,’color’,[0.2 0.5 0.2]);
# python code to demonstrate overfitting and lasso
import cvxpy as cvx
import numpy as np
import matplotlib.pyplot as plt
# setup the problem
n = 20
x = np.linspace(-1,1,n)
a = np.array([1, 0.5, 0.5, 1.5, 1])
y = a[0]*eval_legendre(0,x) + a[1]*eval_legendre(1,x) + \
a[2]*eval_legendre(2,x) + a[3]*eval_legendre(3,x) + \
a[4]*eval_legendre(4,x) + 0.25*np.random.randn(n)
# solve lasso using cvx
d = 20
lambd = 1
x = np.zeros((n, d))
for p in range(d):
x[:,p] = eval_legendre(p,x)
theta = cvx.variable(d)
objective = cvx.minimize( cvx.sum_squares(x*theta-y) \
+ lambd*cvx.norm1(theta) )
prob = cvx.problem(objective)
prob.solve()
thetahat = theta.value
# plot the curves
t = np.linspace(-1, 1, 500)
xhat = np.zeros((500,d))
for p in range(p):
xhat[:,p] = eval_legendre(p,t)
yhat = np.dot(xhat, thetahat)
plt.plot(x, y, ’o’)
plt.plot(t, yhat, linewidth=4)
let us compare the various regression results. figure 7.27 (b) shows the vanilla regres-
sion, which as you can see fits the n= 20 data points very well. however, no one would
believe that such a fitting curve can generalize to unseen data. figure 7.27 (c) shows the
ridge regression result. when performing the analysis, we sweep a range of λand pick the
value λ= 0.5 so that the fitted curve is neither too “wild” nor too “flat”. we can see that
the fitting is improved. however, since the ridge regression only penalizes large-magnitude
coefficients, the fitting is still not ideal. figure 7.27 (d) shows the lasso regression result.
since the true model is a 4th-order polynomial and we use a 20th-order polynomial, the true
solution is sparse. therefore, lasso is helpful, and hence we can pick a sparse solution.
the significance of lasso is often not about the fitting of the data points but the
455chapter 7. regression
-1 -0.5 0 0.5 1-101234
data
fitted curve
-1 -0.5 0 0.5 1-101234
data
fitted curve
(a) ground truth model (b) vanilla regression
-1 -0.5 0 0.5 1-101234
data
fitted curve
-1 -0.5 0 0.5 1-101234
data
fitted curve
(c) ridge (d) lasso
figure 7.27: we fit a dataset of n= 20 data points. (a) the ground truth model that generates
the data. the model is a 4th-order ordinary polynomial. (b) vanilla regression result, without any
regularization. note that there is severe overfitting because the model complexity is too high. (c) ridge
regression result, by setting λ= 0.5. (d) lasso regression result, by setting λ= 2.
number of active coefficients. in figure 7.28 we show a comparison between the ground
truth coefficients, the vanilla regression coefficients, the ridge regression coefficients, and the
lasso regression coefficients. it is evident that the lasso solution contains a much smaller
number of non-zeros compared to the ridge regression. most of the high-order coefficients
are zero. by contrast, the vanilla regression coefficients are wild. the ridge regression is
better, but there are many non-zero high-order coefficients.
closing remark . in this section, we discussed two regularization techniques: ridge regres-
sion and lasso regression. both techniques are about adding a penalty term to the training
loss to constrain the regression coefficients. in the optimization literature, writings on ridge
and lasso regression are abundant, covering both algorithms and theoretical properties.
an example of a theoretical question addressed in the literature is: under what conditions
is lasso guaranteed to recover the correct support of the solution, i.e., locating the correct
positions of the non-zeros? problems like these are beyond the scope of this book.
4567.5. summary
-2-1012
5 10 15 20
-15-10-5051015
5 10 15 20
(a) ground truth model (b) vanilla regression
-2-1012
5 10 15 20
-2-1012
5 10 15 20
(c) ridge (d) lasso
figure 7.28: coefficients of the regression models. (a) the ground truth model, which is a 4th-order
polynomial. there are only 5 non-zero coefficients. (b) the vanilla regression coefficients. note that
the values are wild and large, although the curve fits the training data points very well. (c) the ridge
regression coefficients. while the overall magnitudes are significantly improved from the vanilla, some
high-order coefficients are still non-zero. (d) the lasso regression coefficients. there are very few
non-zeros, and the non-zeros match well with the ground truth.
7.5 summary
regression is one of the most widely used techniques in data science. the formulation of the
regression problem is as simple as setting up a system of linear equations:
minimize
θ∈rd∥xθ−y∥2, (7.42)
which has a closed-form solution. the biggest problems in practice are outliers, lack of
training samples, and poor choice of the regression model.
outliers : we always recommend plotting the data whenever possible to check if there
are obvious outliers. there are also statistical tests in which you can evaluate the
validity of your samples. one simple way to debug outliers is to run the regression
457chapter 7. regression
and check the prediction error against each training sample. if you have an outlier,
and if your model is of reasonably low complexity, then a sample with an excessively
large prediction error is an outlier. for example, if most of the training samples are
within one standard deviation from your prediction but a few are substantially off,
you will know which ones are the outliers. robust linear regression is one technique for
countering outliers, but an experienced data scientist can often reject outliers before
running any regression algorithms. domain knowledge is of great value for this purpose.
lack of training samples : as we have discussed in the overfitting section, it is ex-
tremely important to ensure that your model complexity is appropriate for the number
of training samples. if the training set is small, do not use a complex model. regu-
larization techniques are valuable tools to mitigate overfitting. however, choosing a
good regularization requires domain knowledge. for example, if you know that some
features are not important, you need to scale them properly so as not to over-influence
the regression solution.
wrong model : we have mentioned several times that regression can always return you
a result because regression is an optimization problem. however, whether that result
is meaningful depends on how meaningful your regression problem is. for example, if
the noise is i.i.d. gaussian, a data fidelity term with ∥ · ∥2would be a good choice;
however, if the noise is i.i.d. poisson, ∥ · ∥2would become a very bad model. we need
a tighter connection with the statistics of the underlying data-generation model for
problems like these. this is the subject of our next chapter, on parameter estimation.
7.6 references
linear regression
treatment of standard linear regression is abundant. in the context of machine learning and
data science, the following references are useful.
7-1 gareth james, daniela witten, trevor hastie, and robert tibshirani, an introduction
to statistical learning with applications in r , springer 2013, chapter 3.
7-2 stephen boyd and lieven vandenberghe, convex optimization , cambridge university
press, 2004. chapter 6.
7-3 trevor hastie, robert tibshirani, and jerome friedman, the elements of statistical
learning , springer, 2001. chapter 3.
7-4 christopher bishop, pattern recognition and machine learning , springer 2006. chap-
ter 3.1.
7-5 yaser abu-mostafa, malik magdon-ismail and hsuan-tien lin, learning from data ,
aml book, 2012. chapter 3.2
overfitting and bias/variance
the theory of overfitting and the trade-off between bias and variance can be found in multiple
references. the following are basic treatments of the subject.
4587.7. problems
7-6 yaser abu-mostafa, malik magdon-ismail and hsuan-tien lin, learning from data ,
aml book, 2012. chapter 4.
7-7 christopher bishop, pattern recognition and machine learning , springer 2006. chap-
ter 3.2.
ridge and lasso regression
ridge and lasso regression are important tools in statistical learning today. the following
two textbooks cover some of the perspectives of the statistical community and the signal
processing community.
7-8 trevor hastie, robert tibshirani, and martin wainwright, statistical learning with
sparsity: the lasso and generalizations , crc press, 2015.
7-9 michael elad, sparse and redundant representations , springer, 2010. chapters 1
and 3.
7.7 problems
exercise 1.
(a) construct a dataset with n= 20 samples, following the model
yn=d−1x
p=0θplp(xn) +en, (7.43)
where θ0= 1, θ1= 0.5,θ2= 0.5,θ3= 1.5,θ4= 1, for −1< x < 1. here, lp(x) is the
legendre polynomial of the pth order. the n= 20 samples are random uniformly sam-
pled from the interval [ −1,1]. the noise samples enare i.i.d. gaussian with variance
σ2= 0.252. plot the dataset using the matlab or python command scatter .
(b) run the regression using the same model where d= 5, without any regularization.
plot the predicted curve and overlay with the training samples.
(c) repeat (b) by running the regression with d= 20. explain your observations.
(d) increase the number of training samples nton= 50, n= 500, and n= 5000, and
repeat (c). explain your observations.
(e) construct a testing dataset with m= 1000 testing samples. for each of the regression
models trained in (b)-(d), compute the testing error.
exercise 2.
consider a data generation model
xn=n−1x
k=0cke−j2πkn
n, n= 0, . . . , n −1.
459chapter 7. regression
(a) write the above equation in matrix-vector form
x=wc.
what are the vectors candx, and what is the matrix w?
(b) show that wis orthogonal, i.e.,, whw=i, where whis the conjugate transpose
ofw.
(c) using (b), derive the least squares regression solution.
exercise 3.
consider a simplified lasso regression problem:
bθ= argmin
θ∈rd∥y−θ∥2+λ∥θ∥1. (7.44)
show that the solution is given by
bθ= sign( y)·max (|y| −λ,0), (7.45)
where ·is the elementwise multiplication.
exercise 4.
a one-dimensional signal is corrupted by blur and noise:
yn=l−1x
ℓ=0hℓxn−ℓ+en.
(a) formulate the least squares regression problem in matrix-vector form y=hx+e.
findx,yandh.
(b) consider a regularization function
r(x) =nx
n=2(xn−xn−1)2.
show that this regularization is equivalent to r(x) =∥dx∥2for some d. find d.
(c) using the regularization in (b), derive the regularized least squares regression result:
minimize
x∥y−hx∥2+λ∥dx∥2.
exercise 5.
letσ(·) be the sigmoid function
σ(a) =1
1 +ea.
we want to use σ(a) as a basis function.
4607.7. problems
(a) show that the tanh function and the sigmoid function are related by
tanh( a) = 2 σ(2a)−1.
(b) show that a linear combination of sigmoid functions
yn=θ0+d−1x
p=1θpσxn−µj
s
is equivalent to a linear combination of tanh functions
yn=α0+d−1x
p=1αptanhxn−µj
2s
.
(c) find the relationship between θpandαp.
exercise 6. (nhanes part 1)(data download)
the national health and nutrition examination survey (nhanes) is a program to assess
the health and nutritional status of adults and children in the united states8. the complete
survey result contains over 4,000 samples of health-related data of individuals who partici-
pated in the survey between 2011 and 2014. in the following exercises, we will focus on two
categories of the data for each individual: height (in mm) and body mass index (bmi). the
data is divided into two classes based on gender. table 1 contains snippets of the data.
index female bmi female stature mm
0 28.2 1563
1 22.2 1716
2 27.1 1484
3 28.1 1651index male bmi male stature mm
0 30 1679
1 25.6 1586
2 24.2 1773
3 27.4 1816
table 7.2: male and female data snippets
usecsv.reader to read the training data files for the two data classes.
important! before proceeding to the problems,
normalize the number in male_stature_mm andfemale_stature_mm by dividing them
by 1000, and
normalize that of male_bmi andfemale_bmi by dividing them by 10.
this will significantly reduce the numerical error.
consider a linear model:
gθ=θtx, (7.46)
8https://www.cdc.gov/nchs/nhanes/index.htm
461chapter 7. regression
the regression problem we want to solve is
bθ= argmin
θ∈rdnx
n=1(yn−gθ(xn))2,
where d={(xn, yn)}n
n=1is the training dataset. putting the equation into the matrix form,
we know that the optimization is equivalent to
bθ= argmin
θ∈rd∥y−xθ∥2
|{z}
etrain(θ).
(a) derive the solution bθ. state the conditions under which the solution is the unique
global minimum in terms of the rank of x. suggest two techniques that can be used
when xtxis not invertible.
(b) for the nhanes dataset, assign yn= +1 if the nth sample is a male and yn=−1
if the nth sample is a female. implement your answer in (a) with python to solve the
problem. report your answer.
(c) repeat (b), but this time use cvxpy. report your answer, and compare with (b).
exercise 7. (nhanes part 2)(data download)
we want to do a classification based on the linear model we found in the previous exercise.
the classifier we will use is
predicted label = sign( gθ(x)), (7.47)
where x∈rdis the a test sample. here, we label +1 for male and −1 for female. because
the dataset we consider in this exercise has only two columns, the linear model is
gθ(x) =θ0+θ1x1+θ2x2,
where x= [1, x1, x2]tis the input data and θ= [θ0, θ1, θ2]tis the parameter vector.
(a) first, we want to visualize the classifier.
(i) plot the training data points of the male and female classes. mark the male class
with blue circles and the female class with red dots.
(ii) plot the decision boundary gθ(·) and overlay it with the data plotted in (a).
hint: gθ(·) is a straight line in 2d. you can express x2in terms of x1and other
parameters.
(b) (this problem requires knowledge of the content of chapter 9). report the classifica-
tion accuracy. to do so, take testing data xand compute the prediction according to
equation (7.47).
(i) what is the type 1 error (false alarm) of classifying males? that is, what is the
percentage of testing samples that should be female but a male was predicted?
(ii) what is the type 2 error (miss) of classifying males? that is, what is the per-
centage of testing samples that should be male but a female was predicted?
4627.7. problems
(iii) what is the precision and recall for this classifier? for the definitions of precision
and recall, refer to chapter 9.5.4.
exercise 8. (nhanes part 3)(data download)
this exercise requires some background in optimization. please refer to reference [7.2, chap-
ter 9 and 10]. consider the following three optimization problems:
bθλ= argmin
θ∈rd∥xθ−y∥2
2+λ∥θ∥2
2, (7.48)
bθα= argmin
θ∈rd∥xθ−y∥2
2subject to ∥θ∥2
2≤α, (7.49)
bθϵ= argmin
θ∈rd∥θ∥2
2subject to ∥xθ−y∥2
2≤ϵ. (7.50)
(a) set lambd = np.arange(0.1,10,0.1) . plot
∥xbθλ−y∥2
2as a function of ∥bθλ∥2
2.
∥xbθλ−y∥2
2as a function of λ.
∥bθλ∥2
2as a function of λ.
(b) (i) write down the lagrangian for each of the three problems. note that the first
problem does not have any lagrange multiplier. for the second and third prob-
lems you may use the following notations:
γα= the lagrange multiplier of equation (7.49), and
γϵ= the lagrange multiplier of equation (7.50).
(ii) state the first-order optimality conditions (the karush-kuhn-tucker or kkt
conditions) for each of the three problems. express your answers in terms of x,
θ,y,λ,α,ϵ, and the two lagrange multipliers γα,γϵ.
(iii) fix λ >0. we can solve equation (7.48) to obtain bθλ. find αand the lagrange
multiplier γαin equation (7.49) such that bθλwould satisfy the kkt conditions
of equation (7.49).
(iv) fix λ >0. we can solve equation (7.48) to obtain bθλ. find ϵand the lagrange
multiplier γϵin equation (7.50) such that bθλwould satisfy the kkt conditions
of equation (7.50).
(v) fix λ >0. by using the αandγαyou found in (iii), you can show that bθλwould
satisfy the kkt conditions of equation (7.49). is it enough to claim that bθλis
the solution of equation (7.49)? if yes, why? if no, what else do we need to show?
please elaborate through a proof, if needed.
exercise 9.
consider a training dataset dtrain={(x1, y1), . . . , (xn, yn)}and a weight w= [w1, . . . , w n]t.
find the regression solution to the following problem and discuss how you would choose the
weight.
bθ= argmin
θ∈rdnx
n=1wn 
yn−xt
nθ2. (7.51)
463chapter 7. regression
exercise 10.
consider a training dataset dtrain={(x1, y1), . . . , (xn, yn)}. suppose that the input data
xnis corrupted by i.i.d. gaussian noise en∼gaussian(0 , σ2id) so that the training set
becomes dtrain={(x1+e1, y1), . . . , (xn+en, yn)}. show that the (vanilla) least squares
linear regression by taking the expectation over en,
bθ= argmin
θ∈rdnx
n=1eenh 
yn−(xn+en)tθ2i
, (7.52)
is equivalent to a ridge regression.
464chapter 8
estimation
in this chapter, we discuss another set of important combat skills in data science, namely es-
timation . estimation has a close relationship with regression. regression primarily takes the
optimization route, while estimation takes the probabilistic route. as we will see, at a cer-
tain point the two will merge. that is, under some specific statistical conditions, estimation
processes will coincide with the regression.
estimation is summarized pictorially in figure 8.1 . imagine that we have some random
samples x1, . . . , x n. these samples are drawn from a distribution fx(x;θ), where θis a
parameter that characterizes the distribution. the parameter θis not known to us. the
goal of estimation is to solve an inverse problem to recover the parameter based on the
observations x1, . . . , x n.
figure 8.1: estimation is an inverse problem of recovering the unknown parameters that were used by
the distribution. in this figure, the pdf of xusing a parameter θis denoted as fx(x;θ). the forward
data-generation process takes the parameter θand creates the random samples x1, . . . , x n. estimation
takes these observed random samples and recovers the underlying model parameter θ.
what is estimation?
estimation is an inverse problem with the goal of recovering the underlying pa-
rameter θof a distribution fx(x;θ) based on the observed samples x1, . . . , x n.
465chapter 8. estimation
what are parameters?
before we discuss the methods of estimation, let us clarify the meaning of the parameter θ.
all probability density functions (pdfs) have parameters. for example, a bernoulli random
variable is characterized by a parameter pthat defines the probability of getting a “head”. a
gaussian random variable is characterized by two parameters: the mean µand variance σ2.
example 8.1 . (parameter of a bernoulli ) ifxnis a bernoulli random variable, then
the pmf has a parameter θ:
pxn(xn;θ) =θxn(1−θ)1−xn.
remark . the pmf is expressed in this form because xnis either 1 or 0:
pxn(xn;θ) =(
θ1(1−θ)1−1=θ, if xn= 1,
θ0(1−θ)1−0= 1−θ, if xn= 0.
example 8.2 . (parameter of a gaussian ) ifxnis a gaussian random variable, the
pdf is
fxn(xn;θ|{z}
=(µ,σ)) =1√
2πσ2exp
−(xn−µ)2
2σ2
,
where θ= [µ, σ] consists of both the mean and the variance. we can also designate
the parameter θto be the mean only. for example, if we know that σ= 1, then the
pdf is
fxn(xn;θ|{z}
=µ) =1√
2πexp
−(xn−µ)2
2
,
where θis the mean.
since all probability density functions have parameters, estimating them from the
observed random variables is a well-defined inverse problem. of course, there are better
estimates and there are worse estimates. let us look at the following example to develop
our intuitions about estimation.
figure 8.2 shows a dataset containing 1000 data points generated from a 2d gaussian
distribution with an unknown mean vector µand an unknown covariance matrix σ. we
duplicate this dataset in the four subfigures. the estimation problem is to recover the
unknown mean vector µand the covariance matrix σ. in the subfigures we propose four
candidates, each with a different mean vector and a different covariance matrix. we draw
the contour lines of the corresponding gaussians. it can be seen that some gaussians fit the
data better than others. the goal of this chapter is to develop a systematic way of finding
the best fit for the data.
plan for this chapter
the discussions in this chapter concern the three elementary distributions:
466-5 -4 -3 -2 -1 0 1 2 3 4 5-5-4-3-2-1012345
-5 -4 -3 -2 -1 0 1 2 3 4 5-5-4-3-2-1012345
-5 -4 -3 -2 -1 0 1 2 3 4 5-5-4-3-2-1012345
-5 -4 -3 -2 -1 0 1 2 3 4 5-5-4-3-2-1012345bad estimate bad estimate bad estimate good estimate
µ=
2
−0.5
µ=
0
−1.5
µ=
−0.5
−0.7
µ=
0
0
σ=0.25 0 .2
0.2 1
σ=1−0.2
−0.2 0 .1
σ=1 0
0 1
σ=0.25 0 .3
0.3 1
figure 8.2: an estimation problem. given a set of 1000 data points drawn from a gaussian distribution
with unknown mean µand covariance σ, we propose several candidate gaussians and see which one
would be the best fit to the data. visually, we observe that the right-most gaussian has the best fit.
the goal of this chapter is to develop a systematic way of solving estimation problems of this type.
likelihood: fx|θ(x|θ), which is the conditional pdf of xgiven that the parameter
isθ.
prior: fθ(θ), which is the pdf of θ.
posterior: fθ|x(θ|x), which is the conditional pdf of θgiven the data x.
each of these density functions has its respective meaning, and consequently a set of different
estimation techniques. in section 8.1 we introduce the concept of maximum-likelihood (ml)
estimation. as the name suggests, the estimate is constructed by maximizing the likelihood
function. we will discuss a few examples of ml estimation and draw connections between
ml estimation and regression. in section 8.2 we will discuss several basic properties of an
ml estimate. specifically, we will introduce the ideas of unbiasedness, consistency, and the
invariance principle.
the second topic discussed in this chapter is the maximum-a-posteriori (map) esti-
mation, detailed in section 8.3. in map, the parameter θis a random variable. since θis a
random variable, it has its own probability density function fθ(θ), which we call the prior.
given the likelihood and the prior, we can define the posterior . the map estimation finds
the peak of the posterior distribution as a way to “explain” the data. several important
topics will be covered in section 8.3. for example, we will discuss the choice of the prior
via the concept of conjugate prior . we will also discuss how map is related to regularized
regressions such as the ridge and lasso regressions.
the third topic is the minimum mean-square estimation (mmse), outlined in sec-
tion 8.4. the mmse is a bayesian approach. an important result that will be demonstrated
is that the mmse estimate is the conditional expectation of the posterior distribution. in
other words, it is the mean of the posterior. an mmse estimate has an important difference
compared to a map estimate, namely that while an mmse estimate is the mean of the
posterior, a map estimate is the mode of the posterior. we discuss the formulation of the
estimation problem and ways of solving the problem. we also discuss how the mmse can
be performed for multidimensional gaussian distributions.
467chapter 8. estimation
8.1 maximum-likelihood estimation
maximum-likelihood (ml) estimation, as the name suggests, is an estimation method that
“maximizes” the “likelihood”. therefore, to understand the ml estimation, we first need to
understand the meaning of likelihood, and why maximizing the likelihood would be useful.
8.1.1 likelihood function
consider a set of ndata points d={x1, x2, . . . , x n}. we want to describe these data points
using a probability distribution. what would be the most general way of defining such a
distribution?
since we have ndata points, and we do not know anything about them, the most gen-
eral way to define a distribution is as a high-dimensional probability density function (pdf)
fx(x). this is a pdf of a random vector x= [x1, . . . , x n]t. a particular realization of
this random vector is x= [x1, . . . , x n]t.
fx(x) is the most general description for the ndata points because fx(x) is the
joint pdf of all variables. it provides the complete statistical description of the vector x.
for example, we can compute the mean vector e[x], the covariance matrix cov( x), the
marginal distributions, the conditional distribution, the conditional expectations, etc. in
short, if we know fx(x), we know everything about x.
the joint pdf fx(x) is always parameterized by a certain parameter θ. for example, if
we assume that xis drawn from a joint gaussian distribution, then fx(x) is parameterized
by the mean vector µand the covariance matrix σ. so we say that the parameter θis
θ= (µ,σ). to state the dependency on the parameter explicitly, we write
fx(x;θ) = pdf of the random vector xwith a parameter θ.
when you express the joint pdf as a function of xandθ, you have two variables to
play with. the first variable is the observation x, which is given by the measured data. we
usually think about the probability density function fx(x) in terms of x, because the pdf
is evaluated at x=x. in estimation, however, xis something that you cannot control.
when your boss hands a dataset to you, xis already fixed. you can consider the probability
of getting this particular x, but you cannot change x.
the second variable stated in fx(x;θ) is the parameter θ. this parameter is what
we want to find out, and it is the subject of interest in an estimation problem. our goal is
to find the optimal θthat can offer the “best explanation” to data x, in the sense that it
can maximize fx(x;θ).
thelikelihood function is the pdf that shifts the emphasis to θ:
definition 8.1. letx= [x1, . . . , x n]tbe a random vector drawn from a joint pdf
fx(x;θ), and let x= [x1, . . . , x n]tbe the realizations. the likelihood function is a
4688.1. maximum-likelihood estimation
function of the parameter θgiven the realizations x:
l(θ|x)def=fx(x;θ). (8.1)
a word of caution: l(θ|x) isnota conditional pdf because θis not a random variable.
the correct way to interpret l(θ|x) is to view it as a function of θ. this function changes
its shape according the observed data x. we will return to this point shortly.
independent observations
while fx(x) provides us with a complete picture of the random vector x, using fx(x) is
tedious. we need to describe how each xnis generated and describe how xnis related to
xmfor all pairs of nandm. if the vector xcontains nentries, then there are n2/2 pairs
of correlations we need to compute. when nis large, finding fx(x) would be very difficult
if not impossible.
in practice, fx(x) may sometimes be overkill. for example, if we measure the inter-
arrival time of a bus for several days, it is quite likely that the measurements will not be
correlated. in this case, instead of using the full fx(x), we can make assumptions about
the data points. the assumption we will make is that all the data points are independent
and that they are drawn from an identical distribution fx(x). the assumption that the
data points are independently and identically distributed (i.i.d.) significantly simplifies the
problem so that the joint pdf fxcan be written as a product of single pdfs fxn:
fx(x) =fx1,...,x n(x1, . . . , x n) =ny
n=1fxn(xn).
if you prefer a visualization, we can take a look at the covariance matrix, which goes
from a full covariance matrix to a diagonal matrix and then to an identity matrix:

var[x1] cov( x1, x2)··· cov(x1, xn)
cov[x2, x1] var[ x2] ··· cov(x2, xn)
............
cov(xn, x1) cov( xn, x2)··· var[xn]
=⇒
independent
var[x1] 0 ··· 0
0 var[ x2]··· 0
............
0 0 ··· var[xn]

=⇒
identical
σ20··· 0
0σ2··· 0
............
0 0 ··· σ2
.
the assumption of i.i.d. is strong. not all data can be modeled as i.i.d. (for example,
photons passing through a scattering medium have correlated statistics.) however, if the
i.i.d. assumption is valid, we can simplify the model significantly.
if the data points are i.i.d., then we can write the joint pdf as
fx(x;θ) =ny
n=1fxn(xn;θ).
this gives us a simplified form of the likelihood function, written as a product of the indi-
vidual pdfs.
469chapter 8. estimation
definition 8.2. given i.i.d. random variables x1, . . . , x nthat all have the same pdf
fxn(xn), the likelihood function is
l(θ|x)def=ny
n=1fxn(xn;θ). (8.2)
in computation we often take the log of the likelihood function. we call the resulting function
thelog-likelihood .
definition 8.3. given a set of i.i.d. random variables x1, . . . , x nwith pdf fxn(x; ;θ),
thelog-likelihood is defined as
logl(θ|x) = log fx(x;θ) =nx
n=1logfxn(xn;θ). (8.3)
example 8.3 . find the log-likelihood of a sequence of i.i.d. gaussian random variables
x1, . . . , x nwith mean µand variance σ2.
solution . since the random variables x1, . . . , x nare i.i.d. gaussian, the pdf is
fx(x;µ, σ2) =ny
n=11√
2πσ2e−(xn−µ)2
2σ2
. (8.4)
taking the log on both sides yields the log-likelihood function:
logl(µ, σ2|x) = log fx(x;µ, σ2)
= log(ny
n=11√
2πσ2e−(xn−µ)2
2σ2)
=nx
n=1log1√
2πσ2e−(xn−µ)2
2σ2
=nx
n=1
−1
2log(2πσ2)−(xn−µ)2
2σ2
=−n
2log(2πσ2)−1
2σ2nx
n=1(xn−µ)2.
practice exercise 8.1 . find the log-likelihood of a sequence of i.i.d. bernoulli random
variables x1, . . . , x nwith parameter θ.
4708.1. maximum-likelihood estimation
solution . ifx1, . . . , x nare i.i.d. bernoulli random variables, we have
fx(x;θ) =ny
n=1
θxn(1−θ)1−xn
.
taking the log on both sides of the equation yields the log-likelihood function:
logl(θ|x) = log(ny
n=1
θxn(1−θ)1−xn)
=nx
n=1log
θxn(1−θ)1−xn
=nx
n=1xnlogθ+ (1−xn) log(1 −θ)
= nx
n=1xn!
·logθ+ 
n−nx
n=1xn!
·log(1−θ).
visualizing the likelihood function
the likelihood function l(θ|x) is a function of θ, but its value also depends on the under-
lying measurements x. it is extremely important to keep in mind the presence of both.
to help you visualize the effect of θandx, we consider a set of i.i.d. bernoulli random
variables. as we have just shown in the practice exercise, the likelihood function of these
i.i.d. random variables is
logl(θ|x) = nx
n=1xn!
|{z}
s·logθ+ 
n−nx
n=1xn!
|{z }
n−s·log(1−θ), (8.5)
where we define s=pn
n=1xnas the sum of the (binary) measurements.
to make the dependency on sandθexplicit, we write l(θ|x) as
logl(θ|s) =slogθ+ (n−s) log(1 −θ), (8.6)
which emphasizes the role of sin defining the log-likelihood function. we plot the surface
ofl(θ|s) as a function of sandθ, assuming that n= 50. as shown on the left-hand side
offigure 8.3 , the surface l(θ|s) has a saddle shape. along one direction the function goes
up, whereas along another direction the function goes down. in the middle of figure 8.3 ,
we show a bird’s-eye view of the surface, with the color-coding matched with the surface
plot. as you can see, when plotted as a function of θandx(in our case, we use a summary
statistic s=pn
n=1xn), the two-dimensional plot tells us how the log-likelihood function
changes when schanges. on the right-hand side of figure 8.3 , we show two particular
cross sections of the two-dimensional plot. one cross section is taken from s= 25 and the
other cross section is taken from s= 12. since the total number of heads in this numerical
experiment is assumed to be n= 50, the first cross section at s= 25 is obtained when
471chapter 8. estimation
figure 8.3: we plot the log-likelihood function as a function of s=pn
n=1xnandθ. [left] we show
the surface plot of l(θ|s) =slogθ+ (n−s) log(1 −θ). note that the surface has a saddle shape.
[middle] by taking a bird’s-eye view of the surface plot, we obtain a 2-dimensional contour plot of the
surface, where the color code matches the height of the log-likelihood function. [right] we take two
cross sections along s= 25 ands= 12 . observe how the shape changes.
half of the bernoulli measurements are “1”, whereas the second cross section at s= 12 is
obtained when a quarter of the bernoulli measurements are “1”.
the cross sections tell us the log-likelihood function log l(θ|s) is a function defined
specifically for a given measurement x. as you can see from figure 8.3 , the log-likelihood
function changes when schanges. therefore, if our goal is to “find a θthat maximizes the
log-likelihood function”, then for a different xwe will have a different answer. for example,
according to figure 8.3 , the maximum for log l(θ|s= 25) occurs when θ≈0.5, and the
maximum for log l(θ|s= 12) occurs when θ≈0.24. these are the maximum-likelihood
estimates for the respective measurements.
we use the following matlab code to generate the surface plot:
% matlab code to generate the surface plot
n = 50;
s = 1:n;
theta = linspace(0.1,0.9,100);
[s_grid, theta_grid] = meshgrid(s, theta);
l = s_grid.*log(theta_grid) + (n-s_grid).*log(1-theta_grid);
s = surf(s,theta,l);
s.linestyle = ’-’;
colormap jet
view(65,15)
for the bird’s-eye view plot, we replace surf with imagesc(s,theta,l) . for the cross
section plots, we call the commands plot(theta, l(:,12)) andplot(theta, l(:,25)) .
8.1.2 maximum-likelihood estimate
the likelihood is the pdf of xbut viewed as a function of θ. the optimization problem
of maximizing l(θ|x) is called the maximum-likelihood (ml) estimation:
4728.1. maximum-likelihood estimation
definition 8.4. letl(θ)be the likelihood function of the parameter θgiven the
measurements x= [x1, . . . , x n]t. the maximum-likelihood estimate of the parameter
θis a parameter that maximizes the likelihood:
bθmldef=argmax
θl(θ|x). (8.7)
example 8.4 . find the ml estimate for a set of i.i.d. bernoulli random variables
{x1, . . . , x n}with xn∼bernoulli( θ) for n= 1, . . . , n .
solution . we know that the log-likelihood function of a set of i.i.d. bernoulli random
variables is given by
logl(θ|x) = nx
n=1xn!
·logθ+ 
n−nx
n=1xn!
·log(1−θ). (8.8)
thus, to find the ml estimate, we need to solve the optimization problem
bθml= argmax
θ( nx
n=1xn!
·logθ+ 
n−nx
n=1xn!
·log(1−θ))
.
taking the derivative with respect to θand setting it to zero, we obtain
d
dθ( nx
n=1xn!
·logθ+ 
n−nx
n=1xn!
·log(1−θ))
= 0.
this gives us
pn
n=1xn
θ−n−pn
n=1xn
1−θ= 0.
rearranging the terms yields
bθml=1
nnx
n=1xn.
let’s do a sanity check to see if this result makes sense. the solution to this problem
says that bθmlis the empirical average of the measurements. assume that n= 50. let us
consider two particular scenarios as illustrated in figure 8.4 .
scenario 1 :xis a vector of measurements such that sdef=pn
n=1xn= 25. since
n= 50, the formula tells us that bθml=25
50= 0.5. this is the bestguess based on the
50 measurements where 25 are heads. if you look at figure 8.3 andfigure 8.4 , when
s= 25, we are looking at a particular cross section in the 2d plot. the likelihood
function we are inspecting is l(θ|s= 25). for this likelihood function, the maximum
occurs at θ= 0.5.
473chapter 8. estimation
figure 8.4: illustration of how the maximum-likelihood estimate of a set of i.i.d. bernoulli random
variables is determined. the subfigures above show two particular scenarios at s= 25 ands= 12 ,
assuming that n= 50 . when s= 25 , the likelihood function has a quadratic shape centered at
θ= 0.5. this point is also the peak of the likelihood function when s= 25 . therefore, the ml estimate
isbθml= 0.5. the second case is when s= 12 . the quadratic likelihood is shifted toward the left. the
ml estimate is bθml= 0.24.
scenario 2 :xis a vector of measurements such that sdef=pn
n=1xn= 12. the formula
tells us that bθml=12
50= 0.24. this is again the bestguess based on the 50 measure-
ments where 12 are heads. referring to figure 8.3 andfigure 8.4 , we can see that
the likelihood function corresponds to another cross section l(θ|s= 12) where the
maximum occurs at θ= 0.24.
at this point, you may wonder why the shape of the likelihood function l(θ|x) changes
so radically as xchanges? the answer can be found in figure 8.5 . imagine that we have
n= 50 measurements of which s= 40 give us heads. if these i.i.d. bernoulli random
variables have a parameter θ= 0.5, it is quite unlikely that we will get 40 out of 50
measurements to be heads. (if it were θ= 0.5, we should get more or less 25 out of 50
heads.) when s= 40, and without any additional information about the experiment, the
most logical guess is that the bernoulli random variables have a parameter θ= 0.8. since
the measurement scan be as extreme as 0 out of 50 or 50 out of 50, the likelihood function
l(θ|x) has to reflect these extreme cases. therefore, as we change x, we observe a big
change in the shape of the likelihood function.
as you can see from figure 8.5 ,s= 40 corresponds to the marked vertical cross
section. as we determine the maximum-likelihood estimate, we search among all the possi-
bilities, such as θ= 0.2,θ= 0.5,θ= 0.8, etc. these possibilities correspond to the horizontal
lines we drew in the figure. among those horizontal lines, it is clear that the best estimate
occurs when θ= 0.8, which is also the ml estimate.
4748.1. maximum-likelihood estimation
figure 8.5: suppose that we have a set of measurements such that s= 40 . to determine the ml
estimate, we look at the vertical cross section at s= 40 . among the different candidate parameters,
e.g.,θ= 0.2,θ= 0.5andθ= 0.8, we pick the one that has the maximum response to the likelihood
function. for s= 40 , it is more likely that the underlying parameter is θ= 0.8than θ= 0.2orθ= 0.5.
visualizing ml estimation as ngrows
maximum-likelihood estimation can also be understood directly from the pdf instead of
the likelihood function. to explain this perspective, let’s do a quick exercise.
practice exercise 8.2 . suppose that xnis a gaussian random variable. assume
thatσ= 1 is known but the mean θis unknown. find the ml estimate of the mean.
solution . the ml estimate bθmlis
bθml= argmax
θlogl(θ|x)
= argmax
θlog(ny
n=11√
2πexp
−(xn−θ)2
2)
= argmax
θ−n
2log(2π)−1
2nx
n=1(xn−θ)2.
taking the derivative with respect to θ, we obtain
d
dθ(
−n
2log(2π)−1
2nx
n=1(xn−θ)2)
= 0.
this gives uspn
n=1(xn−θ) = 0. therefore, the ml estimate is
bθml=1
nnx
n=1xn.
now we will draw the pdf and compare it with the measured data points. our focus
475chapter 8. estimation
is to analyze how the ml estimate changes as ngrows.
when n= 1.there is only one observation x1. the best gaussian that fits this sample
must be the one that is centered at x1. in fact, the optimization is1
bθml= argmax
θlogl(θ|x1) = argmax
θlog1√
2πσ2exp
−(x1−θ)2
2σ2
= argmax
θ−(x1−θ)2=x1.
therefore, the ml estimate is bθml=x1.figure 8.6 illustrates this case. as we conduct the
ml estimation, we imagine that there are a few candidate pdfs. the ml estimation says
that among all these candidate pdfs we need to find one that can maximize the probability
of obtaining the observation x1. since we only have one observation, we have no choice but
to pick a gaussian centered at x1. certainly the sample x1=x1could be bad, and we may
find a wrong gaussian. however, with only one sample there is no way for us to make better
decisions.
-5 -4 -3 -2 -1 0 1 2 3 4 5
x00.050.10.150.20.250.30.350.40.450.5
data point
candidate pdf
estimated pdf
figure 8.6: n= 1. suppose that we are given one observed data point located around x=−2.1. to
conduct the ml estimation we propose a few candidate pdfs, each being a gaussian with unit variance
but a different mean θ. the ml estimate is a parameter θsuch that the corresponding pdf matches
the best with the observed data. in this example the best match happens when the estimated gaussian
pdf is centered at x1.
when n= 2.in this case we need to find a gaussian that fits both x1andx2. the
probability of simultaneously observing x1andx2is determined by the joint distribution.
by independence we then have
bθml= argmax
θlog(1√
2πσ22
exp
−(x1−θ)2+ (x2−θ)2)
2σ2)
= argmax
θ
−(x1−θ)2+ (x2−θ)2
2σ2
=x1+x2
2,
1we skip the step of checking whether the stationary point is a maximum or a minimum, which can be
done by evaluating the second-order derivative. in fact, since the function −(x1−θ)2is concave in θ, a
stationary point must be a maximum.
4768.1. maximum-likelihood estimation
where the last step is obtained by taking the derivative:
d
dθ
(x1−θ)2+ (x2−θ)2	
= 2(x1−θ) + 2( x2−θ).
equating this with zero yields the solution θ=x1+x2
2. therefore, the best gaussian that
fits the observations is gaussian(x1+x2
2, σ2).
-5 -4 -3 -2 -1 0 1 2 3 4 5
x00.050.10.150.20.250.30.350.40.450.5
data point
candidate pdf
estimated pdf
figure 8.7: n= 2. suppose that we are given two observed data points located around x1=−0.98
andx2=−1.15. to conduct the ml estimation we propose a few candidate pdfs, each being a
gaussian with unit variance but a different mean θ. the ml estimate is a parameter θsuch that the
corresponding pdf best matches the observed data. in this example the best match happens when the
estimated gaussian pdf is centered at (x1+x2)/2≈ −1.07.
does this result make sense? when you have two data points x1andx2, the ml
estimation is trying to find a gaussian that can best fit both of these two data points.
your best bet here is bθml= (x1+x2)/2, because there are no other choices. if you choose
bθml=x1orbθml=x2, it cannot be a good estimate because you are not using both data
points. as shown in figure 8.7 , for these two observed data points x1andx2, the pdf
marked in red (which is a gaussian centered at ( x1+x2)/2) is indeed the best fit.
when n= 10 andn= 100 .we can continue the above calculation for n= 10 and
n= 100. in this case the mle is
bθml= argmax
θlog(1√
2πσ2n
exp
−(x1−θ)2+···+ (xn−θ)2
2σ2)
= argmax
θ−nx
n=1(xn−θ)2
2σ2=1
nnx
n=1xn.
where the optimization is solved by taking the derivative:
d
dθnx
n=1(xn−θ)2=−2nx
n=1(xn−θ)
equating this with zero yields the solution θ=1
npn
n=1xn.
the result suggests that for an arbitrary number of training samples the ml estimate
is the sample average. these cases are illustrated in figure 8.8 . as you can see, the red
curves (the estimated pdf) are always trying to fit as many data points as possible.
the above experiment tells us something about the ml estimation:
477chapter 8. estimation
-5 -4 -3 -2 -1 0 1 2 3 4 500.050.10.150.20.250.30.350.40.450.5
data point
candidate pdf
estimated pdf
-5 -4 -3 -2 -1 0 1 2 3 4 500.050.10.150.20.250.30.350.40.450.5
data point
candidate pdf
estimated pdf
(c)n= 10 (d) n= 100
figure 8.8: when n= 10 andn= 100 , the ml estimation continues to evaluate the different
candidate pdfs. for a given set of data points, the ml estimation picks the best pdf to fit the data
points. in this gaussian example it was shown that the optimal parameter is bθml= (1/n)pn
n=1xn,
which is the sample average.
how does ml estimation work, intuitively?
the likelihood function l(θ|x) measures how “likely” it is that we will get xif
the underlying parameter is θ.
in the case of a gaussian with an unknown mean, you move around the gaussian
until you find a good fit.
8.1.3 application 1: social network analysis
ml estimation has extremely broad applicability. in this subsection and the next we discuss
two real examples. we start with an example in social network analysis.
in chapter 3, when we discussed the bernoulli random variables, we introduced the
erd˝ os-r´ enyi graph — one of the simplest models for social networks. the erd˝ os-r´ enyi graph
is a single-membership network that assumes that all users belong to the same cluster. thus
the connectivity between users is specified by a single parameter, which is also the probability
of the bernoulli random variable.
in our discussions in chapter 3 we defined an adjacency matrix to represent a graph.
the adjacency matrix is a binary matrix, with the ( i, j)th entry indicating an edge connect-
ing nodes iandj. since the presence and absence of an edge is binary and random, we may
model each element of the adjacency matrix as a bernoulli random variable
xij∼bernoulli( p).
in other words, the edge xijlinking user iand user jin the network is either xij= 1 with
probability p, orxij= 0 with probability 1 −p. in terms of notation, we define the matrix
x∈rn×nas the adjacency matrix, with the ( i, j)th element being xij.
a few examples of a single-membership erd˝ os-r´ enyi graph are shown in figure 8.9 . as
the figure shows, the network connectivity increases as the bernoulli parameter pincreases.
this happens because pdefines the “density” of the edges. if pis large, we have a greater
chance of getting xij= 1, and so there is a higher probability that an edge is present
between node iand node j. ifpis small, the probability is lower.
4788.1. maximum-likelihood estimation
-2 0 2-3-2-1012p = 0.3
  1
  2  3
  4
  5  6  7
  8  9  10
  11  12
  13
  14  15  16  17  18  19  20
  21  22  23  24
  25  26  27
  28  29
  30  31
  32  33
  34  35
  36
  37
  38  39
  40
-2 0 2-4-3-2-10123p = 0.5
  1
  2  3  4
  5  6  7
  8
  9
  10  11
  12  13  14  15
  16  17
  18   19  20
  21
  22
  23  24  25
  26  27  28
  29  30
  31  32  33
  34
  35
  36
  37  38
  39  40
-4 -2 0 2 4-4-3-2-10123p = 0.7
  1
  2
  3  4
  5  6
  7
  8  9  10
  11  12
  13  14
  15  16  17
  18
  19  20  21
  22  23
  24
  25  26  27  28
  29  30  31
  32  33
  34  35  36
  37  38  39
  40
-4 -2 0 2 4-4-2024p = 0.9
  1
  2  3
  4  5
  6  7
  8
  9  10
  11  12  13
  14  15
  16
  17  18
  19  20
  21  22
  23  24
  25
  26  27  28
  29
  30  31  32  33  34  35
  36
  37  38
  39  40
(a) graph representations of erd˝ os-r´ enyi graphs at different p.
(b) adjacent matrices of the corresponding graphs.
figure 8.9: a single-membership erd˝ os-r´ enyi graph is a graph structure in which the edge between
node iand node jis defined as a bernoulli random variable with parameter p. aspincreases, the graph
has a higher probability of having more edges. the adjacent matrices shown in the bottom row are the
mathematical representations of the graphs.
suppose that we are given onesnapshot of the network, i.e., one realization x∈rn×n
of the adjacency matrix x∈rn×n. the problem of recovering the latent parameter pcan
be formulated as an ml estimation.
example 8.5 . write down the log-likelihood function of the single-membership erd˝ os-
r´ enyi graph ml estimation problem.
solution . based on the definition of the graph model, we know that
xij∼bernoulli( p).
therefore, the probability mass function of xijis
p[xij= 1] = p and p[xij= 0] = 1 −p.
this can be compactly expressed as
fx(x;p) =ny
i=1ny
j=1pxij(1−p)1−xij.
hence, the log-likelihood is
logl(p|x) =nx
i=1nx
j=1{xijlogp+ (1−xij) log(1 −p)}.
479chapter 8. estimation
now that we have the log-likelihood function, we can proceed to estimate the param-
eterp. the solution to this is the ml estimate.
practice exercise 8.3 . solve the ml estimation problem:
bpml= argmax
plogl(p|x).
solution . using the log-likelihood we just derived, we have that
bpml=nx
i=1nx
j=1{xijlogp+ (1−xij) log(1 −p)}.
taking the derivative and setting it to zero,
d
dplogl(p|x) =d
dp

nx
i=1nx
j=1{xijlogp+ (1−xij) log(1 −p)}


=nx
i=1nx
j=1xij
p−1−xij
1−p
= 0.
lets=pn
i=1pn
j=1xij. the equation above then becomes
s
p−n2−s
1−p= 0.
rearranging the terms yields (1 −p)s=p(n2−s), which gives us
bpml=s
n2=1
n2nx
i=1nx
j=1xij. (8.9)
on computers, visualizing the graphs and computing the ml estimates are reasonably
straightforward. in matlab, you can call the command graph to build a graph from the
adjacency matrix a. this will allow you to plot the graph. the computation, however, is done
directly by the adjacency matrix. in the code below, you can see that we call rand to generate
the bernoulli random variables. the command triu extracts the upper triangular matrix
from the matrix a. this ensures that we do not pick the diagonals. the symmetrization of
a+a’ ensures that the graph is indirectional, meaning that itojis the same as jtoi.
% matlab code to visualize a graph
n = 40; # number of nodes
p = 0.3 # probability
a = rand(n,n)<p;
a = triu(a,1);
a = a+a’; # adj matrix
g = graph(a); # graph
4808.1. maximum-likelihood estimation
plot(g); # drawing
p_ml = mean(a(:)); # ml estimate
in python, the computation is done similarly with the help of the networkx library.
the number of edges mis defined as m=pn2
2. this is because for a graph with nnodes, there
are at mostn2
2unique pairs of indirected edges. multiplying this number by the probability
pwill give us the number of edges m.
# python code to visualize a graph
import networkx as nx
import numpy as np
n = 40 # number of nodes
p = 0.3 # probability
m = np.round(((n ** 2)/2)*p) # number of edges
g = nx.gnm_random_graph(n,m) # graph
a = nx.adjacency_matrix(g) # adj matrix
nx.draw(g) # drawing
p_ml = np.mean(a) # ml estimate
as you can see in both the matlab and the python code, the ml estimate bpmlis de-
termined by taking the sample average. thus the ml estimate, according to our calculation,
isbpml=1
n2pn
i=1pn
j=1xij.
8.1.4 application 2: reconstructing images
being able to see in the dark is the holy grail of imaging. many advanced sensing technologies
have been developed over the past decade. in this example, we consider a single-photon image
sensor. this is a counting device that counts the number of photons arriving at the sensor.
physicists have shown that a poisson process can model the arrival of the photons. for
simplicity we assume a homogeneous pattern of npixels. the underlying intensity of the
homogeneous pattern is a constant λ.
suppose that we have a sensor with npixels x1, . . . , x n. according to the poisson
statistics, the probability of observing a pixel value is determined by the poisson probability:
xn∼poisson( λ), n = 1, . . . , n,
or more explicitly,
p[xn=xn] =λxn
xn!e−λ,
where xnis the nth observed pixel value, and is an integer.
a single-photon image sensor is slightly more complicated in the sense that it does
not report xnbut instead reports a truncated version of xn. depending on the number of
incoming photons, the sensor reports
yn=(
1, x n≥1,
0, x n= 0.(8.10)
we call this type of sensors a one-bit single-photon image sensor (see figure 8.10 ). our
question is: if we are given the measurements x1, . . . , x n, can we estimate the underlying
parameter λ?
481chapter 8. estimation
figure 8.10: a one-bit single-photon image sensor captures an image with binary bits: it reports a “1”
when the number of photons exceeds certain threshold, and “0” otherwise. the recovery problem here
is to estimate the underlying image from the measurements.
example 8.6 . derive the log-likelihood function of the estimation problem for the
single-photon image sensors.
solution . since ynis a binary random variable, its probability is completely specified
by the two states it takes:
p[yn= 0] = p[xn= 0] = e−λ
p[yn= 1] = p[xn̸= 0] = 1 −e−λ.
thus, ynis a bernoulli random variable with probability 1 −e−λof getting a value
of 1, and probability e−λof getting a value of 0. by defining ynas a binary number
taking values of either 0 or 1, it follows that the log-likelihood is
logl(λ|y) = logny
n=1 
1−e−λyn 
e−λ1−yn
=nx
n=1
ynlog(1−e−λ)−λ(1−yn)
.
practice exercise 8.4 . solve the ml estimation problem
bλml= argmax
λlogl(λ|y). (8.11)
solution . first, we define s=pn
n=1yn. this simplifies the log-likelihood function to
logl(λ|y) =nx
n=1
ynlog(1−e−λ)−λ(1−yn)
=slog(1−e−λ)−λ(n−s).
4828.1. maximum-likelihood estimation
the ml estimation is
bλml= argmax
λslog(1−e−λ)−λ(n−s).
taking the derivative w.r.t. λyields
d
dλ
slog(1−e−λ)−λ(n−s)
=s
1−e−λe−λ−(n−s).
moving around the terms, it follows that
s
1−e−λe−λ−(n−s) = 0 = ⇒ λ=−log
1−s
n
.
therefore, the ml estimate is
bλml=−log 
1−1
nnx
n=1yn!
. (8.12)
for real images, you can extrapolate the idea from yntoyi,j,t, which denotes the ( i, j)th
pixel located at time t. defining yt∈rn×nas the tth frame of the observed data, we can
usetframes to recover one image bλml∈rn×n. it follows from the above derivation that
the ml estimate is
bλml=−log 
1−1
ttx
t=1yt!
. (8.13)
figure 8.11 shows a pair of input-output images of a 256 ×256 image.
(a) observed data (1-frame) (b) ml estimate (using 100 frames)
figure 8.11: ml estimation for a single-photon image sensor problem. the observed data consists of
100 frames of binary measurements y1, . . . ,yt, where t= 100 . the ml estimate is constructed by
λ=−log(1−1
tpt
t=1yt).
on a computer the ml estimation can be done in a few lines of matlab code. the
code in python requires more work, as it needs to read images using the opencv library.
483chapter 8. estimation
% matlab code to recover an image from binary measurements
lambda = im2double(imread(’cameraman.tif’));
t = 100; % 100 frames
x = poissrnd( repmat(lambda, [1,1,t]) ); % generate poisson r.v.
y = (x>=1); % binary truncation
lambdahat = -log(1-mean(y,3)); % ml estimation
figure(1); imshow(x(:,:,1));
figure(2); imshow(lambdahat);
# python code to recover an image from binary measurements
import cv2
import numpy as np
import scipy.stats as stats
import matplotlib.pyplot as plt
lambd = cv2.imread(’./cameraman.tif’) # read image
lambd = cv2.cvtcolor(lambd, cv2.color_bgr2gray)/255 # gray scale
t = 100
lambdt = np.repeat(lambd[:, :, np.newaxis], t, axis=2) # repeat image
x = stats.poisson.rvs(lambdt) # poisson statistics
y = (x>=1).astype(float) # binary truncation
lambdhat = -np.log(1-np.mean(y,axis=2)) # ml estimation
plt.imshow(lambdhat,cmap=’gray’)
8.1.5 more examples of ml estimation
by now you should be familiar with the procedure for solving the ml estimation problem.
we summarize the two steps as follows.
how to solve an ml estimation problem
write down the likelihood l(θ|x).
maximize the likelihood by solving bθml= argmax
θlogl(θ|x).
practice exercise 8.5 (gaussian ). suppose that we are given a set of i.i.d. gaus-
sian random variables x1, . . . , x n, where both the mean µand the variance σ2are
unknown. let θ= [µ, σ2]tbe the parameter. find the ml estimate of θ.
solution . we first write down the likelihood. the likelihood of these i.i.d. gaussian
random variables is
l(θ|x) =1√
2πσ2n
exp(
−1
2σ2nx
n=1(xn−µ)2)
.
4848.1. maximum-likelihood estimation
to solve the ml estimation problem, we maximize the log-likelihood:
bθmldef= argmax
θl(θ|x)
= argmax
µ,σ2(
−n
2log(2πσ2)−1
2σ2nx
n=1(xn−µ)2)
.
since we have two parameters, we need to take the derivatives for both.
d
dµ(
−n
2log(2πσ2)−1
2σ2nx
n=1(xn−µ)2)
= 0,
d
dσ2(
−n
2log(2πσ2)−1
2σ2nx
n=1(xn−µ)2)
= 0.
(note that the derivative of the second equation is taken w.r.t. to σ2and not σ.) this
pair of equations gives us
1
σ2nx
n=1(xn−µ) = 0 ,and−n
2·1
2πσ2·(2π) +1
2σ4nx
n=1(xn−µ)2= 0.
rearranging the equations, we find that
bµml=1
nnx
n=1xn and bσ2
ml=1
nnx
n=1(xn−bµml)2. (8.14)
practice exercise 8.6 . (poisson ) given a set of i.i.d. poisson random variables
x1, . . . , x nwith an unknown parameter λ, find the ml estimate of λ.
solution . for a poisson random variable, the likelihood function is
l(λ|x) =ny
n=1λxn
xn!e−λ
. (8.15)
to solve the ml estimation problem, we note that
bλml= argmax
λl(λ|x) = argmax
λlog(ny
n=1λxn
xn!e−λ)
= argmax
λlogλp
nxn
q
nxn!e−nλ
.
sinceq
nxn! is independent of λ, its presence or absence will not affect the optimization
485chapter 8. estimation
problem. consequently we can drop the term. it follows that
bλml= argmax
λlogn
λp
nxne−nλo
= argmax
λ x
nxn!
logλ−nλ.
taking the derivative and setting it to zero yields
d
dλ( x
nxn!
logλ−nλ)
=p
nxn
λ−n= 0.
rearranging the terms yields
bλml=1
nnx
n=1xn. (8.16)
the idea of ml estimation can also be extended to vector observations.
example 8.7 . (high-dimensional gaussian ) suppose that we are given a set of i.i.d.
d-dimensional gaussian random vectors x1, . . . ,xnsuch that
xn∼gaussian( µ,σ).
we assume that σis fixed and known, but µis unknown. find the ml estimate of µ.
solution . the likelihood function is
l(µ|{xn}n
n=1) =ny
n=1fxn(xn;µ)
=ny
n=1(
1p
(2π)d|σ|exp
−1
2(xn−µ)tς−1(xn−µ))
= 
1p
(2π)d|σ|!n
exp(
−1
2nx
n=1(xn−µ)tς−1(xn−µ))
.
thus the log-likelihood function is
logl(µ|{xn}n
n=1) =n
2log|σ|+n
2log(2π)d+nx
n=11
2(xn−µ)tς−1(xn−µ)
.
the ml estimate is found by maximizing this log-likelihood function:
bµml= argmax
µlogl(µ|{xn}n
n=1).
4868.1. maximum-likelihood estimation
taking the gradient of the function and setting it to zero, we have that
d
dµ(
n
2log|σ|+n
2log(2π)d+nx
n=11
2(xn−µ)tς−1(xn−µ))
= 0.
the derivatives of the first two terms are zero because they do not depend on µ). thus
we have that:
nx
n=1
σ−1(xn−µ)
= 0.
rearranging the terms yields the ml estimate bµml=1
npn
n=1xn.
example 8.8 . (high-dimensional gaussian ) assume the same problem setting as in
example 8.7, except that this time we assume that both the mean vector µand the
covariance matrix σare unknown. find the ml estimate for θ= (µ,σ).
solution . the log-likelihood follows from example 8.7:
logl(µ|{xn}n
n=1) =n
2log|σ|+n
2log(2π)d+nx
n=11
2(xn−µ)tς−1(xn−µ)
.
finding the ml estimate requires taking the derivative with respect to both µandς:
d
dµ(
n
2log|σ|+n
2log(2π)d+nx
n=11
2(xn−µ)tς−1(xn−µ))
= 0,
d
dς(
n
2log|σ|+n
2log(2π)d+nx
n=11
2(xn−µ)tς−1(xn−µ))
= 0.
after some tedious algebraic steps (see duda et al., pattern classification , problem
3.14), we have that
bµml=1
nnx
n=1xn, (8.17)
bσml=1
nnx
n=1(xn−bµml)(xn−bµml)t. (8.18)
8.1.6 regression versus ml estimation
ml estimation is closely related to regression. to understand the connection, we consider a
linear model that we studied in chapter 7. this model describes the relationship between
487chapter 8. estimation
the inputs x1, . . . ,xnand the observed outputs y1, . . . , y n, via the equation
yn=d−1x
p=0θpϕp(xn) +en, n = 1, . . . , n. (8.19)
in this expression, ϕp(·) is a transformation that extracts the “features” of the input vector
xto produce a scalar. the coefficient θpdefines the relative weight of the feature ϕp(xn) in
constructing the observed variable yn. the error endefines the modeling error between the
observation ynand the predictionpd−1
p=0θpϕp(xn). we call this equation a linear model.
expressed in matrix form, the linear model is

y1
y2
...
yn

|{z}
=y=
ϕ0(x1)ϕ1(x1)··· ϕd−1(x1)
ϕ0(x2)ϕ1(x2)··· ϕd−1(x2)
... ···......
ϕ0(xn)ϕ1(xn)···ϕd−1(xn)

| {z }
=x
θ0
θ1
...
θd−1

|{z}
=θ+
e1
e2
...
en

|{z}
=e,
or more compactly as y=xθ+e. rearranging the terms, it is easy to show that
nx
n=1e2
n=nx
n=1 
yn−d−1x
p=0θpϕp(xn)!2
=nx
n=1(yn−[xθ]n)2=∥y−xθ∥2.
now we make an assumption : that each noise enis an i.i.d. copy of a gaussian random
variable with zero mean and variance σ2. in other words, the error vector eis distributed
according to e∼gaussian( 0, σ2i). this assumption is not always true because there are
many situations in which the error is not gaussian. however, this assumption is necessary
for us to make the connection between ml estimation and regression.
with this assumption, we ask, given the observations y1, . . . , y n, what would be the
ml estimate of the unknown parameter θ? we answer this question in two steps.
example 8.9 . find the likelihood function of θ, given y= [y1, . . . , y n]t.
solution . the pdf of yis given by a gaussian:
fy(y;θ) =ny
n=11√
2πσ2exp
−(yn−[xθ]n)2
2σ2
=1p
(2πσ2)nexp(
−1
2σ2nx
n=1(yn−[xθ]n)2)
=1p
(2πσ2)nexp
−1
2σ2∥y−xθ∥2
. (8.20)
4888.1. maximum-likelihood estimation
therefore, the log-likelihood function is
logl(θ|y) = log(
1p
(2πσ2)nexp
−1
2σ2∥y−xθ∥2)
=−n
2log(2πσ2)−1
2σ2∥y−xθ∥2.
the next step is to solve the ml estimation by maximizing the log-likelihood.
example 8.10 . solve the ml estimation problem stated in example 8.9. assume that
xtxis invertible.
solution .
bθml= argmax
θlogl(θ|y)
= argmax
θ
−n
2log(2πσ2)−1
2σ2∥y−xθ∥2
.
taking the derivative w.r.t. θyields
d
dθ
−n
2log(2πσ2)−1
2σ2∥y−xθ∥2
= 0.
sinced
dθθtaθ=a+at, it follows from the chain rule that
d
dθ
−1
2σ2∥y−xθ∥2
=d
dθ
−1
2σ2(y−xθ)t(y−xθ)
=1
σ2xt(xθ−y).
substituting this result into the equation,
1
σ2xt(xθ−y) = 0 .
rearranging terms we obtain xtxθ=xty, of which the solution is
bθml= (xtx)−1xty. (8.21)
since the ml estimate in equation (8.21) is the same as the regression solution (see
chapter 7), we conclude that the regression problem of a linear model is equivalent to solving
an ml estimation problem.
the main difference between a linear regression problem and an ml estimation problem
is the underlying statistical model, as illustrated in figure 8.12 . in linear regression, you
do not care about the statistics of the noise term en. we choose ( ·)2as the error because it
is differentiable and convenient. in ml estimation, we choose ( ·)2as the error because the
noise is gaussian. if the noise is not gaussian, e.g., the noise follows a laplace distribution,
we need to choose | · |as the error. therefore, you can always get a result by solving the
linear regression. however, this result will only become meaningful if you provide additional
489chapter 8. estimation
figure 8.12: ml estimation is equivalent to a linear regression when the underlying statistical model
for ml estimation is a gaussian. specifically, if the error term e=y−xθis an independent gaussian
vector with zero mean and covariance matrix σ2i, then the resulting ml estimation is the same as linear
regression. if the underlying statistical model is not gaussian, then solving the regression is equivalent
to applying a gaussian ml estimation to a non-gaussian problem. this will still give us a result, but
that result will not maximize the likelihood, and thus it will not have any statistical guarantee.
information about the problem. for example, if you know that the noise is gaussian, then
the regression solution is also the ml solution. this is a statistical guarantee.
in practice, of course, we do not know whether the noise is gaussian or not. at this
point we have two courses of action: (i) use your prior knowledge/domain expertise to
determine whether a gaussian assumption makes sense, or (ii) select an alternative model
and see if the alternative model fits the data better. in practice, we should also question
whether maximizing the likelihood is what we want. we may have some knowledge and
therefore prefer the parameter θ, e.g., we want a sparse solution so that θonly contains a
few non-zeros. in that case, maximizing the likelihood without any constraint may not be
the solution we want.
ml estimation versus regression
ml estimation requires a statistical assumption, whereas regression does not.
suppose that you use a linear model yn=pd−1
p=0θpϕp(xn) +enwhere en∼
gaussian(0 , σ2), for n= 1, . . . , n .
then the likelihood function in the ml estimation is
l(θ|y) =1p
(2πσ2)nexp
−1
2σ2∥y−xθ∥2
,
the ml estimate bθmlisbθml= (xtx)−1xty, which is exactly the same as
the regression solution. if the above statistical assumptions do not hold, then the
regression solution will not maximize the likelihood.
4908.2. properties of ml estimates
8.2 properties of ml estimates
ml estimation is a very special type of estimation. not all estimations are ml. if an estimate
is ml, are there any theoretical properties we can analyze? for example, will ml estimates
guarantee the recovery of the true parameter? if so, when will this happen? in this section
we investigate these theoretical questions so that you will acquire a better understanding of
the statistical nature of ml estimates.2
8.2.1 estimators
we know that an ml estimate is defined as
bθml(x) = argmax
θl(θ|x). (8.22)
we write bθml(x) to emphasize that bθmlis a function of x. the dependency of bθml(x) on
xshould not be a surprise. for example, if the ml estimate is the sample average, we have
that
bθml(x1, . . . , x n) =1
nnx
n=1xn,
where x= [x1, . . . , x n]t.
however, in this setting we should always remember that x1, . . . , x nare realizations
of the i.i.d. random variables x1, . . . , x n. therefore, if we want to analzye the randomness
of the variables, it is more reasonable to write bθmlas a random variable bθml. for example,
in the case of sample average, we have that
bθml(x1, . . . , x n) =1
nnx
n=1xn. (8.23)
we call bθmlthe ml estimator of the true parameter θ.
estimate versus estimator
anestimate is anumber , e.g.,bθml=1
nnx
n=1xn. it is the random realization of
a random variable.
anestimator is arandom variable , e.g., bθml=1
nnx
n=1xn. it takes a set of
random variables and generates another random variable.
2for notational simplicity, in this section we will focus on a scalar parameter θinstead of a vector
parameter θ.
491chapter 8. estimation
the ml estimators are one type of estimator, namely those that maximize the likeli-
hood functions. if we do not want to maximize the likelihood we can still define an estimator.
an estimator is any function that takes the data points x1, . . . , x nand maps them to a
number (or a vector of numbers). that is, an estimator is
bθ(x1, . . . , x n).
we call bθ the estimator of the true parameter θ.
example 8.11 . let x1, . . . , x nbe gaussian i.i.d. random variables with unknown
mean θand known variance σ2. construct two possible estimators.
solution . we define two estimators:
bθ1(x1, . . . , x n) =1
nnx
n=1xn,
bθ2(x1, . . . , x n) =x1,
in the first case, the estimator takes all the samples and constructs the sample average.
the second estimator takes all the samples and returns on the first element. both are
legitimate estimators. however, bθ1is the ml estimator, whereas bθ2is not.
8.2.2 unbiased estimators
while you can define estimators in any way you like, certain estimators are good and others
are bad. by “good” we mean that the estimator can provide you with the information about
the true parameter θ; otherwise, why would you even construct such an estimator? however,
the difficulty here is that bθ is a random variable because it is constructed from x1, . . . , x n.
therefore, we need to define different metrics to quantify the usefulness of the estimators.
definition 8.5. an estimator bθisunbiased if
e[bθ] = θ. (8.24)
unbiasedness means that the average of the random variable bθ matches the true
parameter θ. in other words, while we allow bθ to fluctuate, we expect the average to match
the true θ. if this is not the case, using more measurements will not help us get closer to θ.
example 8.12 . let x1, . . . , x nbe i.i.d. gaussian random variables with a unknown
mean θ. it has been shown that the ml estimator is
bθml=1
nnx
n=1xn. (8.25)
is the ml estimator bθmlunbiased?
4928.2. properties of ml estimates
solution : to check the unbiasedness, we look at the expectation:
e[bθml] =1
nnx
n=1e[xn] =1
nnx
n=1θ=θ.
thus,bθml=1
npn
n=1xnis an unbiased estimator of θ.
example 8.13 . same as the example before, but this time we consider an estimator
bθ =x1+x2+ 5. (8.26)
is this estimator unbiased?
solution : in this case,
e[bθ] =e[x1+x2+ 5] = e[x1] +e[x2] + 5 = 2 θ+ 5̸=θ.
therefore, the estimator is biased.
example 8.14 . let x1, . . . , x nbe i.i.d. gaussian random variables with unknown
mean µand unknown variance σ2. we have shown that the ml estimators are
bµml=1
nnx
n=1xn and bσ2
ml=1
nnx
n=1(xn−bµml)2.
it is easy to show that e[bµml] =µ. how about bσ2
ml? is it an unbiased estimator?
solution : for simplicity we assume µ= 0 so that e[x2
n] =e[(xn−0)2] =σ2.
note that
e[bσ2
ml] =1
nnx
n=1
e[x2
n]−2e[bµmlxn] +e[bµ2
ml]
=1
nnx
n=1

σ2−2e
1
nnx
j=1xjxn
+e
 
1
nnx
n=1xn!2


.
by independence, we observe that e[xjxn] =e[xj]e[xn] = 0, for any j̸=n. there-
fore,
e
1
nnx
j=1xjxn
=1
ne
x1xn+···+xnxn
=1
n(0 +···+σ2+···+ 0) =σ2
n.
493chapter 8. estimation
similarly, we have that
e
 
1
nnx
n=1xn!2
=1
n2nx
n=1

e[x2
n] +x
j̸=ne[xjxn]


=1
n2nx
n=1n
σ2+ 0o
=σ2
n.
combining everything, we arrive at the result:
e[bσ2
ml] =1
nnx
n=1

σ2−2e
1
nnx
j=1xjxn
+e
 
1
nnx
n=1xn!2



=1
nnx
n=1
σ2−2σ2
n+σ2
n
=n−1
nσ2,
which is not equal to σ2. therefore, bσ2
mlis a biased estimator of σ2.
in the previous example, it is possible to construct an unbiased estimator for the
variance. to do so, we can use
bσ2
unbias =1
n−1nx
n=1(xn−bµml)2, (8.27)
so that e[bσ2
unbias ] =σ2. however, note that bσ2
unbias does not maximize the likelihood, so while
you can get unbiasedness, you cannot maximize the likelihood. if you want to maximize the
likelihood, you cannot get unbiasedness.
what is an unbiased estimator?
an estimator bθ is unbiased if e[bθ] = θ.
unbiased means that the statistical average of bθ is the true parameter θ.
ifxn∼gaussian( θ, σ2), then bθ = (1 /n)pn
n=1xnis unbiased, but bθ = x1is
biased.
8.2.3 consistent estimators
by definition, an estimator bθ(x1, . . . , x n) is a function of nrandom variables x1, . . . , x n.
therefore, bθ(x1, . . . , x n) changes as ngrows. in this subsection we analyze how bθ behaves
when nchanges. for notational simplicity we use the following notation:
bθn=bθ(x1, . . . , x n). (8.28)
thus, as nincreases, we use more random variables in defining bθ(x1, . . . , x n).
4948.2. properties of ml estimates
definition 8.6. an estimator bθnisconsistent ifbθnp−→θ, i.e.,
lim
n→∞pbθn−θ≥ϵ
= 0. (8.29)
the definition here follows from our discussions of the law of large numbers in chapter 6.
the specific type of convergence is known as the convergence in probability . it says that
asngrows, the estimator bθ will be close enough to θso that the probability of getting a
large deviation will diminish, as illustrated in figure 8.13 .
-5 -4 -3 -2 -1 0 1 2 3 4 500.20.40.60.811.2
-5 -4 -3 -2 -1 0 1 2 3 4 500.20.40.60.811.2
(a)n= 1 (b) n= 2
-5 -4 -3 -2 -1 0 1 2 3 4 500.20.40.60.811.2
-5 -4 -3 -2 -1 0 1 2 3 4 500.20.40.60.811.2
(c)n= 4 (d) n= 8
figure 8.13: the four subfigures here illustrate the probability of error p
|bθn−θ| ≥ϵ
, which is
represented by the areas shaded in blue. we assume that the estimator bθnis a gaussian random
variable following a distribution gaussian (0,σ2
n), where we set σ= 1. the threshold we use in this
figure is ϵ= 1. asngrows, we see that the probability of error diminishes. if the probability of error
goes to zero, we say that the estimator is consistent .
the examples in figure 8.13 are typical situations for an estimator based on the
sample average. for example, if we assume that x1, . . . , x nare i.i.d. gaussian copies of
gaussian(0 , σ2), then the estimator
bθ(x1, . . . , x n) =1
nnx
n=1xn
will follow a gaussian distribution gaussian(0 ,σ2
n). (please refer to chapter 6 for the deriva-
tion.) then, as ngrows, the pdf of bθnbecomes narrower and narrower. for a fixed ϵ, it
follows that the probability of error will diminish to zero. in fact, we can prove that, for this
495chapter 8. estimation
example,
pbθn−θ≥ϵ
=p
bθn−θ≥ϵ
+p
bθn−θ≤ −ϵ
=z∞
θ+ϵgaussian
zθ,σ2
n
dz+zθ−ϵ
−∞gaussian
zθ,σ2
n
dz
=z∞
θ+ϵ1p
2πσ2/ne−(z−θ)2
2σ2/ndz+zθ−ϵ
−∞1p
2πσ2/ne−(z−θ)2
2σ2/ndz
=z∞
ϵ
σ/√
n1√
2πe−z2
2dz+z−ϵ
σ/√
n
−∞1√
2πe−z2
2dz
= 1−φϵ
σ/√
n
+ φ−ϵ
σ/√
n
= 2φ−ϵ
σ/√
n
.
therefore, as n→ ∞ , it holds that−ϵ
σ/√
n→ −∞ . hence,
lim
n→∞pbθn−θ≥ϵ
= lim
n→∞2φ−ϵ
σ/√
n
= 0.
this explains why in figure 8.13 the probability of error diminishes to zero as ngrows.
therefore, we say that bθnisconsistent .
in general, there are two ways to check whether an estimator is consistent:
prove convergence in probability . this is based on the definition of a consistent
estimator. if we can prove that
lim
n→∞p
|bθn−θ| ≥ϵ
= 0, (8.30)
then we say that the estimator is consistent.
prove convergence in mean squared error :
lim
n→∞e[(bθn−θ)2] = 0. (8.31)
to see why convergence in the mean squared error is sufficient to guarantee consistency,
we recall chebyshev’s inequality in chapter 6, which says that
p
|bθn−θ| ≥ϵ
≤e[(bθn−θ)2]
ϵ2.
thus, if lim n→∞e[(bθn−θ)2] = 0, convergence in probability will also hold. how-
ever, since mean square convergence is stronger than convergence in probability, being
unable to show mean square convergence does not imply that an estimator is incon-
sistent.
be careful not to confuse a consistent estimator and an unbiased estimator. the two
are different concepts; one does not imply the other.
4968.2. properties of ml estimates
consistent versus unbiased
consistent = if you have enough samples, then the estimator bθ will converge to
the true parameter.
unbiasedness does not imply consistency. for example (gaussian), if
bθ =x1,
thene[x1] =µ. butp[|bθ−µ|> ϵ] does not converge to 0 as ngrows. so this
estimator is inconsistent. (see example 8.16 below.)
consistency does not imply unbiasedness. for example (gaussian), if
bθ =1
nnx
n=1(xn−µ)2
is a biased estimate for variance, but it is consistent. (see example 8.17 below.)
example 8.15 . let x1, . . . , x nbe i.i.d. gaussian random variables with an unknown
mean µand known variance σ2. we know that the ml estimator for the mean is
bµml= (1/n)pn
n=1xn. isbµmlconsistent?
solution . we have shown that the ml estimator is
bµml=1
nnx
n=1xn.
sincee[bµml] =µ, ande[(bµml−µ)2] = var[ bµml] =σ2
n, it follows that
p
|bµml−µ| ≥ϵ
≤e[(bµml−µ)2]
ϵ2=σ2
nϵ2.
thus, when ngoes to infinity, the probability converges to zero, and hence the esti-
mator is consistent.
example 8.16 . let x1, . . . , x nbe i.i.d. gaussian random variables with an unknown
mean µand known variance σ2. define an estimator bµ=x1. show that the estimator
is unbiased but inconsistent.
solution . we know that e[bµ] =e[x1] =µ. sobµis an unbiased estimator. however,
we can show that
e[(bµ−µ)2] =e[(x1−µ)2] =σ2.
since this variance e[(bµ−µ)2] does not shrink as nincreases, it follows that no matter
497chapter 8. estimation
how many samples we use we cannot make e[(bµ−µ)2] go to zero. to be more precise,
p
|bµ−µ| ≥ϵ
=p
|x1−µ| ≥ϵ
=p
x1≤µ−ϵ
+p
x1≥µ+ϵ
=zµ−ϵ
−∞1√
2πσ2e−(x−µ)2
2σ2dx+z∞
µ+ϵ1√
2πσ2e−(x−µ)2
2σ2dx
= 2φ−ϵ
σ
,
which does not converge to zero as n→ ∞ . so the estimator is inconsistent.
example 8.17 . let x1, . . . , x nbe i.i.d. gaussian random variables with an unknown
mean µand an unknown variance σ2. is the ml estimate of the variance, i.e., bσ2
ml,
consistent?
solution . we know that the ml estimator for the mean is
bµml=1
nnx
n=1xn,
and we have shown that it is an unbiased and consistent estimator of the mean. for
the variance,
bσ2
ml=1
nnx
n=1(xn−bµml)2=1
nnx
n=1
x2
n−2bµmlxn+bµ2
ml
=1
nnx
n=1x2
n−2bµml·1
nnx
n=1xn+bµ2
ml
=1
nnx
n=1x2
n−bµ2
ml.
note that1
npn
n=1x2
nis the sample average of the second moment, and so by the
weak law of large numbers it should converge in probability to e[x2
n]. similarly, bµml
will converge in probability to µ. therefore, we have
bσ2
ml=1
nnx
n=1x2
n−bµ2
mlp−→(σ2+µ2)−µ2=σ2.
thus, we have shown that the ml estimator of the variance is biased but consistent.
4988.2. properties of ml estimates
the following discussions about the consistency of ml estimators can be skipped.
as we have said, there are many estimators. some estimators are consistent and some
are not. the ml estimators are special. it turns out that under certain regularity conditions
the ml estimators of i.i.d. observations are consistent.
without proving this result formally, we highlight a few steps to illustrate the idea.
suppose that we have a set of i.i.d. data points x1, . . . ,xndrawn from some distribution
f(x,|θtrue). to formulate the ml estimation, we consider the log-likelihood function (di-
vided by n):
1
nlogl(θ|x) =1
nnx
n=1logf(xn;θ). (8.32)
here, the variable θis unknown. we need to find it by maximizing the log-likelihood.
by the weak law of large numbers, we can show that the log-likelihood based on the
nsamples will converge in probability to
1
nnx
n=1logf(xn;θ)
| {z }
gn(θ)p−→e[logf(x;θ)]. (8.33)
the expectation can be evaluated by integrating over the true distribution:
e[logf(x;θ)] =z
logf(x;θ)·f(x;θtrue)dx
| {z }
g(θ).
where f(x;θtrue) denotes the true distribution of the samples xn’s. from these two results
we define two functions:
gn(θ)def=1
nnx
n=1logf(xn;θ),andg(θ)def=z
logf(x;θ)·f(x;θtrue)dx,
and we know that gn(θ)p−→g(θ).
we also know that bθmlis the ml estimator, and so
bθml= argmax
θgn(θ).
letθ∗be the maximizer of the limiting function, i.e.,
θ∗= argmax
θg(θ).
because gn(θ)p→g(θ), we can (loosely3) argue that bθmlp→θ∗. if we can show that
θ∗=θtrue, then we have shown that bθmlp→θtrue, implying that bθmlis consistent.
3to rigorously prove this statement we need some kind of regularity conditions on gnandg. a more
formal proof can be found in h. vincent poor, an introduction signal detection and estimation , springer,
1998, section iv.d.
499chapter 8. estimation
to show that θ∗=θtrue, we note that
d
dθz
logf(x;θ)·f(x;θtrue)dx=zd
dθlogf(x;θ)·f(x;θtrue)dx
=zf′(x;θ)
f(x;θ)·f(x;θtrue)dx.
we ask whether this is equal to zero. putting θ=θtrue, we have that
zf′(x;θtrue)
f(x;θtrue)·f(x;θtrue)dx=z
f′(x;θtrue)dx.
however, this integral can be simplified to
z
f′(x;θtrue)dx=d
dθz
f(x;θ)dx
|{z}
=1
θ=θtrue= 0.
therefore, θtrueis the maximizer for g(θ), and so θtrue=θ∗.
end of the discussion. please join us again.
8.2.4 invariance principle
another useful property satisfied by the ml estimate is the invariance principle . the in-
variance principle says that a monotonic transformation of the true parameter is preserved
for the ml estimates.
what is the invariance principle?
there is a monotonic function h.
there is an ml estimate bθmlforθ.
the monotonic function hmaps the true parameter θ7−→h(θ).
then the same function will map the ml estimate bθml7−→h(bθml).
the formal statement of the invariance principle is given by the theorem below.
theorem 8.1. ifbθmlis the ml estimate of θ, then for any one-to-one function h
ofθ, the ml estimate of h(θ)ish(bθml).
proof . define the likelihood function l(θ) (we have dropped xto simplify the notation).
then, for any monotonic function h, we have that
l(θ) =l(h−1(h(θ))).
5008.2. properties of ml estimates
letbθmlbe the ml estimate:
bθml= argmax
θl(θ) = argmax
θl(h−1(h(θ))).
by the definition of ml, bθmlmust maximize the likelihood. therefore, l(h−1(h(θ))) is
maximized when h−1(h(θ)) =bθml. this implies that h(θ) =h(bθml) because his monotonic.
since h(θ) is the parameter we try to estimate, the equality h(θ) =h(bθml) implies that
h(bθml) is the ml estimate of h(θ). □
example 8.18 . consider the single-photon image sensor example we discussed in
section 8.1. we consider a set of i.i.d. bernoulli random variables with pmf
pxn(1) = 1 −e−ηand pxn(0) = e−η. (8.34)
find the ml estimate through (a) direct calculation and (b) the invariance principle.
solution . (a) following the example in equation (8.12), the ml estimate of ηis
bηml= argmax
ηny
n=1(1−e−η)xn(e−η)1−xn=−log 
1−1
nnx
n=1xn!
.
(b) we can obtain the same result using the invariance principle. since xnis a
binary random variable, we assume that it is a bernoulli with parameter θ. then the
ml estimate of θis
bθml= argmax
θny
n=1θxn(1−θ)1−xn
=1
nnx
n=1xn.
the relationship between θandηis that θ= 1−e−η, orη=−log(1−θ). so we let
h(θ) =−log(1−θ). the invariance principle says that the ml estimate of h(θ) is
bηmldef=dh(θ)ml(i)=h(bθml)
=−log 
1−1
nnx
n=1xn!
,
where (i) follows from the invariance principle.
the invariance principle can be very convenient, especially when the transformation his
complicated, so that a direct evaluation of the ml estimate is difficult.
the invariance principle is portrayed in figure 8.14 . we start with the bernoulli log-
likelihood
logl(θ|s) =slogθ+ (1−s) log(1 −θ).
501chapter 8. estimation
figure 8.14: the invariance principle is a transformation of the ml estimate. in this example, we
consider a bernoulli log-likelihood function shown in the lowermost plot. for this log-likelihood, the ml
estimate is bθml= 0.4. on the left-hand side we show another log-likelihood, derived for a truncated
poisson random variable. note that the ml estimate is bηml= 0.5108. the invariance principle asserts
that, instead of computing these ml estimates directly, we can first derive the relationship between η
andθfor any θ. since we know that θ= 1−e−η, it follows that η=−log(1−θ). we define this
transformation as η=h(θ) =−log(1−θ). then the ml estimate is bηml=h(bθml) =h(0.4) = 0 .5108.
the invariance principle saves us the trouble of computing the maximization of the more truncated
poisson likelihood.
in this particular example we let s= 20, where sdenotes the sum of the n= 50 bernoulli
random variables. the other log-likelihood is the truncated poisson, which is given by
logl(η|s) =slog(1−e−η) + (1 −s) log( e−η).
the transformation between the two is the function η=h(θ) =−log(1−θ). putting
everything into the figure, we see that the ml estimate ( θ= 0.4) is translated to η= 0.5108.
the invariance principle asserts that this calculation can be done by bηml=h(bθml) =
h(0.4) =−0.5108.
8.3 maximum a posteriori estimation
in ml estimation, the parameter θis treated as a deterministic quantity. there are, however,
many situations where we have some prior knowledge about θ. for example, we may not
know exactly the speed of a car, but we may know that the speed is roughly 65 mph
5028.3. maximum a posteriori estimation
with a standard deviation of 5 mph. how do we incorporate such prior knowledge into the
estimation problem?
in this section, we introduce the second estimation technique, known as the maximum
a posteriori (map) estimation. map estimation links the likelihood and the prior. the key
idea is to treat the parameter θas a random variable (vector) θwith a pdf fθ(θ).
8.3.1 the trio of likelihood, prior, and posterior
to understand how the map estimation works, it is important first to understand the role
of the parameter θ, which changes from a deterministic quantity to a random quantity.
recall the likelihood function we defined in the ml estimation; it is
l(θ|x) =fx(x;θ),
if we assume that we have a set of i.i.d. observations x= [x1, . . . , x n]t. by writing the pdf
ofxasfx(x;θ), we emphasize that θis a deterministic but unknown parameter. there
is nothing random about θ.
in map, we change the nature of θfrom deterministic to random. we replace θbyθ
and write
fx(x;θ)becomes=⇒ fx|θ(x|θ). (8.35)
the difference between the left-hand side and the right-hand side is subtle but important.
on the left-hand side, fx(x;θ) is the pdf of x. this pdf is parameterized by θ. on the
right-hand side, fx|θ(x|θ) is a conditional pdf of xgiven θ. the values they provide
are exactly the same. however, in fx|θ(x|θ),θis a realization of a random variable θ.
because θis now a random variable (vector), we can define its pdf (yes, the pdf
ofθ), and denote it by
fθ(θ), (8.36)
which is called the prior distribution. the prior distribution of θis unique in map estima-
tion. there is nothing called a prior in ml estimation.
multiplying fx|θ(x|θ) with the prior pdf fθ(θ), and using bayes’ theorem, we
obtain the posterior distribution:
fθ|x(θ|x) =fx|θ(x|θ)fθ(θ)
fx(x). (8.37)
the posterior distribution is the pdf of θgiven the measurements x.
the likelihood, the prior, and the posterior can be confusing. let us clarify their mean-
ings.
likelihood fx|θ(x|θ): this is the conditional probability density of xgiven the pa-
rameter θ. do not confuse the likelihood fx|θ(x|θ) defined in the map context
and the likelihood fx(x;|θ) defined in the ml context. the former assumes that θ
is random whereas the latter assumes that θis deterministic. they have the same
values.
prior fθ(θ): this is the prior distribution of θ. it does not come from the data x
but from our prior knowledge. for example, if we see a bike on the road, even before
we take any measurement we will have a rough idea of its speed. this is the prior
distribution.
503chapter 8. estimation
posterior fθ|x(θ|x): this is the posterior density of θgiven that we have observed x.
do not confuse fθ|x(θ|x) andl(θ|x). the posterior distribution fθ|x(θ|x) is a pdf
ofθgiven x=x. the likelihood l(θ|x) is not a pdf. if you integrate fθ|x(θ|x)
with respect to θ, you get 1, but if you integrate l(θ|x) with respect to θ, you do
not get 1.
what is the difference between ml and map?
likelihood ml fx(x;θ) the parameter θis deterministic.
map fx|θ(x|θ) the parameter θis random.
prior ml there is no prior, because θis deterministic.
map fθ(θ) this is the pdf of θ.
optimization ml find the peak of the likelihood fx(x;θ).
map find the peak of the posterior fθ|x(θ|x).
maximum a posteriori (map) estimation is a form of bayesian estimation. bayesian
methods emphasize our prior knowledge or beliefs about the parameters. as we will see
shortly, the prior has something valuable to offer, especially when we have very few data
points.
8.3.2 understanding the priors
since the biggest difference between map and ml is the addition of the prior fθ(θ), we
need to take a closer look at what they mean. in figure 8.15 below, we show a set of six
different priors. we ask two questions: (1) what do they mean? (2) which one should we
use?
figure 8.15: this figure illustrates six different examples of the prior distribution fθ(θ), when the prior
is a 1d parameter θ. the prior distribution fθ(θ)is the pdf of θ. (a) fθ(θ) =δ(θ), which is a delta
function. (b) fθ(θ) =1
b−afora≤θ≤b. this is a uniform distribution. (c) this is also a uniform
distribution, but the spread is very wide. (d) fθ(θ) =gaussian (0, σ2), which is a zero-mean gaussian.
(e) the same gaussian, but with a different mean. (f) a gaussian with zero mean, but a large variance.
5048.3. maximum a posteriori estimation
what does the shape of a prior tell us?
it tells us your belief as to how the underlying parameter θshould be distributed.
the meaning of this statement can be best understood from the examples shown in fig-
ure 8.15 :
figure 8.15 (a). this is a delta prior fθ(θ) =δ(θ) (or fθ(θ) =δ(θ−θ0)). if you use this
prior, you are absolutely sure that the parameter θ takes a specific value. there is no
uncertainty about your belief. since you are so confident about your prior knowledge,
you will ignore the likelihood that is constructed from the data. no one will use a
delta prior in practice.
figure 8.15 (b).fθ(θ) =1
b−afora≤θ≤b, and is zero otherwise. this is a bounded
uniform prior. you do not have any preference for the parameter θ, but you do know
from your prior experience that a≤θ≤b.
figure 8.15 (c). this prior is the same as (b) but is short and very wide. if you use
this prior, it means that you know nothing about the parameter. so you give up the
prior and let the likelihood dominate the map estimate.
figure 8.15 (d).fθ(θ) = gaussian(0 , σ2). you use this prior when you know something
about the parameter, e.g., that it is centered at certain location and you have some
uncertainty.
figure 8.15 (e). same as (d), but the parameter is centered at some other location.
figure 8.15 (f). same as (d), but you have less confidence about the parameter.
as you can see from these examples, the shape of the prior tells us how youwant θ to be
distributed. the choice you make will directly influence the map optimization, and hence
the map estimate.
since the prior is a subjective quantity in the map framework, you as the user have
the freedom to choose whatever you like. for instance, if you have conducted a similar
experiment before, you can use the results of the previous experiments as the current prior.
another strategy is to go with physics. for instance, we can argue that θshould be sparse
so that it contains as few non-zeros as possible. in this case, a sparsity-driven prior, such
asfθ(θ) = exp {−∥θ∥1}, could be a choice. the third strategy is to choose a prior that is
computationally “friendlier”, e.g., in quadratic form so that the map is differentiable. one
such choice is the conjugate prior . we will discuss this later in section 8.3.6.
which prior should we choose?
based on your preference, e.g., you know from historical data that the parameter
should behave in certain ways.
based on physics, e.g., the parameter has a physical interpretation, so you need
to abide by the physical laws.
choose a prior that is computationally “friendlier”. this is the topic of the
conjugate prior , which is a prior that does not change the form of the posterior
distribution. (we will discuss this later in section 8.3.6.)
505chapter 8. estimation
8.3.3 map formulation and solution
our next task is to study how to formulate the map problem and how to solve it.
definition 8.7. letx= [x1, . . . , x n]tbe i.i.d. observations. let θbe a random
parameter. the maximum-a-posteriori estimate of θis
bθmap =argmax
θfθ|x(θ|x). (8.38)
philosophically speaking, ml and map have two different goals. ml considers a para-
metric model with a deterministic parameter. its goal is to find the parameter that maximizes
the likelihood for the data we have observed. map also considers a parametric model but
the parameter θis random. because θis random, we are finding one particular state θof
the parameter θthat offers the best explanation conditioned on the data xwe observe.
in a sense, the two optimization problems are
bθml= argmax
θfx|θ(x|θ),
bθmap = argmax
θfθ|x(θ|x).
this pair of equations is interesting, as the pair tells us that the difference between the ml
estimation and the map estimation is the flipped order of xandθ.
there are two reasons we care about the posterior. first, in map the posterior allows
us to incorporate the prior. ml does not allow a prior. a prior can be useful when the
number of samples is small. second, maximizing the posterior does have some physical
interpretations. map asks for the probability of θ=θafter observing ntraining samples
x=x. ml asks for the probability of observing x=xgiven a parameter θ. both are
correct and legitimate criteria, but sometimes we might prefer one over the other.
to solve the map problem, we notice that
bθmap = argmax
θfθ|x(θ|x)
= argmax
θfx|θ(x|θ)fθ(θ)
fx(x)
= argmax
θfx|θ(x|θ)fθ(θ), f x(x) does not contain θ
= argmax
θlogfx|θ(x|θ) + log fθ(θ).
therefore, what map adds is the prior log fθ(θ). if you use an uninformative prior, e.g., a
prior with extremely wide support, then the map estimation will return more or less the
same result as the ml estimation.
when does map = ml?
the relation “=” does not make sense here, because θis random in map but
deterministic in ml.
solution of map optimization = solution of ml optimization, when fθ(θ) is
uniform over the parameter space.
5068.3. maximum a posteriori estimation
in this case, fθ(θ) = constant and so it can be dropped from the optimization.
example 8.19 . let x1, . . . , x nbe i.i.d. random variables with a pdf fxn|θ(xn|θ)
for all n, and θ be a random parameter with pdf fθ(θ):
fxn|θ(xn|θ) =1√
2πσ2exp
−(xn−θ)2
2σ2
,
fθ(θ) =1p
2πσ2
0exp
−(θ−µ0)2
2σ2
0
.
find the map estimate.
solution . the map estimate is
bθmap = argmax
θ"ny
n=11√
2πσ2exp
−(xn−θ)2
2σ2#
×"
1p
2πσ2
0exp
−(θ−µ0)2
2σ2
0#
= argmax
θ1√
2πσ2n
×1p
2πσ2
0exp(
−nx
n=1(xn−θ)2
2σ2−(θ−µ0)2
2σ2
0)
.
since the maximizer is not changed by any monotonic function, we apply logarithm
to the above equations. this yields
bθmap = argmax
θ
−n
2log 
2πσ2
−1
2log(2πσ2
0)
−nx
n=1(xn−θ)2
2σ2−(θ−µ0)2
2σ2
0
.
constants in the maximization do not matter. so by dropping the constant terms we
obtain
bθmap = argmax
θ(
−nx
n=1(xn−θ)2
2σ2−(θ−µ0)2
2σ2
0)
. (8.39)
it now remains to solve the maximization. to this end we take the derivative w.r.t. θ
and show that
d
dθ(
−nx
n=1(xn−θ)2
2σ2−(θ−µ0)2
2σ2
0)
= 0.
this yields
nx
n=1(xn−θ)
σ2−θ−µ0
σ2
0= 0.
507chapter 8. estimation
rearranging the terms gives us the final result:
bθmap =σ2
0
1
npn
n=1xn
+σ2
nµ0
σ2
0+σ2
n. (8.40)
practice exercise 8.7 . prove that if fθ(θ) =δ(θ−θ0), the map estimate is bθmap =
θ0.
solution . iffθ(θ) =δ(θ−θ0), then
bθmap = argmax
θlogfx|θ(x|θ) + log fθ(θ)
= argmax
θlogfx|θ(x|θ) + log δ(θ−θ0)
=

argmax
θlogfx|θ(x|θ)− ∞, θ̸=θ0.
argmax
θlogfx|θ(x|θ) + 0, θ=θ0.
thus, if bθmap̸=θ0, the first case says that there is no solution, so we must go with
the second case bθmap =θ0. but if bθmap =θ0, there is no optimization because we
have already chosen bθmap =θ0. this proves the result.
8.3.4 analyzing the map solution
as we said earlier, map offers something that ml does not. to see this, we will use the
result of the gaussian random variables as an example and analyze the map solution as
we change the parameters nandσ0. recall that if x1, . . . , x nare i.i.d. gaussian random
variables with unknown mean θand known variance σ, the ml estimate is
bθml=1
nnx
n=1xn.
assuming that the parameter θ is distributed according to a pdf gaussian( µ0, σ2
0), we
have shown in the previous subsection that
bθmap =σ2
0
1
npn
n=1xn
+σ2
nµ0
σ2
0+σ2
n=σ2
0bθml+σ2
nµ0
σ2
0+σ2
n.
in what follows, we will take a look at the behavior of the map estimate bθmap asn
andσ0change. the results of our discussion are summarized in figure 8.16 .
first, let’s look at the effect of n.
how does nchange bθmap?
asn→ ∞ , the map estimate bθmap→bθml: if we have enough samples, we
trust the data.
5088.3. maximum a posteriori estimation
(a) effect of n (b) effect of σ0
figure 8.16: the map estimate bθmapswings between the ml estimate bθmland the prior µ0. (a) when
nincreases, the likelihood is more reliable and so we lean towards the ml estimate. if nis small, we
should trust the prior more than the ml estimate. (b) when σ0decreases, we become more confident
about the prior and so we will use it. if σ0is large, we use more information from the ml estimate.
asn→0, the map estimate bθmap→θ0. if we do not have any samples, we
trust the prior.
these two results can be demonstrated by taking the limits. as n→ ∞ , the map estimate
converges to
lim
n→∞bθmap = lim
n→∞σ2
0bθml+σ2
nµ0
σ2
0+σ2
n=bθml. (8.41)
this result is not surprising. when we have infinitely many samples, we will completely
rely on the data and make our estimate. thus, the map estimate is the same as the ml
estimate.
when n→0, the map estimate converges to
lim
n→0bθmap = lim
n→0σ2
0bθml+σ2
nµ0
σ2
0+σ2
n=µ0. (8.42)
this means that, when we do not have any samples, the map estimate bθmap will completely
use the prior distribution, which has a mean µ0.
the implication of this result is that map offers a natural swing between bθmlandbθ0,
controlled by n. where does this ncome from? if we recall the derivation of the result, we
note that the naffects the likelihood term through the number of samples:
bθmap = argmax
θ
−nx
n=1(xn−θ)2
2σ2
|{z }
nterms here−(θ−µ0)2
2σ2
0|{z}
1 term
.
thus, as nincreases, the influence of the data term grows, and so the result will gradually
shift towards bθml.
figure 8.17 illustrates a numerical experiment in which we draw nrandom samples
x1, . . . , x naccording to a gaussian distribution gaussian( θ, σ2), with σ= 1. we assume
that the prior distribution is gaussian( µ0, σ2
0), with µ0= 0 and σ0= 0.25. the ml estimate
of this problem is bθml=1
npn
n=1xn, whereas the map estimate is given by equation (8.40).
509chapter 8. estimation
the figure shows the resulting pdfs. a helpful analogy is that the prior and the likelihood
are pulling a rope in two opposite directions. as ngrows, the force of the likelihood increases
and so the influence becomes stronger.
(a)n= 1 (b) n= 50
figure 8.17: the subfigures show the prior distribution fθ(θ)and the likelihood function fx|θ(x|θ),
given the observed data. (a) when n= 1, the estimated posterior distribution fθ|x(θ|x)is pulled
towards the prior. (b) when n= 50 , the posterior is pulled towards the ml estimate. the analogy for
the situation is that each data point is acting as a small force against the big force of the prior. as n
grows, the small forces of the data points accumulate and eventually dominate.
we next look at the effect of σ0.
how does σ0change bθmap?
asσ0→ ∞ , the map estimate bθmap→bθml: if we have doubts about the prior,
we trust the data.
asσ0→0, the map estimate bθmap→θ0. if we are absolutely sure about the
prior, we ignore the data.
when σ0→ ∞ , the limit of bθmap is
lim
σ0→∞bθmap = lim
σ0→∞σ2
0bθml+σ2
nµ0
σ2
0+σ2
n=bθml. (8.43)
the reason why this happens is that σ0is the uncertainty level of the prior. if σ0is high,
we are not certain about the prior. in this case, map chooses to follow the ml estimate.
when σ0→0, the limit of bθmap is
lim
σ0→0bθmap = lim
σ0→0σ2
0bθml+σ2
nµ0
σ2
0+σ2
n=µ0. (8.44)
note that when σ0→0, we are essentially saying that we are absolutely sure about the
prior. if we are so sure about the prior, there is no need to look at the data. in that case
the map estimate is µ0.
5108.3. maximum a posteriori estimation
the way to understand the influence of σ0is to inspect the equation:
bθmap = argmax
θ
−nx
n=1(xn−θ)2
2σ2
|{z }
fixed w.r.t. σ0−(θ−µ0)2
2σ2
0|{z}
changes with σ0
.
since σ0is purely a preference youdecide, you can control how much trust to put onto the
prior.
(a)σ0= 0.1 (b) σ0= 1
figure 8.18: the subfigures show the prior distribution fθ(θ)and the likelihood function fx|θ(x|θ),
given the observed data. (a) when σ0= 0.1, the estimated posterior distribution fθ|x(θ|x)is pulled
towards the prior. (b) when σ0= 1, the posterior is pulled towards the ml estimate. an analogy for
the situation is that the strength of the prior depends on the magnitude of σ0. ifσ0is small the prior
is strong, and so the influence is large. if σ0is large the prior is weak, and so the ml estimate will
dominate.
figure 8.18 illustrates a numerical experiment in which we compare σ0= 0.1 and
σ0= 1. if σ0is small, the prior distribution fθ(θ) becomes similar to a delta function. we
can interpret it as a very confident prior, so confident that we wish to align with the prior.
the situation can be imagined as a game of tug-of-war between a powerful bull and a horse,
which the bull will naturally win. if σ0is large the prior distribution will become flat. it
means that we are not very confident about the prior so that we will trust the data. in this
case the map estimate will shift towards the ml estimate.
8.3.5 analysis of the posterior distribution
when the likelihood is multiplied with the prior to form the posterior, what does the poste-
rior distribution look like? to answer this question we continue our gaussian example with
a fixed variance σand an unknown mean θ. the posterior distribution is proportional to
fθ|x(θ|x) =fx|θ(x|θ)fθ(θ)
fx(x)∝fx|θ(x|θ)fθ(θ)
="ny
n=11√
2πσ2exp
−(xn−θ)2
2σ2#
·"
1p
2πσ2
0exp
−(θ−µ0)2
2σ2
0#
.(8.45)
511chapter 8. estimation
performing the multiplication and completing the squares,
nx
n=1(xn−θ)2
2σ2+(θ−µ0)2
2σ2
0=(θ−bθmap)2
2σ2
map,
where
bθmap =σ2
0bθml+σ2
nµ0
σ2
0+σ2
n, and1
bσ2
map=1
σ2
0+n
σ2. (8.46)
in other words, the posterior distribution fθ|x(θ|x) is also a gaussian with
fθ|x(θ|x) = gaussian( bθmap,bσ2
map).
iffx|θ(x|θ) =gaussian (x;θ, σ), and fθ(θ) =gaussian (θ;µ0, σ2
0), what is the
posterior fθ|x(θ|x)?
the posterior fθ|x(θ|x) is gaussian( bθmap,bσ2
map), where
bθmap =σ2
0bθml+σ2
nµ0
σ2
0+σ2
n,and1
bσ2
map=1
σ2
0+n
σ2. (8.47)
the posterior tells us how nandσ0will influence the map estimate. as ngrows,
the posterior mean and variance becomes
lim
n→∞bθmap =bθml=θ,and lim
n→∞bσmap = 0.
as a result, the posterior distribution fθ|x(θ|x) will converge to a delta function centered
at the ml estimate bθml. therefore, as we try to solve the map problem by maximizing the
posterior, the map estimate has to improve because bσmap→0.
we can plot the posterior distribution gaussian( bθmap,bσ2
map) as a function of the
number of samples n.figure 8.19 illustrates this example using the following configurations.
the likelihood is gaussian with µ= 1, σ= 0.25. the prior is gaussian with µ0= 0 and
σ= 0.25. we construct the gaussian according to gaussian( bθmap,bσ2
map) by varying n.
the result shown in figure 8.19 confirms our prediction: as ngrows, the posterior becomes
more like a delta function whose mean is the true mean µ. the posterior estimator bθmap,
for each n, is the peak of the respective gaussian.
what is the pictorial interpretation of the map estimate?
for every n, map has a posterior distribution fθ|x(θ|x).
asngrows, fθ|x(θ|x) converges to a delta function centered at bθml.
map tries to find the peak of fθ|x(θ|x). for large n, it returns bθml.
5128.3. maximum a posteriori estimation
-1 -0.5 0 0.5 1 1.502468
n = 0
n = 1
n = 2
n = 5
n = 8
n = 12
n = 20
figure 8.19: posterior distribution fθ|x(θ|x) =gaussian (bθmap, σ2
map)asngrows. when nis small,
the posterior distribution is dominated by the prior. as nincreases, the posterior distribution changes
its mean and its variance.
8.3.6 conjugate prior
choosing the prior is an important topic in a map estimation. we have elaborated two
“engineering” solutions: use your prior experience or follow the physics. in this subsection,
we discuss the third option: to choose something computationally friendly. to explain what
we mean by “computationally friendly”, let us consider the following example, thanks to
avinash kak.4
consider a bernoulli distribution with a pdf
fx|θ(x|θ) =ny
n=1θxn(1−θ)1−xn. (8.48)
to compute the map estimate, we assume that we have a prior fθ(θ). therefore, the map
estimate is given by
bθmap = argmax
θfx|θ(x|θ)fθ(θ)
= argmax
θ"ny
n=1θxn(1−θ)1−xn#
·fθ(θ)
= argmax
θnx
n=1xnlogθ+ (1−xn) log(1 −θ) + log fθ(θ).
let us consider three options for the prior. which one would you use?
candidate 1 :fθ(θ) =1√
2πσ2expn
−(θ−µ)2
2σ2o
, a gaussian prior. if you choose this
prior, the optimization problem will become
bθmap = argmax
θnx
n=1
xnlogθ+ (1−xn) log(1 −θ)
−(θ−µ)2
2σ2.
4avinash kak “ml, map, and bayesian — the holy trinity of parameter estimation and data pre-
diction”, https://engineering.purdue.edu/kak/tutorials/trinity.pdf
513chapter 8. estimation
we can still take the derivative and set it to zero. this gives
pn
n=1xn
θ−n−pn
n=1xn
1−θ=θ−µ
σ2.
defining s=pn
n=1xnand moving the terms around, we have
(1−θ)σ2s−θσ2(n−s) =θ(1−θ)(θ−µ).
this is a cubic polynomial problem that has a closed-form solution and is also solvable
by a computer. but it’s also tedious, at least to lazy engineers like ourselves.
candidate 2 :fθ(θ) =λ
2e−λ|θ|, a laplace prior. in this case, the optimization problem
becomes
bθmap = argmax
θnx
n=1
xnlogθ+ (1−xn) log(1 −θ)
−λ|θ|.
welcome to convex optimization! there is no closed-form solution. if you want to solve
this problem, you need to call a convex solver.
candidate 3 :fθ(θ) =1
cθα−1(1−θ)β−1, a beta prior. this prior looks very compli-
cated, but let’s plug it into our optimization problem:
bθmap = argmax
θnx
n=1
xnlogθ
+ (1−xn) log(1 −θ)
+ (α−1) log θ+ (β−1) log(1 −θ)
= argmax
θ(s+α−1) log θ+ (n−s+β−1) log(1 −θ),
where s=pn
n=1xn. taking the derivative and setting it to zero, we have
s+α−1
θ=n−s+β−1
1−θ.
rearranging the terms we obtain the final estimate:
bθmap =s+α−1
n+β+α−2. (8.49)
there are a number of intuitions that we can draw from this beta prior, but most
importantly, we have obtained a very simple solution. that is because the posterior distri-
bution remains in the same form as the prior, after multiplying by the prior. specifically, if
we use the beta prior, the posterior distribution is
fθ|x(θ|x)∝fx|θ(x|θ)fθ(θ)
="ny
n=1θxn(1−θ)1−xn#
·1
cθα−1(1−θ)β−1
=θs+α−1(1−θ)n−s+β−1.
this is still in the form of θ⋆−1(1−θ)■−1, which is the same as the prior. when this
happens, we call the prior a conjugate prior. in this example, the beta prior is a conjugate
before the bernoulli likelihood.
5148.3. maximum a posteriori estimation
what is a conjugate prior?
it is a prior such that when multiplied by the likelihood to form the posterior,
the posterior fθ|x(θ|x) takes the same form as the prior fθ(θ).
every likelihood has its conjugate prior.
conjugate priors are not necessarily good priors. they are just computationally
friendly. some of them have good physical interpretations.
we can make a few interpretations of the beta prior, in the context of bernoulli likeli-
hood. first, the beta distribution takes the form
fθ(θ) =1
b(α, β)θα−1(1−θ)β−1, (8.50)
with b(α, β) is the beta function5. the shape of the beta distribution is shown in fig-
ure 8.20 . for different choices of αandβ, the distribution has a peak located towards
either side of the interval [0 ,1]. for example, if αis large but βis small, the distribution
fθ(θ) leans towards 1 (the yellow curve).
0 0.2 0.4 0.6 0.8 101234
 = 2,  = 8
 = 3,  = 7
 = 8,  = 2
figure 8.20: beta distribution fθ(θ)for various choices of αandβ. when (α, β) = (2 ,8), the beta
distribution favors small θ. when (α, β) = (8 ,2), the beta distribution favors large θ. by swinging
between the (α, β)pairs, we obtain a prior that has a preference over θ.
as a user, you have the freedom to pick fθ(θ). even if you are restricted to the beta
distribution, you still have plenty of degrees of freedom in choosing αandβso that your
choice matches your belief. for example, if you know ahead of time that the bernoulli
experiment is biased towards 1 (e.g., the coin is more likely to come up heads), you can
choose a large αand a small β. by contrast, if you believe that the coin is fair, you choose
α=β. the parameters αandβare known as the hyperparameters of the prior distribution.
hyperparameters are parameters for fθ(θ).
5the beta function is defined as b(α, β) =γ(α)γ(β)
γ(α+β), where γ is the gamma function. for integer n,
γ(n) = (n−1)!
515chapter 8. estimation
example 8.20 . (prior for gaussian mean) consider a gaussian likelihood for a fixed
variance σ2and unknown mean θ:
fx|θ(x|θ) =1√
2πσ2n
exp(
−nx
n=1(xn−θ)2
2σ2)
.
show that the conjugate prior is given by
fθ(θ) =1p
2πσ2
0exp
−(θ−µ0)2
2σ2
0
. (8.51)
solution . we have shown this result previously. by some (tedious) completing squares,
we show that
fθ|x(θ|x) =1p
2πσ2
nexp
−(θ−µn)2
2σ2
n
,
where
µn=σ2
nσ2
0+σ2µ0+nσ2
0
nσ2
0+σ2bθmland σ2
n=σ2σ2
0
σ2+nσ2
0.
since fθ|x(θ|x) is in the same form as fθ(θ), we know that fθ(θ) is a conjugate prior.
example 8.21 . (prior for gaussian variance ) consider a gaussian likelihood for a
mean µand unknown variance σ2:
fx|σ(x|σ) =1√
2πσ2n
exp(
−nx
n=1(xn−µ)2
2σ2)
.
find the conjugate prior.
solution . we first define the precision θ=1
σ2. the likelihood is
fx|θ(x|θ) =1√
2πσ2n
exp(
−nx
n=1(xn−µ)2
2σ2)
=1
(2π)n/2θn/2exp(
−θ
2nx
n=1(xn−µ)2)
.
we propose to choose the prior fθ(θ) as
fθ(θ) =1
γ(a)baθa−1exp{−bθ},
for some aandb. this fθ(θ) is called the gamma distribution gamma( θ|a, b). we can
show that e[θ] =a
band var[θ] =a
b2. with some (tedious) completing squares, we
5168.3. maximum a posteriori estimation
show that the posterior is
fθ|x(θ|x)∝θ(a0+n/2)−1exp(
− 
b0+1
2nx
n=1(xn−µ)2!
θ)
,
which is in the same form as the prior. so we know that our proposed fθ(θ) is a
conjugate prior.
the story of conjugate priors is endless because every likelihood has its conjugate prior.
table 8.1 summarizes a few commonly used conjugate priors, their likelihoods, and their
posteriors. the list can be expanded further to distributions with multiple parameters. for
example, if a gaussian has both unknown mean and variance, then there exists a conjugate
prior consisting of a gaussian multiplied by a gamma. conjugate priors also apply to multi-
dimensional distributions. for example, the prior for the mean vector of a high-dimensional
gaussian is another high-dimensional gaussian. the prior for the covariance matrix of a
high-dimensional gaussian is the wishart prior. the prior for both the mean vector and the
covariance matrix is the normal wishart.
table of conjugate priors
likelihood conjugate prior posterior
fx|θ(x|θ) fθ(θ) fθ|x(θ|x)
bernoulli( θ) beta( α, β) beta( α+s, β+n−s)
poisson( θ) gamma( α, β) gamma
α+s,β
1+n
exponential( θ) gamma( α, β) gamma
α+n,β
1+βs
gaussian( θ, σ2) gaussian( µ0, σ2
0) gaussian
µ0/σ2
0+s/σ2
1/σ2
0+n/σ2
gaussian( µ, θ2) inv. gamma( α, β) gamma
α+n
2, β+1
2pn
n=1(xn−µ)2
table 8.1: commonly used conjugate priors.
8.3.7 linking map with regression
ml and regression represent the statistics and the optimization aspects of the same problem.
with the parallel argument, map is linked to the regularized regression. the reason follows
immediately from the definition of map:
bθmap = argmax
θlogfx|θ(x|θ)|{z }
data fidelity+ log fθ(θ)|{z}
regularization.
517chapter 8. estimation
to make this more explicit, we consider following linear regression problem:

y1
y2
...
yn

|{z}
=y=
ϕ0(x1)ϕ1(x1)··· ϕd−1(x1)
ϕ0(x2)ϕ1(x2)··· ϕd−1(x2)
... ···......
ϕ0(xn)ϕ1(xn)···ϕd−1(xn)

| {z }
=x
θ0
θ1
...
θd−1

|{z}
=θ+
e1
e2
...
en

|{z}
=e.
if we assume that e∼gaussian(0 , σ2i), the likelihood is defined as
fy|θ(y|θ) =1p
(2πσ2)nexp
−1
2σ2∥y−xθ∥2
. (8.52)
in the ml setting, the ml estimate is the maximizer of the likelihood:
bθml= argmax
θlogfy|θ(y|θ)
= argmax
θ−1
2σ2∥y−xθ∥2.
for map, we add a prior term so that the optimization becomes
bθmap = argmax
θlogfy|θ(y|θ) + log fθ(θ)
= argmin
θ1
2σ2∥y−xθ∥2−logfθ(θ).
therefore, the regularization of the regression is exactly −logfθ(θ). we can perform reverse
engineering to find out the corresponding prior for our favorite choices of the regularization.
ridge regression . suppose that
fθ(θ) = exp
−∥θ∥2
2σ2
0
.
taking the negative log on both sides yields
−logfθ(θ) =∥θ∥2
2σ2
0.
putting this into the map estimate,
bθmap = argmin
θ1
2σ2∥y−xθ∥2+1
2σ2
0∥θ∥2
= argmin
θ∥y−xθ∥2+σ2
σ2
0|{z}
=λ∥θ∥2,
where λis the corresponding ridge regularization parameter. therefore, the ridge regression
is equivalent to a map estimation using a gaussian prior.
5188.3. maximum a posteriori estimation
how is map related to ridge regression?
in map, define the prior as a gaussian:
fθ(θ) = exp
−∥θ∥2
2σ2
0
. (8.53)
the prior says that the solution θis naturally distributed according to a gaussian
with mean zero and variance σ2
0.
lasso regression . suppose that
fθ(θ) = exp
−∥θ∥1
α
.
taking the negative log on both sides yields
−logfθ(θ) =∥θ∥1
α.
putting this into the map estimate we can show that
bθmap = argmin
θ1
2σ2∥y−xθ∥2+1
α∥θ∥1
= argmin
θ1
2∥y−xθ∥2+σ2
α|{z}
=λ∥θ∥1.
to summarize:
how is map related to lasso regression?
lasso is a map using the prior
fθ(θ) = exp
−∥θ∥1
α
. (8.54)
at this point, you may be wondering what map buys us when regularized regression
can already do the job. the answer is about the interpretation. while regularized regression
can always return us a result, that is just a result. however, if you know that the parameter θ
is distributed according to some distributions fθ(θ), map offers a statistical perspective of
the solution in the sense that it returns the peak of the posterior fθ|x(θ|x). for example, if
we know that the data is generated from a linear model with gaussian noise, and if we know
that the true regression coefficients are drawn from a gaussian, then the ridge regression is
guaranteed to be optimal in the posterior sense. similarly, if we know that there are outliers
and have some ideas about the outlier statistics, perhaps the lasso regression is a better
choice.
it is also important to note the different optimalities offered by map versus ml versus
regression. the optimality offered by regression is the training loss, which can always give
us a result even if the underlying statistics do not match the optimization formulation,
519chapter 8. estimation
e.g., there are outliers, and you use unregularized least-squares minimization. you can get a
result, but the outliers will heavily influence your solution. on the other hand, if you know
the data statistics and choose to follow the ml, then the ml solution is optimal in the sense
of optimizing the likelihood fx|θ(x|θ). if you further know the prior statistics, the map
solution will be optimal, but this time it is optimal w.r.t. to the posterior fθ|x(θ|x). since
each of these is optimizing for a different goal, they are only good for their chosen objectives.
for example, bθmap can be a biased estimate if our goal is to maximize the likelihood. the
bθmlis optimal for the likelihood but can be a bad choice for the posterior. both bθmap and
bθmlcan possibly achieve a reasonable mean-squared error, but their results may not make
sense (e.g., if θis an image then bθmap may over-smooth the image whereas bθmlamplifies
noise). so it’s incorrect to think that bθmap is superior to bθmlbecause it is more general.
here are some rules of thumb for map, ml, and regression:
when should i use regression, ml and map?
regression : if you are lazy and you know nothing about the statistics, do the
regression with whatever regularization you prefer. it will give you a result. see
if it makes sense with your data.
map : if you know the statistics of the data, and if you have some preference for
the prior distribution, go with map. it will offer you the optimal solution w.r.t.
finding the peak of the posterior.
ml: if you are interested in some simple-form solution, and you want those nice
properties such as consistency and unbiasedness, then go with ml. it usually
possesses the “friendly” properties so that you can derive the performance limit.
8.4 minimum mean-square estimation
first-time readers are often tempted to think that the maximum-likelihood estimation or
the maximum a posteriori estimation are thebest methods to estimate parameters. in some
sense, this is true because both estimation procedures offer some form of optimal explanation
for the observed variables. however, as we said above, being optimal with respect to the
likelihood or the posterior only means optimal under the respective criteria. an ml estimate
is not necessarily optimal for the posterior, whereas a map estimate is not necessarily
optimal for the likelihood. therefore, as we proceed to the third commonly used estimation
strategy, we need to remind ourselves of the specific type of optimality we seek.
8.4.1 positioning the minimum mean-square estimation
mean-square error estimation, as it is termed, uses the mean-square error as the optimality
criterion. the corresponding estimation process is known as the minimum mean-square
estimation (mmse) . mmse is a bayesian approach, meaning that it uses the prior fθ(θ)
as well as the likelihood fx|θ(x|θ). as we will show shortly, the mmse estimate of a set
5208.4. minimum mean-square estimation
of i.i.d. observation x= [x1, . . . , x n]tis
bθmmse (x)(a)=eθ|x[θ|x=x] ( a) : we will discuss this.
=z
θ·fθ|x(θ|x)dθ. (8.55)
you may find this equation very surprising, because it says that the mmse estimate is
themean of the posterior distribution fθ|x(θ|x). let’s compare this result with the ml
estimate and the map estimate:
bθml= peak of fx|θ(x|θ),
bθmap = peak of fθx|(θ|x),
bθmmse = average of fθ|x(θ|x).
therefore, an mmse estimate is not by any means universally superior or inferior to a map
estimate or an ml estimate. it is just a different estimate with a different goal.
so how exactly are these estimates different? figure 8.21 illustrates a typical situation
of asymmetric distribution. here, we plot both the likelihood function fx|θ(x|θ) and the
posterior function fθx|(θ|x).
figure 8.21: a typical example of an ml estimate, a map estimate and an mmse estimate.
as shown in the figure, the ml estimate is the peak of the likelihood, whereas the map
estimate is the peak of the posterior. the third estimate is the mmse estimate, which is
the average of the posterior distribution. it is easy to see that if the posterior distribution
is symmetric and has a single peak, the peak is always the mean. therefore, for single-peak
symmetric distributions, mmse and map estimates are identical.
what is so special about the mmse estimate?
mmse is a bayesian estimation, so it requires a prior.
an mmse estimate is the mean of the posterior distribution.
mmse estimate = map estimate if the posterior distribution is symmetric and
has a single peak.
521chapter 8. estimation
8.4.2 mean squared error
the mmse is based on minimizing the mean squared error (mse). in this subsection we
discuss the mean squared error in the bayesian setting. in the deterministic setting, given
an estimate bθand a ground truth θ, the mse is defined as
mse( θ|{z}
ground truth,bθ|{z}
estimate) = (θ−bθ)2. (8.56)
in any estimation problem, the estimate bθis always a function of the observed variables.
thus, we have
bθ(x) =g(x), where x= [x1, . . . , x n]t,
for some function g(·). substituting this into the definition of mse, and recognizing that x
is drawn from a distribution fx(x), we take the expectation to define the mse as
mse( θ,bθ) = (θ−bθ)2
⇓replace bθbyg(x)
mse( θ,bθ) = (θ−g(x))2
⇓take expectation over x
mse( θ,bθ) =ex
(θ−g(x))2
.
thus we have arrived at the definition of mse. we call this the frequentist version, because
the parameter θis deterministic.
definition 8.8 (mean squared error, frequentist ).the mean squared error of an
estimate g(x)w.r.t. the true parameter θis
mse freq(θ, g(·)) =ex
(θ−g(x))2
. (8.57)
if the parameter θis high-dimensional, so is the estimate g(x), and the mse is
mse freq(θ,g(·)) =ex
∥θ−g(x)∥2
. (8.58)
note that in the above definition the mse is measured between the true parameter θand
the estimator g(·). we use the function g(·) here because we have taken the expectation
of all the possible inputs x. so we are not comparing θwith a value g(x) but with the
function g(·).
if we take a bayesian approach such as the map, then θitself is a random variable θ.
to compute the mse, we then need to take the average across all the possible choices of
ground truth θ. this leads to
mse( θ,bθ) =ex
(θ−g(x))2
⇓replace θby θ
mse( θ,bθ) =ex
(θ−g(x))2
⇓take expectation over θ
mse( θ,bθ) =ex,θ
(θ−g(x))2
.
therefore, we have arrived at our definition of the mse, in the bayesian setting.
5228.4. minimum mean-square estimation
definition 8.9 (mean squared error, bayesian ).the mean squared error of an es-
timate g(x)w.r.t. the true parameter θis
mse bayes (θ, g(·)) =eθ,x
(θ−g(x))2
. (8.59)
if the parameter θis high-dimensional, so is the estimate g(x), and the mse is
mse bayes (θ,g(·)) =eθ,x
∥θ−g(x)∥2
. (8.60)
the difference between the bayesian mse and the frequentist mse is the expectation over θ.
practically speaking, the frequentist mse is more of an evaluation metric than an objective
function for solving an inverse problem. the reason is that in an inverse problem, we never
have access to the true parameter θ. (if we knew θ, there would be no problem to solve.)
bayesian mse is more meaningful. it says that we do not know the true parameter θ, but
we know its statistics. we are trying to find the best g(·) that minimizes the error. our
solution will depend on the statistics of θ but not on the unknown true parameter θ.
when we say minimum mean squared error estimation, we typically refer to the
bayesian mmse. in this case, the problem we solve is
g(·) = argmin
g(·)eθ,x
(θ−g(x))2
. (8.61)
as you can see from definition 8.9, the goal of the bayesian mmse is to find a function
g:rn→rsuch that the joint expectation eθ,x
(θ−g(x))2
is minimized. in the case
where θis a vector, the problem becomes
g(·) = argmin
g(·)eθ,x
∥θ−g(x)∥2
, (8.62)
where g(·) :rn×d→rdifθis ad-dimensional vector. the function gwill take a sequence
ofnobserved numbers and estimate the parameter θ.
what is the bayesian mmse estimate?
the bayesian mmse estimate is obtained by minimizing the mse:
g(·) = argmin
g(·)eθ,x
(θ−g(x))2
. (8.63)
8.4.3 mmse estimate = conditional expectation
theorem 8.2. thebayesian mmse estimate is
bθmmse =argmin
g(·)eθ,x
(θ−g(x))2
=eθ|x[θ|x=x]. (8.64)
523chapter 8. estimation
proof . first of all, we decompose the joint expectation:
eθ,x
(θ−g(x))2
=z
eθ|x
(θ−g(x))2|x=x
fx(x)dx.
since fx(x)≥0 for all x, andeθ|x
(θ−g(x))2|x=x
≥0 because it is a square, it
follows that the integral is minimized when eθ|x
(θ−g(x))2|x=x
is minimized.
the conditional expectation can be evaluated as
eθ|x[(θ−g(x))2|x=x]
=eθ|x
θ2−2θg(x) +g(x)2x=x
=eθ|x
θ2x=x
| {z }
def=v(x)−2eθ|x
θx=x
| {z }
def=u(x)g(x) +g(x)2
=v(x)−2u(x)g(x) +g(x)2+u(x)2−u(x)2
=v(x)−u(x)2+ (u(x)−g(x))2
≥v(x)−u(x)2,∀g(·),
where the last inequality holds because no matter what g(·) we choose, the square term
(u(x)−g(x))2is non-negative. therefore, eθ|x[(θ−g(x))2|x=x] is lower-bounded by
v(x)−u(x)2, which is a bound that is independent of g(·). if we can find a g(·) such that
this lower bound can be met, the corresponding g(·) is the minimizer.
to this end we only need to make eθ|x[(θ−g(x))2|x=x] equal v(x)−u(x)2,
but this is easy: the equality holds if and only if ( u(x)−g(x))2= 0. in other words, if we
choose g(·) such that g(x) =u(x), the corresponding g(·) is the minimizer. this g(·), by
substituting the definition of u(x), is
g(x) =eθ|x
θx=x
. (8.65)
this completes the proof.
□
what is the mmse estimate?
the mmse estimate is
bθmmse (x) =eθ|x[θ|x=x]. (8.66)
we emphasize that bθmmse (x) is a function of x, because for a different set of observations
xwe will have a different estimated value. since xis a random realization of the random
vector x, we can also define the mmse estimator as
bθmmse (x) =eθ|x[θ|x]. (8.67)
in this notation, we emphasize that the estimator bθmmse returns a random parameter. the
input to the estimator is the random vector x. because we are not looking at a particular
realization x=xbut the general x,bθmmse is a function of xand not x.
5248.4. minimum mean-square estimation
conditional expectation of what?
an mmse estimator is the conditional expectation of θ given x=x:
eθ|x
θx=x
=z
θ fθ|x(θ|x)dθ. (8.68)
this is the expectation using the posterior distribution fθ|x(θ|x). it should be compared
to the peak of the posterior, which returns us the map estimate. the posterior distribution
is constructed through bayes’ theorem:
fθ|x(θ|x) =fx|θ(x|θ)fθ(θ)
fx(x). (8.69)
therefore, to evaluate the expectation of the condition distribution, we need to include the
normalization constant fx(x), which was omitted in map.
the discussion about the mean squared error and the vector estimates can be skipped if
this is your first time reading the book.
what is the mean squared error when using the mmse estimator?
the mean squared error conditioned on the observation is
mse(θ ,bθmmse (x))def=eθ|x[(θ−bθmmse (x))2|x]
= var θ|x[θ|x],
which is the conditional variance.
the overall mean squared error, unconditioned, is
mse(θ ,bθmmse (·)) =ex
varθ|x[θ|x]
= var θ[θ].
proof . let us prove these two statements. the resulting mse is obtained by substituting
bθmmse (x) =eθ|x
θx
into the mse(θ ,bθmmse (x)). to this end, we have that
eθ|x[(θ−bθmmse (x))2|x] =v(x)−u(x)2
+ ( u(x)−bθmmse (x))2
| {z }
=0,because bθmmse (x)=eθ|x[θ|x]=u(x).
the variables vanduare defined as
v(x) =eθ|x
θ2x
= 2nd moment of θ using fθ|x(θ|x),
u(x) =eθ|x
θx
= 1st moment of θ using fθ|x(θ|x).
525chapter 8. estimation
since var[ z] =e[z2]−e[z]2for any random variable z, it follows that
eθ|x[(θ−bθmmse (x))2|x] =v(x)−u(x)2
=eθ|x
θ2x
− 
eθ|x
θx2
= variance of θ using fθ|x(θ|x)
def= var θ|x[θ|x].
substituting this conditional variance into the mse definition,
mse(θ ,bθmmse (·)) =z
eθ|x[(θ−bθmmse (x))2|x=x]fx(x)dx
=z
varθ|x[θ|x=x]fx(x)dx
= var θ[θ].
□
what happens if the parameter is a vector?
the mmse estimate is bθmmse (x) =eθ|x[θ|x=x].
the mse is
mse( θ,bθmmse (·)) = tr
exn
cov(θ|x)o
. (8.70)
proof . the first statement, that the mmse estimate is
bθmmse (x) =eθ|x[θ|x=x],
is easy to understand since it just follows from the scalar case. the estimator is bθmmse (x) =
eθ|x[θ|x]. the corresponding mse is
mse( θ,bθmmse (·)) =eθ,x[∥θ−bθmmse (x)∥2]
=ex
eθ|x[∥θ−bθmmse (x)∥2|x]
,
where we have used the law of total expectation to decompose the joint expectation. using
the matrix identity below, we have that
ex
eθ|x[∥θ−bθmmse (x)∥2|x]
=ex
eθ|xh
trn
(θ−bθmmse (x))(θ−bθmmse (x))to
|xi
= tr
ex
eθ|xh
(θ−bθmmse (x))(θ−bθmmse (x))t|xi
.
5268.4. minimum mean-square estimation
however, since the mmse estimator is the condition expectation of the posterior, it follows
that the inner expectation is the conditional covariance. therefore, we arrive at the second
statement:
mse( θ,bθmmse (·)) = tr
ex
eθ|xh
(θ−bθmmse (x))(θ−bθmmse (x))t|xi
= tr
exn
cov(θ|x)o
.
□
to prove the two statements above, we need some tools from linear algebra. the two
specific matrix identities are given by the following lemma:
lemma 8.1. the following are matrix identities:
for any random vector θ∈rd,
∥θ∥2=tr(θtθ) =tr(θθt).
for any random vector θ∈rd,
eθ[tr(θθt)] =tr(eθ[θθt]).
the proof of these two results is straightforward. the first is due to the cyclic property of
the trace operator. the second statement is true because the trace is a linear operator that
sums the diagonal of a matrix.
the end of the discussion. please join us again.
example 8.22 . let
fx|θ(x|θ) =(
θe−θx, x ≥0,
0, x < 0,and fθ(θ) =(
αe−αθ, θ ≥0,
0, θ < 0.
find the ml, map, and mmse estimates for a single observation x=x.
solution . we first find the posterior distribution:
fθ|x(θ|x) =fx|θ(x|θ)fθ(θ)
fx(x)
=αθe−(α+x)θ
r∞
0αθe−(α+x)θdθ
=αθe−(α+x)θ
α
(α+x)2
= (α+x)2θe−(α+x)θ.
527chapter 8. estimation
the mmse estimate is the conditional expectation of the posterior:
bθmmse (x) =eθ|x[θ|x=x]
=z∞
0θfθ|x(θ|x)dθ
=z∞
0θ(α+x)2θe−(α+x)θdθ
= (α+x)z∞
0θ2·(α+x)e−(α+x)θdθ
| {z }
2nd moment of exponential distribution
= (α+x)·2
(α+x)2=2
α+x.
the map estimate is the peak of the posterior:
bθmap(x) = argmax
θlogfx|θ(x|θ) + log fθ(θ)
= argmax
θ−θx+ log θ−αθ+ log α.
taking the derivative and setting it to zero yields −x+1
θ−α= 0. this implies that
bθmap(x) =1
α+x.
finally, the ml estimate is
bθml(x) = argmax
θlogfx|θ(x|θ) =1
x.
practice exercise 8.8 . following the previous example, derive the estimates for
multiple observations x=x.
solution . the posterior is
fθ|x(θ|x) =fx|θ(x|θ)fθ(θ)
fx(x)
=(qn
n=1fx|θ(xn|θ))fθ(θ)
fx(x)
=αθe−(α+pn
n=1xn)θ
r∞
0αθe−(α+pn
n=1xn)θdθ
= 
α+nx
n=1xn!2
θe−(α+pn
n=1xn)θ.
5288.4. minimum mean-square estimation
therefore, we are only replacing xby the sumpn
n=1xnin the posterior. hence, the
estimates are:
bθmmse (x) =2
α+pn
n=1xn,
bθmap(x) =1
α+pn
n=1xn,
bθml(x) =1pn
n=1xn.
this example shows that as n→ ∞ , the ml estimate bθml(x)→0. the reason is that the
likelihood is an exponential distribution. therefore, the peak is always at 0. the posterior is
an erlang distribution, and therefore the peak is offset by αin the denominator. however,
asn→ ∞ the posterior distribution is dominated by the likelihood, so the peak is shifted
towards 0. finally, since the erlang distribution is asymmetric, the mean is different from
the peak. hence, the mmse estimate is different from the map estimate.
8.4.4 mmse estimator for multidimensional gaussian
the multidimensional gaussian has some very important uses in data science. accordingly,
we devote this subsection to the discussion of the mmse estimate of a gaussian. the main
result is stated as follows.
what is the mmse estimator for a multi-dimensional gaussian?
theorem 8.3. suppose θ∈rdandx∈rnare jointly gaussian with a joint pdf
θ
x
∼gaussianµθ
µx
,σθθσθx
σxθσxx
.
the mmse estimator is
bθmmse (x) =µθ+σθxς−1
xx(x−µx). (8.71)
the proof of this result is not difficult but it is tedious. the flow of the argument is:
step 1: show that the posterior distribution fθ|x(θ|x) is a gaussian.
step 2: to do so we need to complete the squares for matrices.
step 3: once we have the fθ|x(θ|x), the posterior mean is the mmse estimator.
the proof below can be skipped if this is your first time reading the book.
529chapter 8. estimation
proof . the posterior pdf is
fθ|x(θ|x) =fθ,x(θ,x)
fx(x)
=1√
(2π)d+n|σ|exp(
−1
2θ−µθ
x−µxtσθθσθx
σxθσxx−1θ−µθ
x−µx)
1√
(2π)n|σxx|expn
−1
2x−µxtς−1
xxx−µxo .
without loss of generality, we assume that µx=µθ= 0. then the posterior becomes
fθ|x(θ|x) =1p
(2π)d|σ|/|σxx|
×exp(
−1
2θ
xtσθθσθx
σxθσxx−1θ
x
+1
2xtς−1
xxx)
| {z }
h(θ,x).
the tedious task here is to simplify h(θ,x).
regardless of what the 2-by-2 matrix inverse is, the matrix will take the form
σθθσθx
σxθσxx−1
=a b
c d
,
for some choices of matrices a,b,candd. therefore, the function h(θ,x) can be written
as
h(θ,x) =−1
2n
θtaθ+θtbx+xtcθ+xtdx−xtς−1
xxxo
. (8.72)
our goal is to complete the square for h(θ,x). to this end, we propose to write
h(θ,x) =−1
2n
(θ−gx)ta(θ−gx) +q(x)o
, (8.73)
for some matrix gand function q(·) ofxonly. if we compare equation (8.72) and equa-
tion (8.73), we observe that gmust satisfy
g=−a−1b.
therefore, if we can determine aandb, we will know g. if we know g, we have completed
the square for h(θ,x). if we can complete the square for h(θ,x), we can write
fθ|x(θ|x) =exp{−q(x)/2}p
(2π)d|σ|/|σxx|| {z }
constant in θ×exp
−1
2(θ−gx)ta(θ−gx)
| {z }
a gaussian.
hence, the mmse estimate, which is the posterior mean e[θ|x=x], is simply gx:
bθmmse (x) =e[θ|x=x]
=gx
=−a−1bx.
5308.4. minimum mean-square estimation
so it remains to determine aandbby solving the tedious matrix inversion problem. the
result is:6
a= (σθθ−σθxς−1
xxσxθ)−1,
b=−(σθθ−σθxς−1
xxσxθ)−1σθxς−1
xx,
c= (σxx−σxθς−1
θθσθx)−1σxθς−1
θθ,
d= (σxx−σxθς−1
θθσθx)−1.
therefore, plugging everything into the equation,
bθmmse (x) =−a−1bx
=σθ,xς−1
xxx.
for non-zero means, we can repeat the same arguments above and show that
bθmmse (x) =µθ+σθ,xς−1
xx(x−µx).
□
end of the proof. please join us again.
practice exercise 8.9 . suppose θ∈rdandx∈rnare jointly gaussian with a
joint pdfθ
x
∼gaussianµθ
µx
,σθθσθx
σxθσxx
.
we know that the mmse estimator is
bθmmse (x) =µθ+σθxς−1
xx(x−µx). (8.74)
find the mean squared error when using the mmse estimator.
solution . conditioned on x=x, according to equation (8.70), the mmse is
mse( θ,bθ(x)) = tr {cov[θ|x]}.
the conditional covariance cov[ θ|x] is the covariance of the posterior distribution
fθ|x(θ|x), which is
tr{cov[θ|x]}= tr{a}
= tr
(σθθ−σθxς−1
xxσxθ)−1	
.
6see matrix cookbook https://www.math.uwaterloo.ca/ ~hwolkowi/matrixcookbook.pdf section 9.1.5
on the schur complement.
531chapter 8. estimation
the overall mean squared error is
mse
θ,bθ(·)
=ex
mse( θ,bθ(x))
=z
mse( θ,bθ(x))fx(x)dx
=z
tr{cov[θ|x]}fx(x)dx
=z
tr
(σθθ−σθxς−1
xxσxθ)−1	
fx(x)dx
= tr
(σθθ−σθxς−1
xxσxθ)−1	z
fx(x)dx
= tr
(σθθ−σθxς−1
xxσxθ)−1	
.
for multidimensional gaussian, does mmse = map?
the answer is yes.
theorem 8.4. suppose θ∈rdandx∈rnare jointly gaussian with a joint pdf
θ
x
∼gaussianµθ
µx
,σθθσθx
σxθσxx
.
the map estimate is
bθmap(x) =µθ+σθxς−1
xx(x−µx). (8.75)
proof . the proof of this result is straightforward. if we return to the proof of the mmse
result, we note that
fθ|x(θ|x) =exp{−q(x)/2}p
(2π)d|σ|/|σxx|| {z }
constant in θ×exp
−1
2(θ−gx)ta(θ−gx)
| {z }
a gaussian.
therefore, the maximizer of this posterior distribution, which is the map estimate, is
bθmap(x) = argmax
θfθ|x(θ|x)
= argmax
θ−1
2(θ−gx)ta(θ−gx).
taking the derivative w.r.t. θand setting it zero, we have
bθmap(x) =gx=σθ,xς−1
xxx.
if the mean vectors are non-zero, we have bθmap(x) =µθ+σθxς−1
xx(x−µx).
□
5328.4. minimum mean-square estimation
8.4.5 linking mmse and neural networks
the blossoming of deep neural networks since 2010 has created a substantial impact on
modern data science. the basic idea of a neural network is to train a stack of matrices and
nonlinear functions (known as the network weights and the neuron activation functions,
respectively), among other innovative ideas, so that a certain training loss is minimized.
expressing this by equations, the goal of the learning is equivalent to solving the optimization
problem
bg(·) = argmin
g(·)ex,θ
∥θ−g(x)∥2
, (8.76)
where x∈rmis the input data and θ∈rdis the ground truth prediction. we want to
findg(·) such that the error is minimized.
the error we choose here is the ℓ2-norm error ∥ · ∥2. it is only one of many possi-
ble choices. you may recognize that this is exactly the same as the mmse optimization.
therefore, the neural network we are finding here is the mmse estimator. since the mmse
estimator is the conditional expectation of the posterior distribution, the neural network
approximates the mean of the posterior distribution.
often the struggle we have with deep neural networks is whether we can find the
optimal network parameters via optimization algorithms such as the stochastic gradient
descent algorithms. however, if we think about this problem more deeply, the equivalence
between the mmse estimator and the posterior mean tells us that the hard part is related
to the posterior distribution. in the high-dimensional landscape, it is close to impossible to
determine the posterior and its mean. if we add to these difficulties and the nonconvexity
of the function g, training a network is very challenging.
one misconception about neural networks is that if we can achieve a low training error,
and if the model can also achieve a low testing error, then the network is good. this is a false
sense of satisfaction. if a model can achieve very good training and testing errors, then the
model is only good with respect to the error you choose. for example, if we choose the ℓ2-
norm error ∥·∥2and if our model achieves good training and testing errors (in terms of ∥·∥2),
we can conclude that the model does well with respect to ∥ · ∥2. the more serious problem
here, unfortunately, is that ∥ · ∥2is not necessarily a good metric of performance (for both
training and testing) because training with ∥·∥2is equivalent to approximating the posterior
mean. there is absolutely no reason to believe that in the high-dimensional landscape, the
posterior mean is theoptimal. if we choose the posterior mode or the posterior median ,
we will also obtain a result. why are the modes and medians “worse” than the mean ?
in practice, it has been observed that training deep neural networks for image-processing
tasks generally leads to over-smoothed images. this demonstrates how minimizing the mean
squared error ∥ · ∥2can be a fundamental mismatch with the problem.
is minimizing the mse the best option?
no. minimizing the mse is equivalent to finding the mean of the posterior. there
is no reason why the mean is the “best”.
you can find the mode of the posterior, in which case you will get a map
estimator.
you can also find the median of the posterior, in which case you will get the
minimum absolute error estimator.
533chapter 8. estimation
ultimately, you need to define what is “good” and what is “bad”.
the same principle applies to deep neural networks. especially in the regression
setting, why is ∥ · ∥2a good evaluation metric for testing (not just training)?
8.5 summary
in this chapter, we have discussed the basic principles of parameter estimation. the three
building blocks are:
likelihood fx|θ(x|θ): the pdf that we observe samples xconditioned on the un-
known parameter θ. in the frequentist world, θis a deterministic quantity. in the
bayesian world, θis random and so it has a pdf.
prior fθ(θ): the pdf of θ. the prior fθ(θ) is used by all bayesian computation.
posterior fθ|x(θ|x): the pdf that the underlying parameter is θ=θgiven that we
have observed x=x.
the three building blocks give us several strategies to estimate the parameters:
maximum likelihood (ml) estimation: maximize fx|θ(x|θ).
maximum a posteriori (map) estimation: maximize fθ|x(θ|x).
minimum mean-square estimation (mmse): minimize the mean squared error, which
is equivalent to finding the mean of fθ|x(θ|x).
as discussed in this chapter, no single estimation strategy is universally “better” because
one needs to specify the optimality criterion. if the goal is to minimize the mean squared
error, then the mmse estimator is the optimal strategy. if the goal is to maximize the
likelihood without assuming any prior knowledge, the ml estimator would be the optimal
strategy. it may appear that if we knew the ground truth parameter θ∗we could minimize
the distance between the estimated parameter θand the true value θ∗. if the parameter
is a scalar, this will work. however, if the parameter is a vector, the noise of the distance
becomes an issue. for example, if one cares about the mean absolute error (mae), the
optimal estimator would be the median of the posterior distribution instead of the mean of
the posterior in the mmse case. therefore, it is the end user’s responsibility to specify the
optimality criterion.
whenever we consider parameter estimation, we tend to think that it is about estimat-
ing the model parameters, such as the mean of a gaussian pdf. while in many statistics
problems this is indeed the case, parameter estimation can be much broader if we link it
with regression. specifically, a regularized linear regression problem can be formulated as a
map estimation
θ∗= argmax
θ∥xθ−y∥2
|{z}
−logfx|θ(x|θ)+λr(θ)|{z}
−logfθ(θ), (8.77)
for some regularization r(θ), which is also the negative log of the prior. expressed in this
way, we recognize that the map estimation can be used to recover signals. for example, we
5348.6. references
can model xas a linear degradation process of certain imaging systems. then solving the
map estimation is equivalent to finding the best signal explaining the degraded observation
using the posterior as the criterion. there is rich literature dealing with solving map esti-
mation problems similar to these in subjects such as computational imaging, communication
systems, remote sensing, radar engineering, and recommendation systems, to name a few.
8.6 references
basic
8-1 dimitri p. bertsekas and john n. tsitsiklis, introduction to probability , athena sci-
entific, 2nd edition, 2008. chapter 8 and chapter 9.
8-2 alberto leon-garcia, probability, statistics, and random processes for electrical en-
gineering , prentice hall, 3rd edition, 2008. chapter 6 and chapter 8.
8-3 athanasios papoulis and s. unnikrishna pillai, probability, random variables and
stochastic processes , mcgraw-hill, 4th edition, 2001. chapter 8.
8-4 henry stark and john w. woods, probability and random processes with applications
to signal processing , prentice hall, 3rd edition, 2002. chapter 5.
8-5 todd k. moon and wynn c. stirling, mathematical methods and algorithms for signal
processing , prentice-hall, 2000. chapter 12.
theoretical analysis
8-6 h. vincent poor, an introduction signal detection and estimation , springer, 1998.
8-7 steven m. kay, fundamentals of statistical signal processing: estimation theory ,
prentice-hall, 1993.
8-8 bernard c. levy, principles of signal detection and parameter estimation , springer,
2008.
8-9 athanasios papoulis and s. unnikrishna pillai, probability, random variables and
stochastic processes , mcgraw-hill, 2001. chapter 8.
8-10 larry wasserman, all of statistics: a concise course in statistical inference , springer,
2010.
8-11 erich l. lehmann, elements of large-sample theory , springer, 1999. chapter 7.
8-12 george casella and roger l. berger statistical inference , duxbury, 2002. chapter 7.
535chapter 8. estimation
machine-learning
8-13 christopher bishop, pattern recognition and machine learning , springer, 2006. chap-
ter 2 and chapter 3.
8-14 richard o. duda, peter e. hart and david g. stork, pattern classification , wiley
2001. chapter 3.
8.7 problems
exercise 1.
letx1, . . . , x nbe a sequence of i.i.d. bernoulli random variables with p[xn= 1] = θ.
suppose that we have observed x1, . . . , x n.
(a) show that the pmf of xnispxn(xn|θ) =θxn(1−θ)1−xn. find the joint pmf
px1,...,x n(x1, . . . , x n).
(b) find the maximum likelihood estimate bθ, i.e.,
bθml= argmax
θlogpx1,...,x n(x1, . . . , x n).
express your answer in terms of x1, . . . , x n.
(c) let θ= 1/2. use chebyshev’s inequality to find an upper bound for p[|bθml−θ|>0.1].
exercise 2.
letyn=θ+wnbe the output of a noisy channel where the input is a scalar θand
wn∼ n(0,1) is an i.i.d. gaussian noise. suppose that we have observed y1, . . . , y n.
(a) express the pdf of ynin terms of θandyn. find the joint pdf of y1, . . . , y n.
(b) find the maximum likelihood estimate bθml. express your answer in terms of y1, . . . , y n.
(c) find e[bθml].
exercise 3.
letx1, . . . , x nbe a sequence of i.i.d. gaussian random variables with unknown mean θ1
and variance θ2. suppose that we have observations x1, . . . , x n.
(a) express the pdf of xnin terms of xn,θ1andθ2. find the joint pdf of x1, . . . , x n.
(b) find the maximum likelihood estimates of θ1andθ2.
5368.7. problems
exercise 4.
in this problem we study a single-photon image sensor. first, recall that photons arrive
according to a poisson distribution, i.e., the probability of observing kphotons is
p[y=k] =λke−λ
k!,
where λis the (unknown) underlying photon arrival rate. when photons arrive at the single-
photon detector, the detector generates a binary response “1” when one or more photons
are detected, and “0” when no photon is detected.
(a) let bbe the random variable denoting the response of the single-photon detector.
that is,
b=(
1, y ≥1,
0, y = 0.
find the pmf of b.
(b) suppose we have obtained tindependent measurements with realizations b1=b1,
b2=b2, ...,bt=bt. show that the underlying photon arrival rate λcan be estimated
by
λ=−log 
1−pt
t=1bt
t!
.
(c) get a random image from the internet and turn it into a grayscale array with values
between 0 and 1. write a matlab or python program to synthetically generate a
sequence of t= 1000 binary images. then use the previous result to reconstruct the
grayscale image.
exercise 5.
consider a deterministic vector s∈rdand random vectors
fy|θ(y|θ) = gaussian( sθ,σ),
fθ(θ) = gaussian( µ, σ2).
(a) show that the posterior distribution is given by
fθ|y(θ|y) = gaussian( m, q2), (8.78)
where
d2=stς−1s,
m=
d2+1
σ2−1
stς−1y+µ
σ2
,
q2=1
d2+1
σ2.
(b) show that the mmse estimate bθmmse (y) is given by
bθmmse (y) =σ2stς−1y+µ
σ2d2+ 1. (8.79)
537chapter 8. estimation
(c) show that the mse is given by
mse(θ ,bθmmse (y)) =1
d2+1
σ2. (8.80)
what happens when σ→0?
(d) give an interpretation of d2. what happens when d2→0 and when d2→ ∞ ?
exercise 6.
prove the following identity:
σθθσθx
σxθσxx−1
=(σθθ−σθxς−1
xxσxθ)−1−(σθθ−σθxς−1
xxσxθ)−1σθxς−1
xx
(σxx−σxθς−1
θθσθx)−1σxθς−1
θθ (σxx−σxθς−1
θθσθx)−1
.
hint: you can perform reverse engineering by checking whether the product of the left-hand
side and the right-hand side would give you the identity matrix.
exercise 7.
letx1,x2,x3andx4be four i.i.d. poisson random variables with mean θ= 4. find the
mean and variance of the following estimators bθ(x) for θand determine whether they are
biased or unbiased.
bθ(x) = (x1+x2)/2
bθ(x) = (x3+x4)/2
bθ(x) = (x1+ 2x2)/3
bθ(x) = (x1+x2+x3+x4)/4
exercise 8.
letx1, . . . , x nbe i.i.d. random variables with a uniform distribution of [0 , θ]. consider the
following estimator:
bθ(x) = max( x1, . . . , x n). (8.81)
(a) show that the pdf of bθ is fbθ(θ) =n[fx(x)]n−1fx(x), where fxandfxare re-
spectively the pdf and cdf of xn.
(b) show that bθ is a biased estimator.
(c) find the variance of bθ. is it a consistent estimator?
(d) find a constant cso that cbθ is unbiased.
exercise 9.
letx1, . . . , x nbe i.i.d. gaussian random variables with unknown mean θand known
variance σ= 1.
5388.7. problems
(a) show that the log-likelihood function is
logl(θ|x) =−n
2log(2π)−1
2nx
n=1(xn−θ)2. (8.82)
(b) let x2=1
npn
n=1x2
nandx=1
npn
n=1xn. show that x2>(x)2if and only ifpn
n=1(xn−θ)2≥0 for all θ.
(c) use python to plot the function log l(θ|x), when x= 2 and x2= 1.
exercise 10.
letx1, . . . , x nbe i.i.d. uniform random variables over the interval [0 , θ].
lett= max( x1, . . . , x n).
(a) consider the estimator h(x) =1
npn
n=1xn. ish(·) an unbiased estimator?
(b) consider the estimator g(x) =1
npn
n=1xn. isg(·) an unbiased estimator?
(c) show that
e[g(x)|t=t] =n+ 1
n
t.
(d) let bg(x) =e[g(x)|t] = n+1
n
t. show that
e[bg(x)2] =(n+ 1)2
n(n+ 2)
θ2.
(e) show that
e[(bg(x)−θ)2] =1
n(n+ 2)
θ2.
exercise 11.
the kullback-leibler divergence between two distributions p1(x) and p2(x) is defined as
kl(p1∥p2) =z
p1(x) logp1(x)
p2(x)dx. (8.83)
suppose we approximate p1using a distribution p2. let us choose p2= gaussian( µ,σ).
show that µandς, which minimize the kl divergence, are such that
µ=ex∼p1(x)[x] and σ=ex∼p1(x)[(x−µ)(x−µ)t].
exercise 12.
(a) recall that the trace operator is defined as tr[ a] =pd
i=1[a]i,i. prove the matrix
identity
xtax= tr[axxt], (8.84)
where a∈rd×d.
539chapter 8. estimation
(b) show that the likelihood function
p(d |σ) =ny
n=11
(2π)d/2|σ|1/2expn
−1
2(xn−µ)tς−1(xn−µ)o
(8.85)
can be written as
p(d|σ) =1
(2π)nd/2|σ−1|n/2exp(
−1
2tr"
σ−1nx
n=1(xn−µ)(xn−µ)t#)
.(8.86)
(c) let a=σ−1bσml, and λ1, ..., λ dbe the eigenvalues of a. show that the result from
part (b) leads to
p(d|σ) =1
(2π)nd/2|bσml|n/2 dy
i=1λi!n/2
exp(
−n
2dx
i=1λi)
. (8.87)
hint: for matrix awith eigenvalues λ1, ..., λ d, tr[a] =pd
i=1λi.
(d) find λ1, . . . , λ dsuch that equation (8.87) is maximized.
(e) with the choice of λigiven in (d), derive the ml estimate bσml.
(f) what would be the alternative way of finding bσml? you do not need to prove it. just
briefly describe the idea.
(g)bσmlis abiased estimate of the covariance matrix because e[bσml]̸=σ. can you
suggest an unbiased estimate bσunbias such that e[bσunbias ] =σ? you don’t need to
prove it. just state the result.
540chapter 9
confidence and hypothesis
in chapters 7 and 8 we learned about regression and estimation, which allow us to determine
the underlying parameters of our statistical models. after obtaining the estimates, we would
like to quantify the accuracy of the estimates and draw statistical conclusions. additionally,
we would like to understand the confidence of these estimates along with their statistical
significance . this chapter presents a few principles that involve analyzing the confidence of
the estimates and conducting hypothesis testing. there are two main questions that we will
address:
how good is our estimate? this is a fundamental question about the estimator bθ, a
random variable with a pdf, a mean, and a variance.1the estimator we construct
today may be different from the estimator we construct tomorrow due to variations in
the observed data. therefore, the quality of the estimator depends on the randomness
and the number of samples used to construct it. to measure the quality of the estimator
we need to introduce an important concept known as the confidence .
is there statistical significance? suppose that we ran a campaign and observed that
there is a change in the statistics. on what basis do we claim that the change is
statistically significant? how should the cutoff be determined? if we claim that a
result is statistically significant but there is no significance in reality, how much error
will we suffer? these questions are the subjects of hypothesis testing .
these two principal questions are critical for modern data science. if they are not properly
answered, our statistical conclusions could potentially be flawed. a toy example:
imagine that you are developing a covid-19 vaccine. you tested the vaccine on three
patients, and all of them show positive responses to the vaccine. you felt excited because
your vaccine has a 100% success rate. you submit your vaccine application to fda. within
1 second your application is rejected. why? the answer is obvious. you only have three
testing samples. how reliable can these three samples be?
while you are laughing at this toy example, it raises deep statistical questions. first,
why are three samples not enough? well, it is because the variance of the estimator can
potentially be huge. more samples are better because if the estimator is the sample average of
the individual responses, the estimator will behave like a gaussian according to the central
1not all random variables have a well-defined pdf, mean, and variance. e.g., a cauchy variable does
not have a mean.
541chapter 9. confidence and hypothesis
limit theorem. the variance of this gaussian will diminish as we have more samples.
therefore, if we want to control the variance of the estimator, we need more samples. second,
even if we have many samples, how confident is this estimator with respect to the unknown
population parameter? note that the population parameter is unknown, and so we cannot
measure things such as the mean squared error. we need a tool to report confidence. third,
for simple estimators such as the sample average, we can approximate it by a gaussian .
however, if the estimator is more complicated, e.g., the sample median, how do we estimate
the variance and the confidence? fourth, suppose that we have expanded the vaccine test
to, say, 951 patients, and we have obtained some statistics. to what extent can we declare
that the vaccine is effective? we need a decision rule that turns the statistics into a binary
decision. finally, even if we declare that the vaccine is effective with a confidence of 95%,
what about the remaining 5%? what if we want to push the confidence to 99%? what is
the trade-off?
as you can see, these questions are the recurring themes of all data science problems.
no matter if you are developing a medical diagnostic system, a computer vision algorithm,
a speech recognition system, a recommendation system, a search engine, stock forecast,
fraud detection, or robotics controls, you need to answer these questions. this chapter will
introduce useful concepts related to data analysis in the form of five basic principles :
1.confidence interval (section 9.1). a confidence interval is a random interval that
includes the true parameter. we will discuss how a confidence interval is constructed
and the correct way to interpret the confidence interval.
2.bootstrapping (section 9.2). when constructing the confidence interval, we need the
variance of the estimator. however, since we do not know the true distribution, we
need an alternative way to estimate the variance. bootstrapping is designed for this
purpose.
3.hypothesis testing (section 9.3). many statistical tasks require a binary decision at
the end, e.g., there is a disease versus there is no disease. hypothesis testing is a
principle for making a systematic decision with statistical guarantees.
4.neyman-pearson decision (section 9.4). the simple hypothesis testing procedure has
many limitations that can only be resolved if we understand a more general framework.
we will study such a framework, called the neyman-pearson decision rule.
5.roc and pr curves (section 9.5). no decision rule is perfect. there is always a
trade-off between how much we can detect and how much we will miss. the receiver
operating characteristic (roc) curve and the precision-recall (pr) curve can give us
more insight into this trade-off. we will establish the equivalence between the roc
and the pr curve and correct any misconceptions about them.
after reading this chapter, we hope that you will be able to apply these principles
to your favorite data analysis problems correctly. with these principles, you can tell your
customers or bosses the statistical significance of your conclusions. you will also be able to
help your friends understand the many misconceptions that they may find on the internet.
5429.1. confidence interval
9.1 confidence interval
the first topic we discuss in this chapter is the confidence interval . at a high level, the
confidence interval tells us the quality of our estimator with respect to the number of sam-
ples. we begin this section by reviewing the randomness of an estimator. then we develop
the concept of the confidence interval. we discuss several methods for constructing and
interpreting these confidence intervals.
9.1.1 the randomness of an estimator
imagine that we have a dataset x={x1, . . . , x n}, where we assume that xnare i.i.d.
copies drawn from a distribution fx(x;θ). we want to construct an estimator bθ of θfrom
the dataset x. for example, if fxis a gaussian distribution with an unknown mean θ, we
would like to estimate θusing the sample average bθ. in statistics, an estimator bθ is also
known as a statistic , which is constructed from the samples. in this book we use the terms
“estimator” and “statistic” interchangeably. written as equations, an estimator is a function
of the samples:
bθ|{z}
estimator=g(x1, . . . , x n)|{z }
function of x,
where gis a function that takes the samples x1, . . . , x nand returns a random variable bθ.
for example, the sample average
bθ =1
nnx
n=1xn
|{z}
g(x1,...,x n)
is an estimator because it is computed by summing the samples x1, . . . , x nand dividing it
byn.
what is an estimator?
an estimator bθ is a function of the samples x1, . . . , x n:
bθ =g(x1, . . . , x n). (9.1)
bθ is a random variable. it has a pdf, cdf, mean, variance, etc.
by construction, bθ is a random variable because it is a function of the random samples.
therefore, bθ has its own pdf, cdf, mean, variance, etc. since bθ is a random variable,
we should report both the estimator’s value and the estimator’s confidence when reporting
its performance. the confidence measures the quality of bθ when compared to the true
parameter θ. it provides a measure of the reliability of the estimator bθ. ifbθ fluctuates a
great deal we may not be confident of our estimates. let’s consider the following example.
543chapter 9. confidence and hypothesis
example 9.1 . a class of 1000 students took a test. the distribution of the score is
roughly a gaussian with mean 50 and standard deviation 20. a teaching assistant
was too lazy to calculate the true population mean. instead, he sampled a subset of 5
scores listed as follows:
student id 1 2 3 4 5
scores 11 97 1 78 82
he calculated the average, which is 53.8. this is a very good estimate of the class
average (which is 50). what is wrong with his procedure?
solution . he was just lucky. it quite possible that if he sampled another 5 scores, he
would get something very different. for example, if he looks at the 11 to 15 student
scores, he could get:
student id 11 12 13 14 15
scores 44 29 19 27 15
in this case the average is 26.8.
both 53.8 and 26.8 are legitimate estimates, but they are the random realizations
of a random variable bθ. this bθ has a pdf, cdf, mean, variance, etc. it may be
misleading to simply report the estimated value from a particular instant, so the
confidence of the estimator must be specified.
distributions of bθ. we next discuss the distribution of bθ.figure 9.1 illustrates several
key ideas. suppose that the population distribution fx(x) is a mixture of two gaussians.
letθbe the mean of this distribution (somewhere between the two peak locations). we
sample n= 50 data points x1, . . . , x nfrom this distribution. however, the 50 data points
we sample today could differ from the 50 data points we sample tomorrow. if we compute
the sample average from each of these finite-sample distributions, we will obtain a set of
sample averages bθ. notably, we have a setofbθ because today we have one bθ and tomorrow
we have another bθ. by plotting the histogram of the sample averages bθ, we will have a
distribution.
the histogram of bθ depends on several factors. according to central limit theorem,
the shape of fbθ(θ) is a gaussian because bθ is the average of ni.i.d. random variables.
ifbθ is not the average of i.i.d. random variables, the shape is not necessarily a gaussian.
this results in additional complications, so we will discuss some tools for dealing with this
problem. the spread of the sample distribution is mainly driven by the number of samples
we have in each subdataset. as you can imagine, the more samples we have in a subdataset
the more accurate the distribution. thus you will have a more accurate sample average. the
fluctuation of the sample average will also be smaller.
before we continue, let’s summarize the randomness of bθ:
what is the randomness of bθ?
bθ is generated from a finite-sample dataset. each time we draw a finite-sample
dataset, we introduce randomness.
5449.1. confidence interval
figure 9.1: pictorial illustration of the randomness of the estimator bθ. given a population, our datasets
are usually a subset of the population. computing the sample average from these finite-sample distribu-
tions introduces the randomness to bθ. if we plot the histogram of the sample averages, we will obtain
a distribution. the mean of this distribution is the population mean, but there is a nontrivial amount of
fluctuation. the purpose of the concept of confidence interval is to quantify this fluctuation.
ifbθ is the sample average, the pdf is (roughly) a gaussian. if bθ is not a sample
average, the pdf is not necessarily a gaussian.
the spread of the fluctuation depends on the number of samples in each sub-
dataset.
9.1.2 understanding confidence intervals
the confidence interval is a probabilistic statement about bθ. instead of studying bθ as a
point , we construct an interval
i=h
bθ−ϵ,bθ +ϵi
, (9.2)
for some ϵto be determined. note that this interval is a random interval : if we have a
different realization of bθ, we will have a different i. we call itheconfidence interval for
the estimator bθ.
given this random interval, we ask: what is the probability that iincludes θ? that
means that we want to evaluate the probability
p[θ∈ i] =ph
bθ−ϵ≤θ≤bθ +ϵi
.
we emphasize that the randomness in this probability is caused by bθ, not θ. this is because
the interval ichanges when we conduct a different experiment to obtain a different bθ. the
545chapter 9. confidence and hypothesis
situation is similar to that illustrated on the left-hand side of figure 9.2 . the confidence
interval ichanges but the true parameter θis fixed.
figure 9.2: confidence interval is the random interval i= [bθ−ϵ,bθ +ϵ], not the deterministic interval
[θ−ϵ, θ+ϵ]. the random interval in the former case does not require any knowledge about the true
parameter θ, whereas the latter requires θ. by claiming a 95% confidence interval, we say that there
is 95% chance that the random interval will include the true parameter. so if you have 100 random
realizations of the confidence intervals, then 95 on average will include the true parameter.
confidence intervals can be confusing. often the confusion arises because of the fol-
lowing identity:
ph
bθ−ϵ≤θ≤bθ +ϵi
=ph
−ϵ≤θ−bθ≤ϵi
=ph
−ϵ−θ≤ −bθ≤ϵ−θi
=ph
θ−ϵ≤bθ≤θ+ϵi
. (9.3)
although the values of the two probabilities are the same, the two events are interpreted
differently. the right-hand side of figure 9.2 illustrates p[θ−ϵ≤bθ≤θ+ϵ]. the interval
[θ−ϵ, θ+ϵ] is fixed. what is the probability that the estimator bθ lies within this deterministic
interval? to find this probability, we need to know the true parameter θ, which is not
available. by contrast, the other probability p[bθ−ϵ≤θ≤bθ +ϵ] does not require any
knowledge about the true parameter θ. what is the probability that the true parameter is
included inside the random interval? if the probability is high, we say that there is a good
chance that our confidence interval will contain the true parameter. this is observed in the
left-hand side of figure 9.2 .
in practice we often set p[bθ−ϵ≤θ≤bθ +ϵ] to be greater than a certain confidence
level, say 95%, and then we determine ϵ. once we have determined ϵ, we can claim that
5469.1. confidence interval
with 95% probability the interval [ bθ−ϵ,bθ +ϵ] will include the unknown parameter θ. we
do not need to know θat any point in this process.
to make this more general, we define 1 −αas the confidence level for some parame-
terα. for example, if we would like to have a 95% confidence level, we set α= 0.05. then
the probability inequality
ph
bθ−ϵ≤θ≤bθ +ϵi
≥1−α (9.4)
tells us that there is at least a 95% chance that the random interval i= [bθ−ϵ,bθ +ϵ] will
include the true parameter θ. in this case we say that iis a “ 95% confidence interval ”.
what is a 95% confidence interval?
it is a random interval [ bθ−ϵ,bθ +ϵ] such that there is 95% probability for it to
include the true parameter θ.
it is not the deterministic interval [ θ−ϵ, θ+ϵ], because we never know θ.
let’s consider the following two examples to clarify any misconceptions.
example 9.2 . after analyzing the life expectancy of people in the united states, it
was concluded that the 95% confidence interval is (77.8, 79.1) years old. is the following
claim valid?
about 95% of the people in the united states have a life expectancy between 77.8
years old and 79.1 years old.
solution . no. the confidence interval tells us that with 95% probability the random
interval (77 .8,79.1) will include the true average. we emphasize that (77 .8,79.1) is
random because it is constructed from a small set of data points. if we survey another
set of people we will have another interval.
since we do not know the true average, we do not know the percentage of people
whose life expectancy is between 77.8 years old and 79.1 years old. it could be that the
true average is 80 years old, which is out of the range. it could also be that the true
average is 77.9 years old, which is within the range, but only 10% of the population
may have life expectancy in (77 .8,79.1).
example 9.3 . after studying the sat scores of 1000 high school students, it was
concluded that the 95% confidence interval is (1134, 1250) points. is the following
claim valid?
there is a 95% probability that the average sat score in the population is in the
range 1134 and 1250.
solution . yes, but it can be made clearer. the average sat score in the population
remains unknown. it is a constant and it is deterministic, so there is no probability
associated with it. a better way to say this is: “there is 95% probability that the
547chapter 9. confidence and hypothesis
random interval 1134 and 1250 will include the average sat score.” we emphasize
that the 95% probability is about the random interval, not the unknown parameter.
9.1.3 constructing a confidence interval
let’s consider an example. suppose that we have a set of i.i.d. observations x1, . . . , x n
that are gaussians with an unknown mean θand a known variance σ2. we consider the
maximum-likelihood estimator, which is the sample average:
bθ =1
nnx
n=1xn.
our goal is to construct a confidence interval.
figure 9.3: conceptual illustration of how to construct a confidence interval. starting with the pop-
ulation, we draw random subsets. each random subset gives us an estimator, and correspondingly an
interval.
before we consider the equations, let’s look at a graph illustrating what we want to
achieve. figure 9.3 shows a population distribution, which is a gaussian in this example.
we draw nsamples from the gaussian to construct a random subset. based on this random
subset we construct the estimator bθ. since this estimator is based on the particular random
subset we have, we can follow the same approach by drawing another random subset. to
differentiate the estimators constructed by the different random subsets, let’s call the esti-
mators bθ(1)andbθ(2), respectively. for each estimator we construct an interval [ bθ−ϵ,bθ+ϵ]
to obtain two different intervals:
i1= [bθ(1)−ϵ,bθ(1)+ϵ] and i2= [bθ(2)−ϵ,bθ(2)+ϵ].
5489.1. confidence interval
if we can determine ϵ, we have found the confidence interval.
we can determine the confidence interval by observing the histogram of bθ, which in
our case is the histogram of the sample average, since the histogram of bθ is well-defined,
especially if we are looking at the sample average. the histogram of the sample average is a
gaussian because the average of ni.i.d. gaussian random variables is gaussian. therefore,
the width of this gaussian is determined by the answer to this question:
for what ϵcan we cover 95% of the histogram of bθ?
to find the answer, we set up the following probability inequality:
p
|bθ−e[bθ]|q
var[bθ]≤ϵ
≥1−α.
this probability says that we want to find an ϵsuch that the majority of bθ is living close
to its mean. the level 1 −αis our confidence level, which is typically 95%. equivalently, we
letα= 0.05.
in the above equation, we can define the quotient as
bzdef=bθ−e[bθ]q
var[bθ].
we know that bzis a zero-mean unit-variance gaussian because it is the standardized vari-
able. [note: not all normalized variables are gaussian, but if bθ is a gaussian the normalized
variable will remain a gaussian.] thus, the probability inequality we are looking at is
ph
|bz| ≤ϵi
|{z}
two tails of a standard gaussian≥ 1−α.
the pdf of bzis shown in figure 9.4 . as you can see, to achieve 95% confidence we need
to pick an appropriate ϵsuch that the shaded area is less than 5%.
-3 -2.5 -2 -1.5 -1 -0.5 0 0.5 1 1.5 2 2.5 300.050.10.150.20.250.30.350.4
figure 9.4: pdf of the random variable bz= (bθ−e[bθ])/q
var[bθ]. the shaded area denotes the
α= 0.05confidence level.
549chapter 9. confidence and hypothesis
sincep[bz≤ϵ] is the cdf of a gaussian, it follows that
p[|bz| ≤ϵ] =p[−ϵ≤bz≤ϵ]
=p[bz≤ϵ]−p[bz≤ −ϵ]
= φ ( ϵ)−φ (−ϵ).
using the symmetry of the gaussian, it follows that φ ( −ϵ) = 1−φ (ϵ) and hence
p[|bz| ≤ϵ] = 2φ ( ϵ)−1.
equating this result with the probability inequality p[|bz| ≤ϵ]≥1−α, we have that
ϵ≥φ−1
1−α
2
.
the remainder of this problem is solvable on a computer. on matlab, we can call
icdf to compute the inverse cdf of a standard gaussian. on python, the command is
stats.norm.ppf . the commands are as shown below.
% matlab code to compute the width of the confidence interval
alpha = 0.05;
mu = 0; sigma = 1; % standard gaussian
epsilon = icdf(’norm’,1-alpha/2,mu,sigma)
# python code to compute the width of the confidence interval
import scipy.stats as stats
alph = 0.05;
mu = 0; sigma = 1; # standard gaussian
epsilon = stats.norm.ppf(1-alph/2, mu, sigma)
print(epsilon)
if everything is done properly, we see that for a 95% confidence level ( α= 0.05) the corre-
sponding ϵisϵ= 1.96.
after determining ϵ, it remains to determine e[bθ] and var[ bθ] in order to complete the
probability inequality. to this end, we note that
e[bθ] =e"
1
nnx
n=1xn#
=θ,
var[bθ] = var"
1
nnx
n=1xn#
=σ2
n,
if we assume that the population distribution is gaussian( θ, σ2), where θis unknown but σ
is known. substituting these into the probability inequality, we have that
p
|bθ−e[bθ]|q
var[bθ]≤ϵ
=p
bθ−ϵσ√
n≤θ≤bθ +ϵσ√
n
=p
bθ−1.96σ√
n≤θ≤bθ + 1 .96σ√
n
,
5509.1. confidence interval
where we let ϵ= 1.96 for a 95% confidence level. therefore, the 95% confidence interval is

bθ−1.96σ√
n,bθ + 1 .96σ√
n
. (9.5)
as you can see, we do not need to know the value of θat any point of the derivation because
the confidence interval in equation (9.5) does not involve θ. this is an important difference
with the other probability p[θ−ϵ≤bθ≤θ+ϵ], which requires θ.
how to construct a confidence interval
compute the estimator bθ.
determine the width of the confidence interval ϵby inspecting the confidence
level 1 −α. ifbθ is gaussian, then ϵ= φ−1(1−α
2).
ifbθ is not a gaussian, replace the gaussian cdf by the cdf of bθ.
the confidence interval is [ bθ−ϵ,bθ +ϵ].
9.1.4 properties of the confidence interval
some important properties of the confidence interval are listed below.
probability of bθis the same as probability of bz. first, the two random variables bθ
andbzhave a one-to-one correspondence. we proved the following in chapter 6:
ifbθ∼gaussian( θ,σ2
n), then
bzdef=bθ−θ
σ/√
n∼gaussian(0 ,1). (9.6)
for example, if bθ∼gaussian( θ,σ2
n) with n= 1, θ= 1 and σ= 2, then a 95%
confidence level is
0.95≈p[−1.96≤bz≤1.96], (bzis within 1.96 std from bz’s mean)
=p[−1.96≤bθ−θ
σ/√
n≤1.96]
=p
θ−1.96σ√
n≤bθ≤θ+ 1.96σ√
n
=p[−2.92≤bθ≤4.92]. (bθ is within 1.96 std from bθ’s mean)
note that while the range for bzis different from the range for bθ, they both return the
same probability. the only difference is that bθ is constructed before the normalization
andbzis constructed after the normalization.
551chapter 9. confidence and hypothesis
standard error . in this estimation problem we know that bθ is the sample average. we
assume that the mean θis unknown but the variance var[ bθ] is known. the standard
deviation of bθ is called the standard error :
se=q
var[bθ] =σ√
n. (9.7)
critical value . the value 1 .96 in our example is often known as the critical value . it
is defined as
zα= φ−1
1−α
2
. (9.8)
thezαvalue gives us a multiplier applied to the standard error that will result in a
value within the confidence interval. this is because, by the definition of the confidence
interval, the interval is

bθ−1.96σ√
n,bθ + 1 .96σ√
n
=h
bθ−zαse,bθ +zαsei
margin of error . the margin of error is defined as
margin of error = zασ√
n. (9.9)
the margin of error is also the width of the confidence interval. as the name implies,
the margin of error tells us how much error the confidence interval includes when
predicting the population parameter.
practice exercise 9.1 . suppose that the number of photos a facebook user uploads
per day is a random variable with σ= 2. in a set of 341 users, the sample average is
2.9. find the 90% confidence interval of the population mean.
solution . we set α= 0.1. the zα-value is
zα= φ−1
1−α
2
= 1.6449.
the 90% confidence interval is then

bθ−1.642√
341,bθ + 1 .642√
341
= [2.72,3.08].
therefore, with 90% probability, the interval [2 .72,3.08] includes the population mean.
example 9.4 . professional cyber-athletes have a standard deviation of σ= 73 .4
actions per minute. if we want to estimate the average actions per minute of the
population, how many samples are needed to obtain a margin of error <20 at 90%
confidence?
5529.1. confidence interval
solution . with a 90% confidence level, the zα-value is
zα= φ−1
1−α
2
= φ−1(0.95) = 1 .645.
the margin of error is 20. so we have
zασ√
n= 20.
moving around the terms gives us
n≥
zασ
202
= 36.45.
therefore, we need at least n= 37 samples to ensure a margin of error of <20 at a
90% confidence level.
figure 9.5: relationships between the standard error se, the zαvalue, and the margin of error. the
confidence level αis the area under the curve for the tails of each pdf.
the concepts of standard error se, thezαvalue, and the margin of error are summarized
infigure 9.5 . the left-hand side is the pdf of bz. it is the normalized random variable,
which is also the standard gaussian. the right-hand side is the pdf of bθ, the unnormalized
random variable. the zαvalue is located in the bz-space. it defines the range of bzin the
pdf within which we are confident about the true parameter. the corresponding value
in the bθ-space is the margin of error . this is found by multiplying zαwith the standard
deviation of bθ, known as the standard error . correspondingly, in the bz-space the standard
deviation is the unity.
two further points about the confidence interval should be mentioned:
number of samples n. the confidence interval is a function of n. as we increase the
number of samples, the distribution of the estimator bθ becomes narrower. specifically,
ifbθ follows a gaussian distribution
bθ∼gaussian
θ,σ2
n
,
thenbθp→θasn→ ∞ .figure 9.6 illustrates a few examples of bθ as ngrows. in the
limit when n→ ∞ , we observe that the interval becomes

bθ−1.96σ√
n,bθ + 1 .96σ√
n
−→h
bθ,bθi
=bθ.
553chapter 9. confidence and hypothesis
in this case, the statement θ∈h
bθ−1.96σ√
n,bθ + 1 .96σ√
ni
becomes θ=bθ. that
means the estimator bθ returns the correct true parameter θ. of course, it is possible
thate[bθ]̸=θ, i.e., the estimator is biased. in that case, having more samples will
approach another estimate that is not θ.
-1 -0.75 -0.5 -0.25 0 0.25 0.5 0.75 100.511.522.533.54
n = 10
n = 25
n = 100
figure 9.6: the pdf of bθas the number of samples ngrows. here, we assume that xnare i.i.d.
gaussian random variables with mean θ= 0and variance σ2= 1.
distribution of bz. when defining the confidence interval we constructed an interme-
diate variable
bz=bθ−θ
σ/√
n.
since xn’s are i.i.d. gaussian, it follows that zis also gaussian. this gives us a way
to calculate the probability using the standard gaussian table. what happens when
xn’s are notgaussian? the good news is that even if xn’s are not gaussian, for
sufficiently large n, the random variable bθ is more or less gaussian, because of the
central limit theorem. therefore, even if xn’s are not gaussian we can still use the
gaussian probability table to construct αandϵ.
9.1.5 student’s t-distribution
in the discussions above, we estimate the population mean θusing the estimator bθ. the
assumption was that the variance σ2was known a priori and hence is fixed. in practice,
however, there are many situations where σ2is not known. thus we not only need to use
the mean estimator bθ but also the variance estimator bs, which can be defined as
bs2def=1
n−1nx
n=1(xn−bθ)2,
where bθ is the estimator of the mean. what is the confidence interval for bθ?
for a confidence interval to be valid, we expect it to take the form of
i="
bθ−zαbs√
n,bθ +zαbs√
n#
,
5549.1. confidence interval
which is essentially the confidence interval we have just derived but with σreplaced by bs.
however, there is a problem with this. when we derive the confidence interval assuming a
known σ, the zαvalue is determined by checking the standard gaussian
bz=bθ−θ
σ/√
n,
which gives us zα= φ−1(1−α/2). the whole derivation is based on the fact that bzis a
standard gaussian. now that we have replaced σbybs, the new random variable
tdef=bθ−θ
bs/√
n(9.10)
isnota standard gaussian.
it turns out that the distribution of tis student’s t-distribution with n−1 degrees
of freedom. the pdf of student’s t-distribution is given as follows.
definition 9.1. ifxis a random variable following student’s t-distribution ofν
degrees of freedom, then the pdf of xis
fx(x) =γ ν+1
2
√νπγ ν
2
1 +x2
ν−ν+1
2
. (9.11)
we may compare student’s t-distribution with the gaussian distribution. figure 9.7 shows
the standard gaussian and several tdistributions with ν=n−1 degrees of freedom. note
that student’s t-distribution has a similar shape to the gaussian but it has a heavier tail.
-5 -4 -3 -2 -1 0 1 2 3 4 500.050.10.150.20.250.30.350.4
gaussian(0,1)
t-dist, n = 11
t-dist, n = 3
t-dist, n = 2
figure 9.7: the pdf of student’s t-distribution with ν=n−1degrees of freedom.
since t=bθ−θ
bs/√
nis at-random variable, to determine the zαvalue we can follow the
same procedure by considering the cdf of t. let the cdf of the student’s t-distribution
with νdegrees of freedom be
ψν(z) = cdf of xatz.
555chapter 9. confidence and hypothesis
if we want p[|t| ≤zα] = 1−α, it follows that
zα= ψ−1
ν
1−α
2
. (9.12)
therefore, the new confidence interval, assuming an unknown bs, is
i="
bθ−zαbs√
n,bθ +zαbs√
n#
,
with zαdefined in equation (9.12), using ν=n−1.
practice exercise 9.2 . a survey asked n= 14 people for their rating of a movie. as-
sume that the mean estimator is bθ and the variance estimator is bs. find the confidence
interval.
solution . if we use student’s t-distribution, it follows that
zα= ψ−1
13
1−α
2
= 2.16,
where the degrees of freedom are ν= 14−1 = 13. thus the confidence interval is
i="
bθ−2.16bs√
n,bθ + 2 .16bs√
n#
.
the matlab and python codes to report the zαvalue of a student’s t-distribution
are shown below. they are both called through the inverse cdf function. in matlab it
isicdf, and in python it is stats.t.ppf .
% matlab code to compute the z_alpha value of t distribution
alpha = 0.05;
nu = 13;
z = icdf(’norm’,1-alpha/2,nu)
# python code to compute the z_alpha value of t distribution
import scipy.stats as stats
alph = 0.05
nu = 13
z = stats.t.ppf(1-alph/2, nu)
print(z)
example 9.5 . a class of 10 students took a midterm exam. their scores are given in
the following table.
student 1 2 3 4 5 6 7 8 9 10
score 72 69 75 58 67 70 60 71 59 65
find the 95% confidence interval.
5569.1. confidence interval
solution . the mean and standard deviation of the datasets are respectively bθ = 66 .6
andbs= 5.61. the critical zαvalue is determined by student’s t-distribution:
zα= ψ−1
9
1−α
2
= 2.26.
the confidence interval is
"
bθ−zαbs√
n,bθ +zαbs√
n#
= [62 .59,70.61].
therefore, with 95% probability, the interval [62 .59,70.61] will include the true popu-
lation mean.
remark 1 . make sure you understand the meaning of “population mean” in this
example. since we have ten students, isn’t the population mean just the average of the
ten scores? this is incorrect. in statistics, we assume that these ten students are the
realizations of some underlying (unknown) random variable xwith some pdf fx(x).
the population mean θis therefore the expectation e[x], where the expectation is
taken w.r.t. fx. the sample average bθ, which is the average of the ten numbers, is an
estimator of the population mean θ.
remark 2 . you may be wondering why we are using student’s t-distribution here
when we do not even know the pdf of x. the answer is that it is an approximation.
when xis gaussian, the sample average bθ is a student’s t-distribution, assuming
that the variance is approximated by the sample variance bs. this result is attributed
to the original paper of william gosset, who developed student’s t-distribution.
the above example can be solved computationally. an implementation through python
is given below, and the matlab implementation is straightforward if you translate it from
the python.
# python code to generate a confidence interval
import numpy as np
import scipy.stats as stats
x = np.array([72, 69, 75, 58, 67, 70, 60, 71, 59, 65])
theta_hat = np.mean(x) # sample mean
s_hat = np.std(x) # sample standard deviation
nu = x.size-1 # degrees of freedom
alpha = 0.05 # confidence level
z = stats.t.ppf(1-alph/2, nu)
ci_l = theta_hat-z*s_hat/np.sqrt(n)
ci_u = theta_hat+z*s_hat/np.sqrt(n)
print(ci_l, ci_u)
what is student’s t-distribution?
it was developed by william gosset in 1908. when he published the paper he
used the pseudonym student.
557chapter 9. confidence and hypothesis
we use student’s t-distribution to model the estimator bθ’s pdf when the vari-
ance σ2is replaced by the sample variance bs2.
student’s t-distribution has a heavier tail than a gaussian.
9.1.6 comparing student’s t-distribution and gaussian
we now discuss an important theoretical result regarding the relationship between a stu-
dent’s t-distribution and gaussian distribution. the main result is that the standard gaus-
sian is a limiting distribution of the tdistribution as the degrees of freedom ν→ ∞ .
theorem 9.1. asν→ ∞ , the student’s t-distribution approaches the standard gaus-
sian distribution:
lim
ν→∞(
γ ν+1
2
√νπγ ν
2
1 +y2
ν−ν+1
2)
=1√
2πe−t2
2. (9.13)
the proof of the theorem requires stirling’s approximation, which is not essential for this
book. feel free to skip it if needed.
proof . there are two results we need to use:
stirling’s approximation:2γ(z)≈q
2π
z z
ez.
exponential approximation: (1 +x
k)−k→e−x, ask→ ∞ .
we have that
γ ν+1
2
√νπγ ν
2≈q
2π
ν+1
2 ν+1
2eν+1
2
√νπq
2π
ν
2 ν
2eν
2
=1√νπrν
ν+ 11√eν+ 1
νν
2√ν+ 1√ν
=1√νπ√ν√
2eν+ 1
νν
2
=1√
2πe
1 +1
νν
2
.
putting a limit of ν→ ∞ , we have that
lim
ν→∞1√
2πe
1 +1
νν
2
=1√
2πee1
2=1√
2π.
2k. g. binmore, mathematical analysis: a straightforward approach . cambridge university press, 1977.
section 17.7.2.
5589.2. bootstrapping
the other limit follows from the fact that
lim
ν→∞
1 +t2
ν−ν+1
2
=e−t2
2.
combining the two limits proves the theorem. □
end of the proof. please join us again.
this theorem has several implications:
when nis large, s2→σ2. the gaussian approximation kicks in, and so student’s
t-distribution is more or less the same as the gaussian.
student’s t-distribution is better for small n, usually n≤30. if n≥30, using the
gaussian approximation suffices.
ifxis gaussian, student’s t-distribution is an excellent model. if xis not gaussian,
student’s t-distribution will have some issues unless nincreases.
9.2 bootstrapping
when estimating the confidence interval, we focus exclusively on the sample average bθ =
(1/n)pn
n=1xn. there are, however, many estimators that are not sample averages. for
example, we might be interested in an estimator that estimates the sample median: bθ =
median {x1, . . . , x n}. in such cases, the gaussian-based analysis or the student’s t-based
analysis we just derived would not work.
stepping back a little further, it is important to understand the hierarchy of estimation.
figure 9.8 illustrates a rough breakdown of the various techniques. on the left-hand side
of the tree, we have three point estimation methods: mle, map, and mmse. they are
so-called point estimation methods because they are reporting a point — a single value.
this stands in contrast to the right-hand side of the tree, in which we report the confidence
interval . note that point estimates and confidence intervals do not conflict with each other.
the point estimates are used for the actual engineering solution and the confidence intervals
are used to report the confidence about the point estimates. under the branch of confidence
intervals we discussed sample average. however, if we want to study an estimator that is
not the sample average, we need the technique known as the bootstrapping — a method
for estimating the confidence interval. notably, it does not give you a better point estimate.
as we have frequently emphasized, since bθ is a random variable , it has its own pdf,
cdf, mean, variance, etc. the confidence interval introduced in the previous section pro-
vides one way to quantify the randomness of bθ. throughout the derivation of the confidence
interval we need to estimate the variance var( bθ). for simple problems such as the sample
average, analyzing var( bθ) is not difficult. however, if bθ is a more complicated statistic, e.g.,
themedian , analyzing var( bθ) may not be as straightforward. bootstrapping is a technique
that is suitable for this purpose.
559chapter 9. confidence and hypothesis
figure 9.8: hierarchy of estimation. bootstrapping belongs to the category of confidence interval. it is
used to report the confidence intervals for estimators that are not the sample averages.
why is it difficult to provide a confidence interval for estimators such as the median?
a couple of difficulties arise:
many estimators do not have a simple expression for the variance. for simple esti-
mators such as the sample average bθ = (1 /n)pn
n=1xn, the variance is σ2/n. if the
estimator is the median bθ = median {x1, . . . , x n}, the variance of bθ will depend on
the underlying distribution of the xn’s. if the estimator is something beyond the sam-
ple median, the variance of bθ can be even more complicated to determine. therefore,
techniques such as central limit theorem do not apply here.
we typically have only oneset of data points. we cannot re-collect more i.i.d. samples
to estimate the variance of the estimator. therefore, our only option is to squeeze the
information from the data we have been given.
when do we use bootstrapping?
bootstrapping is a technique to estimate the confidence interval.
we use bootstrapping when the estimator does not have a simple expression for
the variance.
bootstrapping allows us to estimate the variance without re-collecting more data.
bootstrapping does not improve your point estimates.
9.2.1 a brute force approach
before we discuss the idea of bootstrapping, we need to elaborate on the difficulty of esti-
mating the variance using repeated measurements. suppose that we somehow have access to
the population distribution. let us denote the cdf of this population distribution by fx,
5609.2. bootstrapping
and the pdf by fx. by having access to the population distribution we can synthetically
generate as many samples xn’s as we want. this is certainly hypothetical, but let’s assume
that it is possible for now.
if we have full access to the population distribution, then we are able to draw k
replicate datasets x1, . . . ,xkfrom fx:
x(1)={x(1)
1, . . . , x(1)
n} ∼fx,
x(2)={x(2)
1, . . . , x(2)
n} ∼fx, (9.14)
...
x(k)={x(k)
1, . . . , x(k)
n} ∼fx.
each dataset x(k)contains ndata points, and by virtue of i.i.d. all the samples have the
same underlying distribution fx.
for each dataset we construct an estimator bθ = g(·) for some function g(·). the
estimator takes the data points of the dataset xand returns a value. since we have k
datasets, correspondingly we will have kestimators:
bθ(1)=g(x(1)) =g(x(1)
1, . . . , x(1)
n),
bθ(2)=g(x(2)) =g(x(2)
1, . . . , x(2)
n), (9.15)
...
bθ(k)=g(x(k)) =g(x(k)
1, . . . , x(k)
n).
note that these estimators g(·) can be anything. it can be the sample average or it can be
the sample median. there is no restriction.
since we are interested in constructing the confidence interval for bθ, we need to analyze
the mean and variance of bθ. the true mean and the estimated mean of bθ are
e[bθ] = true mean of bθ, (9.16)
m(bθ) = estimated mean based on bθ(1), . . . ,bθ(k)
def=1
kkx
k=1bθ(k)=1
kkx
k=1g(x(k)), (9.17)
respectively. similarly, the true variance and the estimated variance of bθ are
var[bθ] = true variance of bθ, (9.18)
v(bθ) = estimated variance based on bθ(1), . . . ,bθ(k)
def=1
kkx
k=1
bθ(k)−m(bθ)2
=1
kkx
k=1
g(x(k))−m(bθ)2
. (9.19)
561chapter 9. confidence and hypothesis
these two equations should be familiar: since bθ is a random variable, and {bθ(k)}are i.i.d.
copies of bθ, we can compute the average of bθ(1), . . . ,bθ(k)and the corresponding variance.
as the number of repeated trials kapproaches ∞, the estimated variance v(bθ) will converge
to var( bθ) according to the law of large numbers.
we can summarize the procedure we have just outlined. to produce an estimate of the
variance, we run the algorithm below.
algorithm 1: brute force method to generate an estimated variance
assume: we have access to fx.
step 1: generate datasets x(1), . . . ,x(k)from fx.
step 2: compute m(bθ) and v(bθ) based on the samples.
output: the estimated variance is v(bθ).
the problem, however, is that we only have onedataset x(1). we do not have access to
x(2), . . . ,x(k), and we do not have access to fx. therefore, we are not able to approxi-
mate the variance using the above brute force simulation. bootstrapping is a computational
technique to mimic the above simulation process by using the available data in x(1).
9.2.2 bootstrapping
the idea of bootstrapping is illustrated in figure 9.9 . imagine that we have a population
cdf fxand pdf fx. the dataset we have in hand, x, is a collection of the random realiza-
tions of the random variable x. this dataset xcontains ndata points x={x1, . . . , x n}.
figure 9.9: a conceptual illustration of bootstrapping. given the observed dataset x, we synthetically
construct kbootstrapped datasets (colored in yellow) by sampling with replacement from x. we
then compute the estimators, e.g., computing the median, for every bootstrapped dataset. finally, we
construct the estimator’s histogram (in blue) to compute the bootstrapped mean and variance.
in bootstrapping, we synthesize kbootstrapped datasets y(1), . . . ,y(k), where each
bootstrapped dataset y(k)consists of nsamples redrawn from x. essentially, we draw with
5629.2. bootstrapping
replacement nsamples from the observed dataset x:
y(1)={y(1)
1, . . . , y(1)
n}=nrandom samples from x,
...
y(k)={y(k)
1, . . . , y(k)
n}=nrandom samples from x.
afterward, we construct our estimator bθ according to our desired function g(·). for example,
ifg(·) = median, we have
bθ(1)
boot=g(y(1)) = median( y(1)),
...
bθ(k)
boot=g(y(k)) = median( y(k)).
then, we define the bootstrapped mean and the bootstrapped variance as
mboot(bθ) =1
kkx
k=1bθ(k)
boot, (9.20)
vboot(bθ) =1
kkx
k=1
bθ(k)
boot−mboot(bθ)2
. (9.21)
the procedure we have just outlined can be summarized as follows.
algorithm 2: bootstrapping to generate an estimated variance
assume: we do not have access to fx, but we have one dataset x.
step 1: generate datasets y(1), . . . ,y(k)fromx, by sampling with replacement from
x.
step 2: compute mboot(bθ) and vboot(bθ) based on the samples.
output: the bootstrapped variance is vboot(bθ).
the only difference between this algorithm and the previous one is that we are not synthe-
sizing data from the population but rather from the observed dataset x.
what makes bootstrapping work? the basic principle of bootstrapping is based on
three approximations:
varf(bθ)(a)≈vfull(bθ)(b)≈
varbf(bθ)(c)≈vboot(bθ)
in this set of equations, the ultimate quantity we want to know is var f(bθ), which is the
variance of bθ under f. (by “under f” we mean that the variance was found by integrating
with respect to the distribution fx.) however, since we do not have access to f, we have
563chapter 9. confidence and hypothesis
to approximate var f(bθ) by vfull(bθ).vfull(bθ) is the sample variance computed from the
khypothetical datasets x(1), . . . ,x(k). we call it “full” because we can generate as many
hypothetical datasets as we want. it is marked as the approximation ( a) above.
in the bootstrapping world, we approximate the underlying distribution fby some
other distribution bf. for example, if fis the cdf of a gaussian distribution, we can
choose bfto be the finite-sample staircase function approximating f. in our case, we use the
observed dataset xto serve as a proxy bftof. this is the second approximation, marked by
(b). normally, if you have a reasonably large x, it is safe to assume that this finite-sample
dataset xhas a cdf bfthat is close to the true cdf f.
the third approximation is to find a numerical estimate var bf(bθ) via the simulation
procedure we have just outlined. this is essentially the same line of argument for ( a) but
now applied to the bootstrapping world. we mark this approximation by ( c). its goal is to
approximate var bf(bθ) via vboot(bθ).
the three approximations have their respective influence on the accuracy of the boot-
strapped variance:
how does bootstrapping work?
it is based on three approximations:
(a): a hypothetical approximation. the best we can do is that we have access
tof. it is practically impossible to achieve, but it gives us intuition.
(b): approximate fbybf, where bfis the empirical cdf of the observed data.
this is usually the source of error. the approximation error reduces when you
use more samples to approximate f.
(c): approximate the theoretical bootstrapped variance by a finite approxima-
tion. this approximation error is usually small because you can generate as many
bootstrapped datasets as you want.
one “mysterious” property of bootstrapping is the sampling with replacement scheme
used to synthesize the bootstrapped samples. the typical questions are:
(1)why does sampling from the observed dataset xlead to meaningful boot-
strapped datasets y(1), . . . ,y(k)? to answer this question we consider the following
toy example. suppose we have a dataset xcontaining n= 20 samples, as shown
below.
x = [0 0 0 0 0 0 1 1 1 1 2 2 2 2 2 2 2 2 2 2]
this dataset is generated from a random variable xwith a pdf bfhaving three states:
0 (30%), 1 (20%), 2 (50%). as we draw samples from x, the percentage of the states
will determine the likelihood of one state being drawn. for example, if we randomly
pick a sample ynfromx, we have a 30% chance of having ynto be 0, 20% chance
of having it to be 1, and 50% chance of having it to be 2. therefore, the pdf of yn
(the randomly drawn sample from x) will be 0 (30%), 1 (20%), 2 (50%), the same
as the original pdf. if you think about this problem more deeply, by “sampling with
replacement” we essentially assign each xnwith an equal probability of 1 /n. if one
of the states is more popular, the individual probabilities will add to form a higher
probability mass.
5649.2. bootstrapping
(2)why can’t we do sampling without replacement, aka permutation ? we need to
understand that sampling without replacement is the same as permuting the data in x.
by permuting the data in x, the simple probability assignments such as p[x= 0] =6
20,
p[x= 1] =4
20andp[x= 2] =10
20will be destroyed. moreover, permuting the data
does not change the mean and variance of the data because we are only shuffling the
order. as far as constructing the confidence interval is concerned, shuffling the order
is not useful.
on computers it is easy to generate the bootstrapped dataset, along with their mean
and variance. in matlab the key step is to call a forloop. inside the forloop, we draw
nrandom indices randi from 1 to nand pick the samples. the estimator thetahat is then
constructed by calling your target estimator function g(·). in this example the estimator is
the median. after the forloop, we compute the mean and variance of bθ. these are the
bootstrapped mean and variance, respectively.
% matlab code to estimate a bootstrapped variance
x = [72, 69, 75, 58, 67, 70, 60, 71, 59, 65];
n = size(x,2);
k = 1000;
thetahat = zeros(1,k);
for i=1:k % repeat k times
idx = randi(n,[1, n]); % sampling w/ replacement
y = x(idx);
thetahat(i) = median(y); % estimator
end
m = mean(thetahat) % bootstrapped mean
v = var(thetahat) % bootstrapped variance
the python commands are similar. we call np.random.randint to generate random
integers and we pick samples according to y = x[idx] . after generating the bootstrapped
dataset, we compute the bootstrap estimators thetahat .
# python code to estimate a bootstrapped variance
import numpy as np
x = np.array([72, 69, 75, 58, 67, 70, 60, 71, 59, 65])
n = x.size
k = 1000
thetahat = np.zeros(k)
for i in range(k):
idx = np.random.randint(n, size=n)
y = x[idx]
thetahat[i] = np.median(y)
m = np.mean(thetahat)
v = np.var(thetahat)
after we have constructed the bootstrapped variance, we can define the bootstrapped
standard error as
bseboot=q
vboot(bθ). (9.22)
565chapter 9. confidence and hypothesis
accordingly we define the bootstrapped confidence interval as
i=bθ−zαbseboot,bθ +zαbseboot
, (9.23)
where zαis the critical value of the gaussian.
the validity of the confidence intervals constructed by bootstrapping is subject to
the validity of zα. ifbθ is roughly a gaussian, the bootstrapped confidence interval will be
reasonably good. if bθ is not gaussian, there are advanced methods to replace zαwith better
estimates. this topic is beyond the scope of this book; we refer interested readers to larry
wasserman, all of statistics , springer 2003, chapter 8.
9.3 hypothesis testing
imagine that you are a vaccine company developing covid-19 vaccines. you gave the
vaccine to 934 patients, and 928 patients have developed antigens. how confident can you
be that your vaccine is effective? questions like this are becoming more common nowadays
in situations in which we need to make statistically informed choices between yes and no.
the subject of this section is hypothesis testing — a principled statistical procedure used
to evaluate statements that should be accepted or rejected.
9.3.1 what is a hypothesis?
a hypothesis is a statement that requires testing by observation to determine whether it is
true or false. a few examples:
the coin is unbiased.
students entering the graduate program have gpa ≥3.
more people like orange juice than lemonade.
algorithm a performs better than algorithm b.
as you can see from these examples, a hypothesis is something we can test based on the
data. therefore, being “correct” or “wrong” depends on the statistics we have and the cutoff
threshold. accepting or rejecting a hypothesis does not mean that the statement is correct
or wrong, since the truth is unknown. if we accept a hypothesis, we have made a better
decision solely based on the statistical evidence. it is possible that tomorrow when you have
collected more data we may reject a previously accepted hypothesis.
the procedure for testing whether a hypothesis should be accepted or rejected is known
ashypothesis testing . in hypothesis testing, we often have two opposite hypotheses:
h0: null hypothesis. it is the “status quo”, or the current status.
h1: alternative hypothesis. it is the alternative to the null hypothesis.
to better understand hypothesis testing, consider a courthouse. by default, any person
being prosecuted is assumed to be innocent. the police need to show sufficient evidence in
order to prove the person guilty. the null hypothesis is the default assumption. hypothesis
testing asks whether we have strong enough evidence to reject the null hypothesis. if our
evidence is not strong enough, we must assume that the null hypothesis is possibly true.
5669.3. hypothesis testing
example 9.6 . suggest a null hypothesis and an alternative hypothesis regarding
whether a coin is unbiased.
solution : let θbe the probability of getting a head.
h0:θ= 0.5, and h1:θ >0.5. this is a one-sided alternative.
h0:θ= 0.5, and h1:θ <0.5. this is another one-sided alternative.
h0:θ= 0.5, and h1:θ̸= 0.5. this is a two-sided alternative.
practice exercise 9.3 . suggest a null and an alternative hypothesis regarding whether
more than 62% of people in the united states use microsoft windows.
solution : let θbe the proportion of people using microsoft windows in united states.
h0:θ≥0.62, and h1:θ <0.62. this is a one-sided alternative.
practice exercise 9.4 . suggest a null and an alternative hypothesis regarding whether
self-checkout at walmart is faster than using a cashier.
solution : let θbe the proportion of people that check out faster with self-checkout..
h0:θ≥0.5, and h1:θ <0.5. this is a one-sided alternative.
9.3.2 critical-value test
in hypothesis testing, there are two major approaches: the critical-value test , and the
p-value test . the two tests are more or less equivalent. if you reject the null hypothesis using
the critical-value test, you will reject the hypothesis using the p-value. in this subsection,
we will discuss the critical-value test. let us consider a toy problem:
suppose that we have a 4-sided die and our goal is to test whether the die is unbiased.
to do so, we define the null and the alternative hypotheses as
h0:θ= 0.25, which is our default belief.
h1:θ >0.25, which is a one-sided alternative.
there is no particular reason for considering the one-sided alternative other than the fact
that the calculation is slightly easier. you are welcome to consider the two-sided alternative.
we must obtain data prior to conducting any hypothesis testing. let’s assume that we
have thrown the die n= 1000 times. we find that “3” appears 290 times (we could just as
well have chosen 1, 2, or 4). we let x1, . . . , x 1000be the n= 1000 binary random variables
representing whether we have obtained a “3” or not. if the true probability is θ= 0.25, then
we will have p[xn= 3] = θ= 0.25 and p[xn̸= 3] = 1 −θ= 0.75. we know that we cannot
access the true probability, so we can only construct an estimator of the probability:
bθ =1
nnx
n=1xn.
567chapter 9. confidence and hypothesis
in this experiment, we can show that bθ = 290 /1000 = 0 .29.
to make our problem slightly easier, we pretend that we know the variance var[ xn].
in practice, we certainly do not know var[ xn], and so we need to estimate the variance. if
we knew the variance, it should be var[ xn] =θ(1−θ) = 0 .25(1−0.25) = 0 .1875, because
xnis a bernoulli random variable with a mean θ.
the question asked by hypothesis testing is: how far is “ bθ = 0 .29” from “ θ= 0.25”?
if the statistic generated by our data, bθ = 0 .29, is “far” from the hypothesized θ= 0.25,
then we need to reject h0because h0says that θ= 0.25. however, if there is no strong
evidence that θ >0.25, we will need to assume that h0may possibly be true. so the key
question is what is meant by “far”.
for many problems like this one, it is possible to analyze the pdf of bθ. since bθ is the
sample average of a sequence of bernoulli random variables, it follows that bθ is a binomial
(with a scaling constant 1 /n). ifnis large enough, e.g., n≥30, the central limit theorem
tells us that bθ is also very close to a gaussian. therefore, we can more or less claim that
bθ∼gaussian
θ,σ2
n
.
with a simple translation and scaling, we can normalize bθ to obtain bz:
bz=bθ−θ
σ/√
n∼gaussian (0 ,1).
figure 9.10 illustrates the range of values for this problem. there are two axes: the bθ-
axis (which is the estimator) and the bz-axis (which is the normalized variable). the values
corresponding to each axis are shown in the figure. for example. bθ = 0 .29 is equivalent
tobz= 2.92, and bθ = 0 .25 is equivalent to bz= 0, etc. therefore, when we ask how far
“bθ = 0 .29” is from “ θ= 0.25”, we can map this question from the bθ-axis to the bz-axis,
and ask the relative position of bzfrom the origin.
figure 9.10: the mapping between bθandbz. to decide whether we want to reject or keep h0, the
critical-value approach compares bzrelative to the critical value zα.
on a computer, obtaining these values is quite straightforward. using matlab, find-
ingbzcan be done by calling the following commands. the python code is analogous.
5689.3. hypothesis testing
% matlab command to estimate the z_hat value.
theta_hat = 0.29; % your estimate
theta = 0.25; % your hypothesis
sigma = sqrt(theta*(1-theta)); % known standard deviation
n = 1000; % number of samples
z_hat = (theta_hat - theta)/(sigma/sqrt(n));
# python command to estimate the z_hat value
import numpy as np
theta_hat = 0.29 # your estimate
theta = 0.25 # your hypothesis
n = 1000 # number of samples
sigma = np.sqrt(theta*(1-theta)) # known standard deviation
z_hat = (theta_hat - theta)/(sigma / np.sqrt(n))
print(z_hat)
one essential element of hypothesis testing is the cutoff threshold, which is defined
through the critical level α. it is the area under the curve of the pdf of bz. typically,
αis chosen to be a small value, such as α= 0.05 (corresponding to a 5% margin). the
corresponding cutoff is known as the critical value . it is defined as
zα= cutoff location where area under the curve is α.
ifbzis gaussian(0,1) and if we are looking at the right-hand tail, it follows that
zα= φ−1(1−α). (9.24)
in our example, we find that z0.05= 1.65, which is marked in figure 9.10 .
on computers, determining the critical value zαis straightforward. in matlab the
command is icdf, and in python the command is stats.norm.ppf .
% matlab code to compute the critical value
alpha = 0.05;
z_alpha = icdf(’norm’, 1-alpha, 0, 1);
# python code to compute the critical value
import scipy.stats as stats
alpha = 0.05
z_alpha = stats.norm.ppf(1-alpha, 0, 1)
do we have enough evidence to reject h0in this example? of course! the estimated
valuebθ = 0 .29 is equivalent to bz= 2.92, which is much too far from the cutoff zα= 1.65.
in other words, we conclude that at a 5% critical level we have strong evidence to believe
that the die is biased. therefore, we need to reject h0.
this conclusion makes a lot of sense if you think about it carefully. the estimator
bθ = 0 .29 is obtained from n= 1000 independent experiments. if we were only conducting
n= 20 experiments, it might be consistent with the null hypothesis to have bθ = 0 .29.
569chapter 9. confidence and hypothesis
however, if we have n= 1000 experiments, having bθ = 0 .29 does not seem likely when
there is no systematic bias. if there is no systematic bias, the estimator bθ should slightly
jitter around bθ = 0 .25, but it is quite unlikely to vary wildly to bθ = 0 .29. thus, based on
the available statistics, we decide to reject the null hypothesis.
the decision based on comparing the critical value is known as the critical-value test .
the idea (for testing a right-hand tail of a gaussian random variable) is summarized in
three steps:
how to conduct a critical-value test
set a critical value zα. compute bz= (bθ−θ)/(σ/√
n).
ifbz≥zα, then reject h0.
ifbz < z α, then keep h0.
if you are testing a left-hand tail , you can switch the order of the inequalities.
the critical-value test belongs to a larger family of testing procedures based on deci-
sion theory. to give you a preview of the general theory of hypothesis testing, we define a
decision rule , a function that maps a realization of the estimator to a binary decision space.
in our problem the estimator is bz(or equivalently bθ). we denote its realization by bz. the
binary decision space is {h0, h1}, corresponding to whether we want to claim h0orh1.
claiming h0is equivalent to keeping h0, and claiming h1is equivalent to rejecting h0.
for the critical-value test, the decision rule δ(·) :r→ {0,1}is given by the equation (for
testing a right-hand tail):
δ(bz) =(
1,ifbz≥zα, (claim h1),
0,ifbz < z α, (claim h0).(9.25)
example 9.7 . it was found that only 35% of the children in a kindergarten eat
broccoli. the teachers conducted a campaign to get more kids to eat broccoli, after
which it was found that 390 kids out of 1009 kids reported that they had eaten broccoli.
has the campaign successfully increased the number of kids eating broccoli? assume
that the standard deviation is known.
solution . we setup the null and the alternative hypothesis.
h0:θ= 0.35, h 1:θ >0.35.
we construct an estimator bθ = (1 /n)pn
n=1xn, where xnis bernoulli with proba-
bility θ. based on θ,σ2=θ(1−θ) = 0 .227. (again, in practice we do not know the
true variance, but in this problem we pretend that we know it.)
by the central limit theorem, bθ is roughly a gaussian. we compute the test
statistics bθ =390
1009= 0.387. standardization gives bz=bθ−θ
σ/√
n= 2.432. at a 5%
critical level, we have that zα= 1.65. so bz= 2.432>1.65 = zα, and hence we need
to reject the null hypothesis. even if we choose a 1% critical level so that zα= 2.32,
our estimator bz= 2.432>2.32 = zαwill still reject the null hypothesis.
5709.3. hypothesis testing
a graphical illustration of this problem is shown in figure 9.11 . it can be seen
thatbθ = 0 .387 is actually quite far away from the cutoff 1.65. thus, we need to reject
the null hypothesis.
figure 9.11: example of a critical-value test. in this example, the test statistic bθ = 0 .387is
equivalent to bz= 2.432, which is significantly larger than the cutoff zα= 1.65. therefore, we
have strong evidence to reject the null hypothesis, because the probability of obtaining bθ = 0 .387
is very low if h0is true.
9.3.3 p-value test
an alternative to the critical-value test is the p-value test. instead of looking at the cutoff
value zα, we inspect the probability of obtaining our observation if h0is true. to understand
how the p-value test works, we consider another toy problem.
suppose that we have two hypotheses about flipping a coin:
h0:θ= 0.9, which is our default belief.
h1:θ <0.9, which is a one-sided alternative.
it was found that with n= 150 coin flips, the coin landed on heads 128 times. thus the
estimator is bθ =128
150= 0.853. then, by following our previous procedures, we have that
bz=bθ−θ
σ/√
n=0.853−0.9q
0.9(1−0.9)
150=−1.92.
at this point we can follow the previous subsection by computing the critical value zα
and make the decision. however, let’s take a different route. we want to know what is the
probability under the curve if we integrate the pdf of bzfrom−∞to−1.92. this is easy.
sincebzis gaussian(0 ,1), it follows from the cdf of a gaussian that
p[bz≤ −1.92]|{z}
p-value= 0.0274.
referring to figure 9.12 , the value 0.0274 is the pink area under the curve, which is the
pdf of bz. since the area under the curve is less than the critical level α(say 5%), we reject
the null hypothesis.
on computers, computing the p-value is done using the cdf commands.
571chapter 9. confidence and hypothesis
figure 9.12: thep-value test asks us to look at the probability of bz≤bz. if this probability (the p-value)
is less than the critical level α, we have significant evidence to reject the null hypothesis.
% matlab code to compute the p-value
p = cdf(’norm’, -1.92, 0, 1);
# python code to compute the p-value
import scipy.stats as stats
p = stats.norm.cdf(-1.92,0,1)
in this example, the probability p[bz≤ −1.92] is known as the p-value . it is the
probability of bz≤z, under the distribution mandated by the null hypothesis, where z
is the (normalized) estimated value based on data. using our example, zis−1.92. by
“distribution mandated by the null hypothesis” we mean that the pdf of bzis the pdf that
the null hypothesis wants. in the above example the pdf is gaussian(0 ,1), corresponding
to gaussian( θ, σ/√
n) forbθ.
more formally, the p-value for a left-hand tail test is defined as
p-value( bz) =p[bz≤bz],
where bzis the random realization of bzestimated from the data. the decision rule based
on the p-value is (for the left-hand tail):
δ(bz) =(
1,p[bz≤bz]< α (claim h1),
0,p[bz≤bz]≥α (claim h0).(9.26)
if the alternative hypothesis is right-handed, then the probability becomes p[bz≥bz] instead.
relationship between critical-value and p-value tests . there is a one-to-one corre-
spondence between the p-value and the critical value. in the p-value test, if bzis gaussian,
it follows that
p-value = p[bz≤bz] = φ(bz),
5729.3. hypothesis testing
where φ is cdf of the standard gaussian. taking the inverse, the corresponding bzis
bz= φ−1(p-value) .
in practice, we do not need to take any inverse of the p-value to obtain bzbecause it is
directly available from the data.
to test the p-value, we compare it with the critical level αby checking
p-value < α.
taking the inverse of both sides, it follows that the decision rule is equivalent to
φ−1(p-value)|{z}
bz<φ−1(α)|{z}
zα,
where the quantity on the right-hand side is the critical value zα. therefore, if the test
statistic fails in the p-value test it will also fail in the critical-value test, and vice versa.
what is the difference between the critical-value test and p-value test?
critical-value test: compare w.r.t. critical value, which is the cutoff on the z-
axis.
p-value test: compare w.r.t. α, which is the probability.
both will give you the same statistical conclusion. so it does not matter which
one you use.
example 9.8 . we flip a coin for n= 150 times and find that 128 are heads. consider
two hypotheses
h0:θ= 0.9, which is our default belief.
h1:θ̸= 0.9, which is a two-sided alternative.
for a critical level of α= 0.05, shall we keep or reject h0?
solution . we know that bθ = 128 /150 = 0 .853. the normalized statistic is
bz=bθ−θ
σ/√
n=0.853−0.9q
0.9(1−0.9)
150=−1.92.
to compute the p-value, we observe that the two-sided test means that we consider
the two tails. thus, we have
p-value = p[|bz|>1.92]
= 2×p[bz >1.92]
= 2×0.0274 = 0 .055.
573chapter 9. confidence and hypothesis
for a critical level of α= 0.05, the p-value is larger. this means that the probability
of obtaining |z|>1.92 is not extreme enough. therefore, we do not have sufficient
evidence to reject the null hypothesis.
if we take the critical-value test, we will reach the same conclusion. the critical
value for α= 0.05 is determined by taking the inverse cdf at 1 −0.025, giving
zα= φ−1
1−α
2
= 1.96.
sincebz= 1.92 has not passed this threshold, we conclude that there is not enough
evidence to reject the null hypothesis.
figure 9.13: example of a two-sided test using the p-value and the zα-value.
9.3.4 z-test and t-test
the critical-value test and the p-value tests are generic tools for hypothesis testing. in this
subsection we introduce the z-test and the t-test. it is important to understand that the
z-test and the t-test refer to the distributional assumptions we make about the variance.
they define the distribution we use to conduct the test but not the tools. in fact, both the
z-test and the t-test can be implemented using the critical-value test or the p-value test.
figure 9.14 illustrates the hierarchy of the tests.
figure 9.14: when conducting a hypothesis testing of the sample average, we may or may not know
the variance. if we know the variance, we use the gaussian distribution to conduct either a p-value test
or a critical-value test. if we do not know the variance, we use student’s t-distribution.
the difference between the gaussian distribution and the tdistribution is mainly
5749.3. hypothesis testing
attributable to the knowledge about the population variance. if the variance is known,
the distribution of the estimator (which in our case is the sample average) is gaussian. if
the variance is estimated from the sample, the distribution of the estimator will follow a
student’s t-distribution.
to introduce the z-test and the t-test we consider the following two examples. the
first example is a z-test.
example 9.9 (z-test). suppose we have a gaussian random variable with unknown
mean θand a known variance σ= 11.6. we draw n= 25 samples and construct an
estimator bθ = 80 .94. we propose two hypotheses:
h0:θ= 85, which is our default belief.
h1:θ <85, which is a one-sided alternative.
for a critical level of α= 0.05, shall we keep or reject the null hypothesis?
solution . the test statistic is
bz=bθ−θ
σ/√
n=−1.75.
since the individual samples are assumed to follow a gaussian, the sample average bθ
is also a gaussian. hence, bzis distributed according to gaussian(0 ,1).
figure 9.15: a one-sided z-test using the p-value and the zα-value.
for a critical level of 0 .05, a one-sided critical value is
zα= φ−1(1−α) =−1.645.
sincebz=−1.75, which is more extreme than the critical value, we conclude that we
need to reject h0.
if we use the p-value test, we have that the p-value is
p[bz≤ −1.75] = φ( −1.75) = 0 .0401.
575chapter 9. confidence and hypothesis
since the p-value is smaller than the critical level α= 0.05, it implies that bz=−1.75
is more extreme. hence, we reject h0.
the following example is a t-test. in a t-test we do not know the population variance
but only know the sample variance bs. thus the test statistic we use is a trandom variable.
example 9.10 (t-test). suppose we have a gaussian random variable with unknown
mean θand an unknown variance σ. we draw n= 100 samples and construct an
estimator bθ = 130 .1, with a sample variance bs= 21.21. we propose two hypotheses:
h0:θ= 120, which is our default belief.
h1:θ̸= 120, which is a two-sided alternative.
for a critical level of α= 0.05, shall we keep or reject the null hypothesis?
solution . the test statistic is
bt=bθ−θ
bs/√
n= 4.762.
note that while the sample average bθ is a gaussian, the test statistic btis distributed
according to a tdistribution with n−1 degrees of freedom. for a critical level of
0.05, a two-sided critical value is
tα= ψ−1
99
1−α
2
= 1.984.
sincebt= 4.762, which is more extreme than the critical value, we conclude that we
need to reject h0.
if we use the p-value test, we have that the p-value is
p[|bt| ≥4.762] = 2 ×p[bt≥4.762] = 3 .28×10−6.
since the p-value is (much) smaller than the critical level α= 0.05, it implies that
|bt| ≥4.762 is quite extreme. hence, we reject h0.
figure 9.16: a two-sided t-test using the p-value and the zα-value.
for this example, the matlab and python commands to compute tαand the p-value are
5769.4. neyman-pearson test
% matlab code to compute critical-value and p-value
t_alpha = icdf(’t’, 1-0.025, 99);
p = 1-cdf(’t’, 4.762, 99);
# python code to compute critical value and p-value
import scipy.stats as stats
t_alpha = stats.t.ppf(1-0.025,99)
p = 1-stats.t.cdf(4.762,99)
what are the z-test and the t-test?
both are hypothesis testings for the sample averages.
z-test: assume known variance. hence, use the gaussian distribution.
t-test: assume unknown variance. hence, use the student’s t-distribution.
remark . we are exclusively analyzing the sample average in this section. there are other
types of estimators we can analyze. for example, we can discuss the difference between the
two means, the ratio of two random variables, etc. if you need tools for these more advanced
problems, please refer to the reference section at the end of this chapter.
9.4 neyman-pearson test
the hypothesis testing procedures we discussed in the previous section are elementary in
the sense that we have not discussed much theory. this section aims to fill the gap so that
you can understand hypothesis testing from a broader perspective. this generalization will
also help to bridge statistics to other disciplines such as classification in machine learning
and detection in signal processing. we call this theoretical analysis the neyman-pearson
framework .
9.4.1 null and alternative distributions
when we discussed hypothesis testing in the previous section, we focused exclusively on the
null hypothesis h0. regardless of whether we are studying the z-test or the t-test, using
the critical value or the p-value, all the distributions are associated with the distribution
under h0.
what do we mean by “distribution under h0”? using bθ as an example, the pdf of
bθ is assumed to be gaussian( θ, σ2/n). this gaussian, centered at θ, is the distribution
assumed under h0. as we decide whether to keep or reject h0, we look at the critical value
and the p-value of the test statistic under gaussian( θ, σ2/n).
importantly, the analysis of hypothesis testing is not just about h0— it is also about
the alternative hypothesis h1, which uses a different pdf. for example, h1could use
577chapter 9. confidence and hypothesis
gaussian( θ′, σ2/n) forθ′> θ. therefore, for the same testing statistic bθ, we can check how
close it is to h1.
to capture both distributions, we define
f0(y) =fy(y|h0),
f1(y) =fy(y|h1).
the first pdf defines the distribution when the true model is h0. the second pdf is the
distribution when the true model is h1.
example 9.11 . consider an estimator y∼gaussian( θ, σ2/n). define two hypotheses
h0:θ= 120 and h1:θ >120. the two pdfs are then
f0(y) =fy(y|h0) = gaussian(120 , σ2/n),
f1(y) =fy(y|h1) = gaussian( θ′, σ2/n), θ′>120.
a graph of the two distributions is shown in figure 9.17 . in this figure we plot the
pdf under the null hypothesis and the pdf under an alternative hypothesis. the decision
is based on the null, where we marked the critical value.
figure 9.17: the pdf of the estimator under hypotheses h0andh1. the yellow region defines the
rejection zone rα. if the estimator has a realization y=ythat falls into the rejection zone rα, we
need to reject h0.
students are frequently confused about the exact equation of the pdf under h1. if
the alternative hypothesis is defined as θ >120, shall we define the pdf as a gaussian
centered at 130 or 151.4? they are both valid alternative hypotheses. the answer is that
we are going to express all equations based on θ′. for example, if we want to analyze the
prediction error (this term will be explained later), the prediction error will be a function
ofθ′. ifθ′is close to θ, we will expect a larger prediction error. however, if θ′is far away
from θ, the prediction error may be small.
whenever we discuss hypothesis testing, a decision rule is always implied. a decision
rule is a mapping δ(·) from sample space yof the test statistic y(orbθ if you prefer) to the
5789.4. neyman-pearson test
binary space of {0,1}:
δ(y) =(
1, ify∈rα,(we will reject h0),
0, ify̸∈rα,(we will keep h0).(9.27)
here rαis the rejection zone . for example, in a one-sided testing at a critical level α, the
rejection zone is rα={y≥φ−1(1−α)}. therefore, as long as y≥φ−1(1−α), we will
reject the null hypothesis. otherwise, we will keep the null hypothesis. a rejection zone can
be one-sided, two-sided, or even more complicated.
example 9.12 . consider h0:θ= 0.35 and h1:θ >0.35. it was found that the
sample average over 1009 samples is bθ = 0 .387, with σ2= 0.227. the normalized test
statistic is bz=√
n(bθ−θ)/σ= 2.432. at a 5% critical level, define the decision rule
based on the critical-value approach.
solution . ifα= 0.05, it follows that zα= φ−1(1−0.05) = 1 .65. therefore, the
decision rule is
δ(bz) =(
1, ifbz≥1.65,(we will reject h0),
0, ifbz <1.65,(we will keep h0),
where bzis the realization of bz. in this particular problem, we have bz= 2.432. thus,
according to the decision rule, we need to reject h0.
a decision rule is something youcreate. you do not need to follow the critical-value
or the p-value procedure — you can create your own decision rule. for example, you can
say “reject h0when|y|>0.000001”. there is nothing wrong with this decision rule except
that you will almost always reject the null hypothesis (so it is a bad decision rule). see
figure 9.18 for a graph of a similar example. if you follow the critical-value or the p-value
procedures, it turns out that the resulting decision rule is equivalent to some form of optimal
decision rule. this concept is the neyman-pearson framework, which we will explain shortly.
9.4.2 type 1 and type 2 errors
since hypothesis testing is about applying a decision rule to the test statistics, and since
no decision rule is perfect, it is natural to ask about the error expected from a particular
decision rule. in this subsection we define the decision error. however, the terminology varies
from discipline to discipline. we will explain the decision error first through the statistics
perspective and then through the signal processing perspective.
two tables of the cases that can be generated by a binary decision-making process are
shown in figure 9.19 . the columns of the tables are the true statements, i.e., whether the
test statistic has a population distribution under h0orh1. the rows of the tables are the
statements predicted by the decision rule, i.e., whether we should declare the statistics are
from h0orh1. each combination of the truth and prediction has a label:
true positive: the truth is h1, and you declare h1.
true negative: the truth is h0, and you declare h0.
false positive: the truth is h0, and you declare h1.
579chapter 9. confidence and hypothesis
figure 9.18: two possible decision rules δ1(y)andδ2(y). in this example, δ1(y)is designed according
to the critical-value approach at α= 0.025, whereas δ2(y)is arbitrarily designed. both are valid decision
rules, although δ2should not be used because it tends to reject the null hypothesis more often than
desired.
false negative: the truth is h1, and you declare h0.
different communities have different ways of labeling these quantities. in the statistics com-
munity the false negative rate (i.e., the number of false negative cases divided by the total
number of cases) is called the type 2 error , and the false positive rate is called the type 1
error. the true positive rate is called the power of the decision rule.
in the engineering community (e.g., radar engineering and signal processing) the ob-
jective is to detect whether a target (e.g., a missile or an enemy aircraft) is present. in this
context, the false positive rate is known as the probability of false alarm , since personnel
will be alerted when no target is present. the false negative rate is known as the probability
ofmiss because you miss a target. if the truth is h1and the prediction is also h1, we call
this the probability of detection .
figure 9.19: terminologies used in labeling the prediction error. the terms “type 1 error” and “type
2 error” are commonly used by the statistics community, whereas the terms “false alarm”, “miss” and
“detection” are more often used in the engineering community.
the diagram in figure 9.20 will help to clarify these definitions. given two hypotheses
h0andh1, there exists the corresponding distributions f0(y) and f1(y), which are the pdfs
5809.4. neyman-pearson test
of the test statistics y(orbθ if you prefer). supposing that our decision rule is to declare
h1when y≥ηfor some η, for example, η= 1.65 for a 5% critical level, there are two areas
under the curve that we need to consider.
type 1 / false alarm . the blue region under the curve represents the probability of
declaring h1(i.e., we choose to reject the null) while the truth is actually h0(i.e., we
should have not rejected the null). mathematically, this probability is
pf=p[y≥η|h0] =z
y≥ηf0(y)dy. (9.28)
type 2 / miss . the pink region under the curve represents the probability of declaring
h0(i.e., we choose to keep the null) while the truth is actually h1(i.e., we should
have rejected the null). mathematically, this probability is
pm=p[y < η |h1] =z
y<ηf1(y)dy. (9.29)
figure 9.20: definition of type 1 and type 2 errors.
thepower of the decision rule is also known as the detection. it is defined as
pd=p[y≥η|h1]. (9.30)
a plot illustrating the power of the decision rule is shown in figure 9.21 . since pdis the
conditional probability of y≥ηgiven h1, it is the complement of pm, and so we have the
identity
pd= 1−pm.
some communities refer to the above quantities in terms of the counts instead of the
probabilities . the difference is that the probabilities are normalized to [0 ,1] whereas the
counts are just the raw integers obtained from running an experiment. we prefer to use the
probabilities because they are the theoretical values . if you tell us the distributions f0and
f1, we can report the probabilities. the counts, by contrast, are just another form of sample
statistics . the number of counts today may be different from the number of counts tomorrow
581chapter 9. confidence and hypothesis
figure 9.21: the power of the decision rule is the area under the curve of f1, integrated for yinside
the rejection zone.
because they are obtained from the experiments. the difference between probabilities and
counts is analogous to the difference between pmfs and histograms.
since the probability of errors changes as the decision rule changes, it is necessary to
define pf,pdandpmas functions of δ. in addition, hypothesis testing is not limited to one-
sided tests. we can define the rejection zone as rα={y|reject h0using a critical level α}.
the probabilities pfandpmare defined as
pf(δ) =z
δ(y)f0(y)dy=z
y∈rαf0(y)dy, (9.31)
pm(δ) =z
δ(y)f1(y)dy=z
y̸∈rαf1(y)dy. (9.32)
using the property that pd= 1−pm, we have that
pd(δ) = 1−pm(δ) =z
y∈rαf1(y)dy. (9.33)
note that the rejection zone does not need to depend on α. you can arbitrarily define the
rejection zone, and the probabilities pf,pm, and pdcan still be defined.
example 9.13 . find pf(δ1) and pf(δ2) for the decision rule in figure 9.18 .
solution . since f0is a gaussian with zero mean and unit variance, it follows that
pf(δ1) =z∞
1.961√
2πe−y2
2dy= 1−φ(1.92) = 0 .025,
pf(δ2) =z∞
0.51√
2πe−y2
2dy= 1−φ(0.5) = 0 .3085.
9.4.3 neyman-pearson decision
at this point you have probably observed something about the critical-value test and the
p-value test. among the four types of decision combinations, we are looking at the false
5829.4. neyman-pearson test
positive rate, or the probability of false alarm pf(δ). the critical-value test requires us to
findδsuch that pf(δ) is equal to α. that is, if you tell us the critical level α(e.g., α= 0.05),
we will find a decision rule (by telling you the cutoff) such that the false alarm rate is α.
consider an example:
example 9.14 . let α= 0.05. assume that f0is a gaussian with zero-mean and
unit-variance. let us do a one-sided test for h0:θ= 0 versus h1:θ >0. find δsuch
thatpf(δ) =α.
solution . let the decision rule δbe
δ(y) =(
1, y≥η,
0, y < η.
our goal is to find η. the probability of false alarm is
pf(δ) =z∞
η1√
2πe−y2
2dy= 1−φ(η).
equating this to α, it follows that 1 −φ(η) =αimplies η= φ−1(1−α) = 1 .65. so the
decision rule becomes
δ(y) =(
1, y ≥1.65,
0, y < 1.65.
if you apply this decision rule, you are guaranteed that the false alarm rate is α= 0.05.
but why should we aim for pf(δ)equal to α? isn’t a lower false alarm rate better?
indeed, we would not mind having a lower false alarm, so we are happy to have any δ
that satisfies pf(δ)≤α. however, changing the equality to an inequality means that we
now have a set of δinstead of a unique δ. more important, we need to pay attention to
the trade-off between pf(δ) and pd(δ). the smaller the pf(δ) a decision rule δprovides,
the smaller the pd(δ) you can achieve. this is immediately apparent from figure 9.20 and
figure 9.21 . (if you move the cutoff to the right, the gray area and the blue area will both
shrink.) therefore, the desired optimization should be formulated as: from all the decision
rules δthat have a false alarm rate of no larger than α, we pick the one that maximizes the
detection rate. the resulting decision rule is known as the neyman-pearson decision rule .
definition 9.2. theneyman-pearson decision rule is defined as the solution to the
optimization
δ∗=argmax
δpd(δ),
subject to pf(δ)≤α. (9.34)
figure 9.22 illustrates two decision rules δ∗(y) and δ(y). the first decision rule δ∗(y) is
obtained according to the critical-value approach, with α= 0.025. as we will prove shortly,
this is also the optimal neyman-pearson decision rule for a one-sided hypothesis testing at
α= 0.025. the second decision rule δ(y) has a harsher cutoff, meaning that you need an
extreme test statistic to reject the null hypothesis. clearly, the p-value obtained by δ(y) is
583chapter 9. confidence and hypothesis
less than α= 0.025. thus, δ(y) is a valid decision rule according to the neyman-pearson
formulation. however, δ(y) is not optimal because the detection rate is not maximized.
figure 9.22: two decision rules δ(y)andδ∗(y). assume that α= 0.025. then δ(y)is one of the many
feasible choices in the neyman-pearson optimization, but δ∗(y)is the optimal solution.
because of the complementary behavior of pfandpd, it follows that pdis maximized
when pfhits the upper bound. if we want to maximize the detection rate we need to stretch
the false alarm rate as much as possible. as a result, the neyman-pearson solution occurs
when pf(δ) =α, i.e., when the equality is met.
the neyman-pearson framework is a general framework for all distributions f0andf1,
as opposed to the critical-value and p-value examples, which are either gaussian or student’s
t-distribution. the solution to the neyman-pearson optimization is a decision rule known
as the likelihood ratio test . the likelihood ratio is defined as follows.
definition 9.3. thelikelihood ratio for two distributions f1(y)andf0(y)is
l(y) =f1(y)
f0(y). (9.35)
it turns out that the solution to the neyman-pearson optimization takes the form of the
likelihood ratio.
theorem 9.2. the solution to the neyman-pearson optimization is a decision rule
that checks the likelihood ratio
δ∗(y) =(
1, l (y)≥η,
0, l (y)< η,(9.36)
for some decision boundary ηwhich is a function of the critical level α.
5849.4. neyman-pearson test
what is so special about neyman-pearson decision rule?
it is the optimal decision. its optimality is defined w.r.t. maximizing the detection
rate while keeping a reasonable false alarm rate:
δ∗= argmax
δpd(δ),
subject to pf(δ)≤α.
if your goal is to maximize the detection rate while maintaining the false alarm
rate, you cannot do better than neyman-pearson.
its solution is the likelihood ratio test:
δ∗(y) =(
1, l (y)≥η,
0, l (y)< η,
where l(y) =f1(y)/f0(y) is the likelihood ratio.
the critical-value test and the p-value test are special cases of the neyman-
pearson test.
deriving the solution to the neyman-pearson optimization can be skipped if this is your
first time reading the book.
proof . given α, choose δ∗such that the false alarm rate is maximized: pf(δ∗) =α. then,
by substituting the definition of δ∗into the false alarm rate,
α=pf(δ∗) =z∞
−∞δ∗(y)f0(y)dy
=z
l(y)≥η1·f0(y)dy+z
l(y)<η0·f0(y)dy. (9.37)
now, consider another decision rule δthat is not optimal but is feasible. that means that
δsatisfies pf(δ)≤α. therefore,
α≥pf(δ) =z∞
−∞δ(y)f0(y)dy
=z
l(y)≥ηδ(y)·f0(y)dy+z
l(y)<ηδ(y)·f0(y)dy. (9.38)
our goal is to show that pd(δ∗)≥pd(δ), because by proving this result we can claim that
δ∗maximizes the detection rate.
by combining equation (9.37) and equation (9.38), we have
0≤pf(δ∗)−pf(δ)
=z
l(x)≥η(1−δ(y))f0(y)dy−z
l(y)<ηδ(y)f0(y)dy. (9.39)
585chapter 9. confidence and hypothesis
define l(y) =f1(y)
f0(y). then l(y)≥ηif and only if f1(y)≥ηf0(y). so,
pd(δ∗)−pd(δ) =z
l(y)≥η(1−δ(y))f1(y)dy−z
l(y)<ηδ(y)f1(y)dy
=z
l(y)≥η(1−δ(y))ηf0(y)dy−z
l(y)<ηδ(y)ηf0(y)dy
=η"z
l(y)≥η(1−δ(y))f0(y)dy−z
l(y)<ηδ(y)f0(y)dy#
≥0,
where the last inequality holds because of equation (9.39). therefore, we conclude that δ∗
maximizes pd. □
end of the proof. please join us again.
at this point, you may object that the likelihood ratio test (i.e., the neyman-pearson
decision rule) is very different from the hypothesis testing examples we have seen in the
previous chapter because now we need to handle the likelihood ratio l(y). rest assured
that they are the same, as illustrated by the following example.
example 9.15 . consider two hypotheses: h0:y∼gaussian(0 , σ2), and h1:y∼
gaussian( µ, σ2), with µ > 0. construct the neyman-pearson decision rule (i.e., the
likelihood ratio test).
solution . let us first define the likelihood functions. it is clear from the description
that
f0(y) =1√
2πσ2exp
−y2
2σ2
and f1(y) =1√
2πσ2exp
−(y−µ)2
2σ2
.
therefore, the likelihood ratio is
l(y) =f1(y)
f0(y)= exp
−1
2σ2(µ2−2µy)
.
the likelihood ratio test states that the decision rule is
δ∗(y) =(
1, l (y)≥η,
0, l (y)< η.
so it remains to simplify the condition l(y)⋛η. to this end, we observe that
l(y)≥η ⇐⇒ −1
2σ2(µ2−2µy)≥logη
⇐⇒ y≥µ
2−σ2
µlogη
|{z}
def=τ.
5869.4. neyman-pearson test
therefore, instead of determining η, we just need to define τbecause the decision rules
based on ηandτare equivalent.
to determine τ, neyman-pearson states that pf(δ)≤α(and at the optimal point
the equality has to hold). substituting this criterion into the decision rule,
α=pf(δ) =z
l(y)≥ηf0(y)dy
=z
y≥τf0(y)dy
=z
y≥τ1√
2πσ2e−y2
2σ2dy
= 1−φτ
σ
.
taking the inverse of the cdf, we obtain τ:
τ=σφ−1(1−α).
putting everything together, the final decision rule is
δ∗(y) =(
1, y ≥σφ−1(1−α),
0, y < σ φ−1(1−α).
so if α= 0.05 we will reject h0when y≥1.65σ. we can also replace σbyσ/√
nif
the estimator is constructed from multiple measurements.
the above example tells us that even though the likelihood ratio test may appear
complicated at first glance, the decision is the same as the good old hypothesis testing rules
we have derived. the flexibility we have gained with the likelihood ratio test is the variety
of distributions we can handle. instead of restricting ourselves to gaussians or student’s
t-distribution (which exclusively focuses on the sample averages), the likelihood ratio test
allows us to consider any distributions. the exact decision rule could be less obvious, but
the method is generalizable to a broad range of problems.
practice exercise 9.5 . in a telephone system, the waiting time is defined as the
inter-arrival time between two consecutive calls. however, it is known that sometimes
the waiting time can be mistakenly recorded as the time between three consecutive
calls (i.e., by skipping the second one). since the interarrival time of an independent
poisson process is either an exponential random variable or an erlang random variable,
depending on how many occurrences we are counting, we define the hypotheses
f0(y) =(
e−y, y ≥0,
0, y < 0,and f1(y) =(
ye−y, y ≥0,
0, y < 0.
suppose we are given one measurement y=y. find the neyman-pearson decision
rule for α= 0.05.
587chapter 9. confidence and hypothesis
solution . the likelihood ratio is
l(y) =f1(y)
f0(y)=ye−y
e−y=y, y ≥0.
substituting this into the decision rule, we have
δ∗(y) =(
1, l (y)≥η⇐⇒y≥η,
0, l (y)< η⇐⇒y < η.
it remains to determine η. inspecting pf(δ), we have that
α=pf(δ∗) =z
l(y)≥ηf0(y)dy
=z
y≥ηe−ydy=e−η.
setting e−η=α, we have that α=−logα. hence, the decision rule is
δ∗(y) =(
1, l (y)≥η⇐⇒y≥ −logα,
0, l (y)< η⇐⇒y <−logα.
forα= 0.05, we reject the null hypothesis when y≥2.9957. figure 9.23 illustrates
the hypothesis testing rule.
figure 9.23: neyman-pearson decision rule at α= 0.05.
remark . this example is instructive in that we have only one measurement y=y.
if we have repeated measurements and take the average, then the central limit the-
orem will kick in. in that case, we can resort to our favorite gaussian distribution
or student’s t-distribution instead of dealing with the exponential and the erlang
distributions. however, the example demonstrates the usefulness of neyman-pearson,
especially when the distributions are complicated.
5889.5. roc and precision-recall curve
9.5 roc and precision-recall curve
being a binary decision rule, the hypothesis testing procedure shares many similarities with
a two-class classification algorithm.3given a testing statistic or a testing sample, both
the hypothesis testing and a classification algorithm will report yes or no. therefore,
any performance evaluation metric developed for hypothesis testing is equally applicable to
classification and vice versa.
the topic we study in this section is the receiver operating characteristic (roc) curve
and the precision-recall (pr) curve. the roc curve and the pr curve are arguably the
most popular metrics in modern machine learning, in particular for classification, detection,
and segmentation tasks in computer vision. there are many unresolved questions about
these two curves and there are many debates about how to use them. our goal is not to add
another voice to the debate; rather, we would like to fill in the gap between the hypothesis
testing theory (particularly the neyman-pearson framework) and these two sets of curves.
we will establish the equivalence between the two curves and leave the open-ended debates
to you.
9.5.1 receiver operating characteristic (roc)
our approach to understanding the roc curve and the pr curve is based on the neyman-
pearson framework. under this framework, we know that the optimal decision rule w.r.t to
the neyman-pearson criterion is the solution to the optimization
δ∗(α) = argmax
δpd(δ)
subject to pf(δ)≤α.
as a result of this optimization, the decision rule δ∗will achieve a certain false alarm rate
pf(δ∗) and detection rate pd(δ∗). clearly, the decision rule δ∗changes as we change the
critical level α. accordingly we write δ∗asδ∗(α) to reflect this dependency.
what this observation implies is that as we sweep through the range of α’s, we construct
different decision rules, each one with a different pfandpd. if we denote the decision rules
byδ1, δ2, . . . , δ m, we have mpairs of false alarm rate pfand detection rate pd:
decision rule δ1: false alarm rate pf(δ1) and detection rate pd(δ1).
decision rule δ2: false alarm rate pf(δ2) and detection rate pd(δ2).
...
decision rule δm: false alarm rate pf(δm) and detection rate pd(δm).
3in a classification algorithm, the goal is to look at the testing sample yand compute certain thresholding
criteria. for example, a typical decision rule of a classification algorithm is δ(y) =(
1,wtϕ(y)≥τ
0,wtϕ(y)< τ. here,
you can think of the vector was the regression coefficient, and ϕ(·) is some kind of feature transform. the
equation says that class 1 will be reported if the inner product is larger than a threshold τ, and class 0
will be reported otherwise. therefore, a binary classification, when written in this form, is the same as a
hypothesis testing procedure.
589chapter 9. confidence and hypothesis
if we plot pd(δ) on the y-axis as a function of pf(δ) on the x-axis, we obtain a curve shown
infigure 9.24 (see the example below for the problem setting). the black curve shown on
the right is known as the receiver operating characteristic (roc) curve.
figure 9.24: an example of an roc curve, where we consider two hypotheses: h0:y∼gaussian (0,2),
andh1:y∼gaussian (3,2). we construct the neyman-pearson decision rule for a range of critical
levels α. for each αwe compute the theoretical pf(α)andpd(α), shown on the left-hand side of the
figure. the pair of (pd, pf)is then plotted as the right-hand side curve by sweeping the α’s.
the setup of the figure follows the example below.
example 9.16 . we consider two hypotheses: h0:y∼gaussian(0 ,2), and h1:y∼
gaussian(3 ,2). derive the neyman-pearson decision rule and plot the roc curve.
solution . we construct a neyman-pearson decision rule:
δ∗(y) =(
1, y ≥σφ−1(1−α),
0, y < σ φ−1(1−α).
where τis a tunable threshold. for example, if α= 0.05, then σφ−1(1−0.05) = 3 .2897,
and if α= 0.1, then σφ−1(1−0.1) = 2 .5631. therefore, the false alarm rate and the
detection rate are functions of the critical level α.
for this particular example, we have the false alarm rate and detection rate in
closed form, as functions of α:
pf(α) =z∞
σφ−1(1−α)1√
2πσ2e−y2
2σ2dy
= 1−φσφ−1(1−α)
σ
=α,
5909.5. roc and precision-recall curve
pd(α) =z∞
σφ−1(1−α)1√
2πσ2e−(y−µ)2
2σ2dy
= 1−φ
φ−1(1−α)−µ
σ
.
these give us the two curves on the left-hand side of figure 9.24 .
what is an roc curve?
it is a plot showing pdon the y-axis and pfon the x-axis.
pd= detection rate (also known as the power of the test).
pf= false alarm rate (also known as the type 1 error of the test).
the roc curve tells us the behavior of the decision rule as we change the threshold α.
a graphical illustration is shown in figure 9.25 . there are a few key observations we need
to pay attention to:
figure 9.25: interpreting the roc curve.
the roc curve must go through (0 ,0). this happens when you always keep the
null hypothesis or always declare class 0, no matter what observations. if you always
keep h0, certainly you will not make any false positive (or false alarm), because you
will never say h0is wrong. therefore, the detection rate (or the power of the test) is
also 0. this is a useless decision rule for both classification and hypothesis testing.
the roc curve must go through (1 ,1). this happens when you always reject the null
hypothesis, no matter what observations we have. if you always reject h0, you will
always say that “there is a target”. as far as detection is concerned, you are perfect
591chapter 9. confidence and hypothesis
because you have not missed any targets. however, the false positive rate is also high
because you will falsely declare a target when there is nothing. therefore, this is also
a useless decision rule.
the roc curve tells us the operating point of the decision rule as we change the thresh-
old. a threshold is a universal concept for both hypothesis testing and classification.
in hypothesis testing, we have the critical level α, say 0.05 or 0.1. in classification, we
also have a threshold for judging whether a sample should be classified as class 1 or
class 0. often in classification, the intermediate estimates are probabilities or distances
to decision boundaries. these real numbers need to be binarized to generate a binary
decision. the roc curve tells us that if you pick a threshold, your decision rule will
have a certain pfandpdas predicted by the curve. if you want to tolerate a higher
pf, you can move along the curve to find your operating point.
the ideal operating point on a roc curve is when pf= 0 and pd= 1. however, this
is a hypothetical situation that does not happen in any real decision rule.
9.5.2 comparing roc curves
because of how the roc curves are constructed, every binary decision rule has its own roc
curve. typically, when one tries to compare classification algorithms, the area under the
curve (auc ) occupied by the roc curve is compared. a decision rule having a larger auc
is often a “better” decision rule.
to illustrate the idea of comparing estimators, we consider a trivial decision rule based
on a blind guess.
example 9.17 . (a blind guess decision) consider a decision rule that we reject h0
with probability αand keep h0with probability 1 −α. we call this a blind guess, since
the decision rule ignores observation y. mathematically, this trivial decision rule is
δ(y) =(
1, with probability α,
0, with probability 1 −α.
find pf,pd, and auc.
solution . for this decision rule we compute its false positive rate (or false alarm rate)
and its true positive rate (or detection rate). however, since δ(y) is now random, we
need to take the expectation over the two random states that δ(y) can take. this gives
us
pf(α) =ez
δ(y)f0(y)dy
=z
1·f0(y)dyp[δ(y) = 1] +z
0·f0(y)dyp[δ(y) = 0]
=αz
f0(y)dy=α.
5929.5. roc and precision-recall curve
similarly, the detection rate is
pd(α) =ez
δ(y)f1(y)dy
=αz
f1(y)dy=α.
if we plot pdas a function of pf, we notice that the function is a straight line going
from (0 ,0) to (1 ,1). this decision rule is useless. comparing this with the neyman-
pearson decision rule, it is clear that neyman-pearson has a larger auc. the auc
for this trivial decision rule is the area of the triangle, which is 0.5.
figure 9.26: the roc curve of the blind guess decision rule is a straight line. the auc is 0.5.
if you set α= 0.5, then the decision rule becomes
δ(y) =(
1, with probability1
2,
0, with probability1
2.
this is equivalent to flipping a fair coin with probability 1 /2 of declaring h0and 1 /2
declaring h1. its operating point is the yellow circle.
computing the auc can be done by calling special library functions. however, to
spell out the details we demonstrate something more elementary. the program below is a
piece of matlab code plotting two roc curves corresponding to two different decision
rules. the first decision rule is the trivial decision rule, where we have just shown that
pf(α) =pd(α) =α. the second decision rule is the neyman-pearson decision rule, for
which we showed in figure 9.24 that pf(α) =αandpd(α) = 1 −φ 
φ−1(1−α)−µ
σ
.
using the matlab code below, we can plot the two roc curves shown in figure 9.26 .
% matlab code to plot roc curve
sigma = 2; mu = 3;
alphaset = linspace(0,1,1000);
pf1 = zeros(1,1000); pd1 = zeros(1,1000);
pf2 = zeros(1,1000); pd2 = zeros(1,1000);
for i=1:1000
alpha = alphaset(i);
593chapter 9. confidence and hypothesis
pf1(i) = alpha;
pd1(i) = alpha;
pf2(i) = alpha;
pd2(i) = 1-normcdf(norminv(1-alpha)-mu/sigma);
end
figure;
plot(pf1, pd1,’linewidth’, 4, ’color’, [0.8, 0, 0]); hold on;
plot(pf2, pd2,’linewidth’, 4, ’color’, [0, 0, 0]); hold off;
to compute the auc we perform a numerical integration:
auc =z
pd(α)·dpf(α)≈x
ipd(αi)·∆pf(αi)
=x
ipd(αi)·
pf(αi)−pf(αi−1)
,
where αiis the ith critical level we use to plot the roc curve. (we assume that the α’s are
sorted in ascending order.) in matlab, the commands are
auc1 = sum(pd1.*[0 diff(pf1)])
auc2 = sum(pd2.*[0 diff(pf2)])
the auc of the two decision rules computed by matlab are 0.8561 and 0.5005, respec-
tively. the small slack of 0.0005 is caused by the numerical approximation at the tail, which
can be ignored as long as you are consistent for all the roc curves.
the commands for python are analogous to the commands for matlab.
# python code to plot roc curve
import numpy as np
import matplotlib.pyplot as plt
import scipy.stats as stats
sigma = 2; mu = 3;
alphaset = np.linspace(0,1,1000)
pf1 = np.zeros(1000); pd1 = np.zeros(1000)
pf2 = np.zeros(1000); pd2 = np.zeros(1000)
for i in range(1000):
alpha = alphaset[i]
pf1[i] = alpha
pd1[i] = alpha
pf2[i] = alpha
pd2[i] = 1-stats.norm.cdf(stats.norm.ppf(1-alpha)-mu/sigma)
plt.plot(pf1,pd1)
plt.plot(pf2,pd2)
to compute the auc, the python code is (continuing from the previous code):
5949.5. roc and precision-recall curve
auc1 = np.sum(pd1 * np.append(0, np.diff(pf1)))
auc2 = np.sum(pd2 * np.append(0, np.diff(pf2)))
it is possible to get a decision rule that is worse than a blind guess. the following
example illustrates a trivial setup.
practice exercise 9.6 . (flipped neyman-pearson). consider two hypotheses
h0= gaussian(0 , σ2),
h1= gaussian( µ, σ2), µ > 0.
letαbe the critical level. the neyman-pearson decision rule is
δ∗(y) =(
1, y ≥σφ−1(1−α),
0, y < σ φ−1(1−α).
now, consider a flipped neyman-pearson decision rule
δ+(y) =(
1, y < σ φ−1(1−α),
0, y ≥σφ−1(1−α).
find pf,pd, and auc for the new decision rule δ+.
solution . since we flip the rejection zone, the probability of false alarm is
pf(α) =z
δ+(y)f0(y)dy
=zσφ−1(1−α)
−∞1√
2πσ2e−y2
2σ2dy
= φσφ−1(1−α)
σ
= 1−α.
similarly, the probability of detection is
pd(α) =z
δ+(y)f1(y)dy
=zσφ−1(1−α)
−∞1√
2πσ2e−(y−µ)2
2σ2dy
= φσφ−1(1−α)−µ
σ
= φ
φ−1(1−α)−µ
σ
.
595chapter 9. confidence and hypothesis
if you plot pdas a function of pf, you will obtain a curve shown in figure 9.27 .
the auc for this flipped decision rule is 0.1439, whereas that for neyman-pearson is
0.8561. the two numbers are complements of each other, meaning that their sum is
unity.
figure 9.27: the roc curve of a flipped neyman-pearson decision rule.
what if we arbitrarily construct a decision rule that is neither neyman-pearson nor
the blind guess? the following example demonstrates one possible choice.
practice exercise 9.7 . consider two hypotheses
h0= gaussian(0 , σ2),
h1= gaussian( µ, σ2), µ > 0.
letαbe the critical level. consider the following decision rule:
δ♣(y) =(
1,|y| ≥σφ−1(1−α),
0,|y|< σφ−1(1−α).
find pf,pd, and auc for the new decision rule δ♣.
solution . the probability of false alarm is
pf(α) =z
δ♣(y)f0(y)dy
= 1−zσφ−1(1−α)
−σφ−1(1−α)1√
2πσ2e−y2
2σ2dy
= 1−φ 
φ−1(1−α)
+ φ 
−φ−1(1−α)
= 2α.
5969.5. roc and precision-recall curve
similarly, the probability of detection is
pd(α) =z
δ♣(y)f1(y)dy
= 1−zσφ−1(1−α)
−σφ−1(1−α)1√
2πσ2e−(y−µ)2
2σ2dy
= 1−φσφ−1(1−α)−µ
σ
+ φ−σφ−1(1−α)−µ
σ
= 1−φ
φ−1(1−α)−µ
σ
+ φ
−φ−1(1−α)−µ
σ
.
if you plot pdas a function of pf, you will obtain a curve shown in figure 9.28 .
the auc for this proposed decision rule is 0.7534, whereas that of neyman-pearson
is 0.8561. therefore, the neyman-pearson decision rule is better.
figure 9.28: the roc curve of a proposed decision rule.
the matlab code we used to generate figure 9.28 is shown below. note that we
need to separate the calculations of the two curves, because the proposed curve can only
take 0 < α < 0.5. the python code is implemented analogously.
% matlab code to generate the roc curve.
sigma = 2; mu = 3;
pf1 = zeros(1,1000); pd1 = zeros(1,1000);
pf2 = zeros(1,1000); pd2 = zeros(1,1000);
alphaset = linspace(0,0.5,1000);
for i=1:1000
alpha = alphaset(i);
pf1(i) = 2*alpha;
pd1(i) = 1-(normcdf(norminv(1-alpha)-mu/sigma)-...
normcdf(-norminv(1-alpha)-mu/sigma));
end
alphaset = linspace(0,1,1000);
597chapter 9. confidence and hypothesis
for i=1:1000
alpha = alphaset(i);
pf2(i) = alpha;
pd2(i) = 1-normcdf(norminv(1-alpha)-mu/sigma);
end
figure;
plot(pf1, pd1,’linewidth’, 4, ’color’, [0.8, 0, 0]); hold on;
plot(pf2, pd2,’linewidth’, 4, ’color’, [0, 0, 0]); hold off;
import numpy as np
import matplotlib.pyplot as plt
import scipy.stats as stats
sigma = 2; mu = 3;
pf1 = np.zeros(1000); pd1 = np.zeros(1000)
pf2 = np.zeros(1000); pd2 = np.zeros(1000)
alphaset = np.linspace(0,0.5,1000)
for i in range(1000):
alpha = alphaset[i]
pf1[i] = 2*alpha
pd1[i] = 1-(stats.norm.cdf(stats.norm.ppf(1-alpha)-mu/sigma) \
-stats.norm.cdf(-stats.norm.ppf(1-alpha)-mu/sigma))
alphaset = np.linspace(0,1,1000)
for i in range(1000):
alpha = alphaset[i]
pf2[i] = alpha
pd2[i] = 1-stats.norm.cdf(stats.norm.ppf(1-alpha)-mu/sigma)
plt.plot(pf1, pd1)
plt.plot(pf2, pd2)
9.5.3 the roc curve in practice
if the neyman-pearson decision rule is the optimal rule, why don’t we always use it? the
problem is that in practice we may not have access to the distributions. for example, if we
classify images, how do we know that the data follows a gaussian distribution or a mixture
of distributions? consequently, the roc curves we discussed in the subsections above are
thetheoretical roc curves. in practice, we plot the empirical roc curves.
plotting an empirical roc curve for a binary classification method (and hypothesis
testing) is intuitive. the ingredients we need are a set of scores and a set of labels .
the scores are the probability values determining the likelihood of a sample belonging to
one class. generally speaking, for empirical data this requires looking at the training data,
building a model, and computing the likelihood. we will not go into the details of how a
binary classifier is built. instead, we assume that you have already built a binary classifier
and have obtained the scores. our goal is to show you how to plot the roc curve.
5989.5. roc and precision-recall curve
the following matlab code uses a dataset fisheriris . the code builds a binary
classifier and returns the scores.
% matlab code to train a classification algorithm.
% do not worry if you cannot understand this code.
% it is not the focus on this book.
load fisheriris
pred = meas(51:end,1:2);
resp = (1:100)’>50;
mdl = fitglm(pred,resp,’distribution’,’binomial’,’link’,’logit’);
scores = mdl.fitted.probability;
labels = [ones(1,50), zeros(1,50)];
save(’ch9_roc_example_data’,’scores’,’labels’);
to give you an idea of how the scores of the classifier look, we plot the histogram of
the scores in figure 9.29 . as you can see, there is no clear division between the two classes.
no matter what threshold τwe use, some cases will be misclassified.
figure 9.29: the distribution of probability scores obtained from a binary classifier for the dataset
fisheriris . the green vertical lines represent the threshold for turning the scores into binary decisions.
any score greater than τwill be classified as class 1, and any score that is less than τwill be classified
as class 0. these predicted labels would then be compared to the true labels to plot the roc curve.
recall that the roc curve is a function of pdversus pf. using terminology from
statistics, pdis the true positive rate and pfis the false positive rate. by sweeping a range
of decision thresholds (over the scores), we can compute the corresponding pf’s and pd’s.
on a computer this can be done by setting up two columns of labels: the true label labels
and the predicted labels prediction . for any threshold τ, we binarize the scores to turn
them into a decision vector. then we count the number of true positives, true negatives,
false positives, and false negatives. the total of these numbers will give us pfandpd.
in matlab, the above description can be easily implemented by sweeping through
the range of τ.
% matlab code to generate an empirical roc curve
load ch9_roc_example_data
599chapter 9. confidence and hypothesis
tau = linspace(0,1,1000);
for i=1:1000
idx = (scores <= tau(i));
predict = zeros(1,100);
predict(idx) = 1;
true_positive = 0; true_negative = 0;
false_positive = 0; false_negative = 0;
for j=1:100
if (predict(j)==1) && (labels(j)==1)
true_positive = true_positive + 1; end
if (predict(j)==1) && (labels(j)==0)
false_positive = false_positive + 1; end
if (predict(j)==0) && (labels(j)==1)
false_negative = false_negative + 1; end
if (predict(j)==0) && (labels(j)==0)
true_negative = true_negative + 1; end
end
pf(i) = false_positive/50;
pd(i) = true_positive/50;
end
plot(pf, pd, ’linewidth’, 4, ’color’, [0, 0, 0]);
the python codes of this problem are similar. we give them here for completeness.
# python code to generate an empirical roc curve
import numpy as np
import matplotlib.pyplot as plt
import scipy.stats as stats
scores = np.loadtxt(’ch9_roc_example_data.txt’)
labels = np.append(np.ones(50), np.zeros(50))
tau = np.linspace(0,1,1000)
pf = np.zeros(1000)
pd = np.zeros(1000)
for i in range(1000):
idx = scores<= tau[i]
predict = np.zeros(100)
predict[idx] = 1
true_positive = 0; true_negative = 0
false_positive = 0; false_negative = 0
for j in range(100):
if (predict[j]==1) and (labels[j]==1): true_positive += 1
if (predict[j]==1) and (labels[j]==0): false_positive += 1
if (predict[j]==0) and (labels[j]==1): false_negative += 1
if (predict[j]==0) and (labels[j]==0): true_negative += 1
pf[i] = false_positive/50
pd[i] = true_positive/50
plt.plot(pf, pd)
6009.5. roc and precision-recall curve
the empirical roc curve for this problem is shown in figure 9.30 . each point on the
curve is a coordinate ( pf, pd), evaluated at a particular threshold τ. mathematically, the
decision rule we used was
δ(y) =(
1, score (y)≥τ,
0, score (y)< τ.
for every τ, we have a false alarm rate and a detection rate. since this is an empirical
dataset with only 100 samples, there are many occasions where pfdoes not change but
pdincreases, or pdstays constant but pfincreases. for this particular example, we can
compute the auc, which is 0.7948.
figure 9.30: the empirical roc curve for the dataset fisheriris , using a classifier based on the
logistic regression.
note that the empirical roc is rough. it does not have the smooth concave shape of
the theoretical roc curve. one can prove that if the decision rule is neyman-pearson, i.e.,
if we conduct a likelihood ratio test, then the resulting roc curve is concave. otherwise,
you can still obtain an empirical roc curve for real datasets and classifiers. however, the
shape is not necessarily concave.
9.5.4 the precision-recall (pr) curve
in modern data science, an alternative performance metric to the roc curve is the precision-
recall (pr) curve. the precision and recall are defined as follows.
definition 9.4. let tp = true positive, fp = false positive, fn = false negative.
theprecision is defined as
precision =tp
tp+fp=pd
pd+pf, (9.40)
and the recall is defined as
recall =tp
tp+fn=pd
pd+pm=pd. (9.41)
601chapter 9. confidence and hypothesis
in this definition, tp, fp, and fn are the numbers of samples that are classified as true
positive, false positive, and false negative, respectively. however, both precision and recall are
defined as ratios of numbers. the ratios can be equivalently defined through the rates. using
our terminology, this gives us the definitions in terms of pd,pfandpm. since pd= 1−pm,
it also holds that the recall is pd.
let us take a moment to consider the meanings of precision and recall. precision is
defined as
precision =tp
tp + fp=# true positives
total # positives you claim. (9.42)
the numerator of the precision is the number of true positive samples and the denominator
is the total number of positives that you claim. this includes the true positives and the
false positives. therefore, precision measures how trustworthy your claim is. there are two
scenarios to consider:
high precision : this means that among all the positives you claim, many of them are
the true positives. therefore, whatever you claim is trustworthy. one possibility for
obtaining a high precision is that the critical level αof the neyman-pearson decision
rule approaches 1. in other words, you are very accepting of the null hypotheses. thus,
whenever you reject, it will be a reliable reject.
low precision : this means that you are overclaiming the positives, and so there are
many false positives. thus, even though you claim many positives, not all are trust-
worthy. one reason why low precision occurs is that you are too eager to reject the
null. thus you tend to overkill the unnecessary cases.
a similar analysis can be applied to the recall. the recall is defined as
recall =tp
tp + fn=# true positives
total # positives in the distribution. (9.43)
the difference between the recall and the precision is the denominator. for recall, the
denominator is the total number of positives in the distribution . we are not interested
in knowing what you have claimed but in knowing how many of them are there in the
distribution. if you examine the definition using pd, you can see that recall is the probability
of detection — how successfully you can detect a target. a high recall and a low recall can
occur in two situations:
high recall : this means that you are very good at detecting the target or rejecting
the null appropriately. a high recall can happen when the critical level αis low so that
you never miss a target. however, if the critical level αis low, you will suffer from a
low precision.
low recall : this means that you are too accepting of the null hypotheses, and so you
never claim that there is a target. as a result the number of successful detections is
low. however, having a low recall can buy you high precision because you do not reject
the null unless it has extreme evidence (hence there is no false alarm.)
as you can see from the discussions above, the precision-recall has a trade-off, just as
the roc curve does. since the pr curve and roc curve are derived from pfandpd, there
is a one-to-one correspondence. this can be proved by rearranging the terms in the previous
theorem.
6029.5. roc and precision-recall curve
theorem 9.3. thefalse alarm rate pfand the detection rate pdcan be expressed
in terms of the precision and recall as
pf=recall(1 −precision)
precision, (9.44)
pd= recall .
this result implies that whenever we have an roc curve we can convert it to a pr curve.
moreover, whenever we have a pr curve we can convert it to an roc curve. therefore,
there is no additional information one can squeeze out by converting the curves. what we
can claim, at most, is that the two curves offer different ways of interpreting the decision
rule.
to illustrate the equivalence between an roc curve and a pr curve, we plot two
different decision rules in figure 9.31 . any point on the roc curve will have a corresponding
point on the pr curve, and vice versa.
figure 9.31: there is a one-to-one correspondence between the roc curve and the pr curve.
the matlab and python codes for generating the pr curve are straightforward.
assuming that we have run the code used to generate figure 9.28 , we plot the pr curve as
follows (this will give us figure 9.31 ).
% matlab code to generate a pr curve
precision1 = pd1./(pd1+pf1);
precision2 = pd2./(pd2+pf2);
recall1 = pd1;
recall2 = pd2;
plot(recall1, precision1, ’linewidth’, 4); hold on;
plot(recall2, precision2, ’linewidth’, 4); hold off;
603chapter 9. confidence and hypothesis
practice exercise 9.8 . suppose that the decision rule is a blind guess:
δ(y) =(
1, with probability α,
0, with probability 1 −α,
plot the roc curve and the pr curve.
solution : as we have shown earlier, pf(α) and pd(α) for this decision rule are pf(α) =
αandpd(α) =α. therefore,
precision =pd
pd+pf=α
α+α=1
2,and recall = pd=α.
thus the pr curve is a straight line with a level of 0.5.
figure 9.32: the pr curve of a blind-guess decision rule is a straight line.
practice exercise 9.9 . convert the roc curve in figure 9.30 to a pr curve.
solution : the conversion is done by first computing pfandpd. defining the precision
and recall in terms of pfandpd, we plot the pr curves below.
figure 9.33: the pr curve of a real dataset.
6049.6. summary
as you can see from the figure, the pr curve behaves very differently from the
roc curve. it is sometimes argued that the two curves can be interpreted differently,
even though they describe the same decision rule for the same dataset.
9.6 summary
in this chapter, we have discussed five principles for quantifying the confidence of an esti-
mator and making statistical decisions. to summarize the chapter, we clarify a few common
misconceptions about these topics.
confidence interval . students frequently become confused about the meaning of a
confidence interval. it is not the interval that 95% of the samples will fall inside. it
is also not the interval within which the estimator has a 95% chance to show up.
a confidence interval is a random interval that has a 95% chance of including the
population parameter. a better way to think about a confidence interval is to think of
it as an alternative to a point estimate. a point estimate only gives a point, whereas
a confidence interval extends the point to an interval. all the randomness of the point
estimate is also there in the confidence interval. however, if the confidence interval is
narrow, there is a good chance for the point estimate to be accurate.
bootstrapping . the most common misconception about bootstrapping is that it can
create something from nothing. another misconception is that bootstrapping can make
your estimates better. both beliefs are wrong. bootstrapping is a technique for esti-
mating the estimator’s variance, and consequently it provides a confidence interval.
bootstrapping does not improve the point estimate, no matter how many bootstrap-
ping samples you synthesize. bootstrapping works because the sampling with the re-
placement step is equivalent to drawing samples from the empirical distribution. the
whole process relies on the proximity between the empirical distribution and the true
population. if you do not have enough samples and the empirical distribution does not
approximate the population, bootstrapping will not work. therefore, bootstrapping
does not create something from nothing; it uses whatever you have and tells you how
reliable the estimate is.
hypothesis testing . students are often overwhelmed at first by the great number of
tests one can use for hypothesis testing, e.g., p-value, critical value, z-test, t-test, χ2
test, f-test, etc. our advice is to forget about them and remember that hypothesis
testing is a court trial. your job is to decide whether you have enough evidence to
declare that the defendant is guilty. to reach a guilty verdict, you need to make sure
that the test statistic is unlikely to happen. therefore, the best practice is to draw
the distributions of the test statistic and ask yourself how likely is it that the test
statistic has such a value. when you draw the pictures of the distributions, you will
know whether you should use a gaussian z, a student’s t, aχ2, af-statistic, etc.
when you examine the likelihood of the test statistic, you will know whether you want
to use the p-value or the critical value. if you follow this principle, you will never be
confused by the oceans of tests you find in the textbooks.
605chapter 9. confidence and hypothesis
neyman-pearson . beginners often find neyman-pearson abstract and do not under-
stand why it is useful. in this chapter, however, we have explained why we need to
understand neyman-pearson. it is a very general framework for many kinds of hy-
pothesis testing problems. all it says is that if we want to maximize the detection rate
while maintaining the false alarm rate, then the optimal testing procedure boils down
to the critical-value test and the p-value test. this gives us a certificate that our usual
hypothesis testing is optimal according to the neyman-pearson framework.
roc and pr curves . on the internet nowadays there is a huge quantity of articles,
blogs, and tutorials about howto plot the roc curve and the pr curve. often these
curves are explained through programming examples such as python, r, or matlab.
our advice for studying the roc curve and the pr curve is to go back to the neyman-
pearson framework. these two curves do not come out of the blue. the roc curve is
the natural figure explaining the objective and the constraint in the neyman-pearson
framework. by changing the coordinates, we obtain the pr curve. therefore, the two
curves are the same in terms of the amount of information, but they offer different
interpretations.
9.7 reference
confidence interval
9-1 dimitri p. bertsekas and john n. tsitsiklis, introduction to probability , athena sci-
entific, 2nd edition, 2008. chapter 9.1.
9-2 michael j evans and jeffrey s. rosenthal, probability and statistics , w. h. freeman,
2nd edition, 2009. chapter 6.3.
9-3 robert v. hogg, joseph w. mckean, and allen t. craig, introduction to mathematical
statistics , pearson, 7th edition, 2013. chapter 4.2.
9-4 larry wasserman, all of statistics , springer 2003. chapter 6.
9-5 alberto leon-garcia, probability, statistics, and random processes for electrical en-
gineering , prentice hall, 3rd edition, 2008. chapter 8.4.
bootstrapping
9-6 trevor hastie, robert tibshirani, and jerome friedman, elements of statistical learn-
ing, springer, 2nd edition. chapter 8.2.
9-7 larry wasserman, all of statistics , springer 2003. chapter 8.
9-8 michael j evans and jeffrey s. rosenthal, probability and statistics , w. h. freeman,
2nd edition, 2009. chapter 6.4.
9-9 robert v. hogg, joseph w. mckean, and allen t. craig, introduction to mathematical
statistics , pearson, 7th edition, 2013. chapter 4.9.
6069.8. problems
hypothesis testing
9-10 robert v. hogg, joseph w. mckean, and allen t. craig, introduction to mathematical
statistics , pearson, 7th edition, 2013. chapter 4.5.
9-11 athanasios papoulis and s. unnikrishna pillai, probability, random variables and
stochastic processes , mcgraw-hill, 4th edition, 2001. chapter 8.
9-12 alberto leon-garcia, probability, statistics, and random processes for electrical en-
gineering , prentice hall, 3rd edition, 2008. chapter 8.5.
9-13 dimitri p. bertsekas and john n. tsitsiklis, introduction to probability , athena sci-
entific, 2nd edition, 2008. chapter 9.
9-14 michael j evans and jeffrey s. rosenthal, probability and statistics , w. h. freeman,
2nd edition, 2009. chapter 6.3.
9-15 larry wasserman, all of statistics , springer 2003. chapter 10.
9-16 laura simon, introduction to mathematical statistics , penn state university stat
415 textbook, online materials. accessed 12/2020. https://online.stat.psu.edu/
stat415/
neyman-pearson and roc curves
9-17 robert v. hogg, joseph w. mckean, and allen t. craig, introduction to mathematical
statistics , pearson, 7th edition, 2013. chapter 8.
9-18 h. vincent poor, an introduction signal detection and estimation , springer, 1998.
9-19 bernard c. levy, principles of signal detection and parameter estimation , springer,
2008.
9-20 steven m. kay, fundamentals of statistical signal processing: estimation theory ,
prentice-hall, 1993.
9-21 steven m. kay, fundamentals of statistical signal processing: detection theory , prentice-
hall, 1998.
9.8 problems
exercise 1.
consider i.i.d. gaussian random variables x1, . . . , x nwith an unknown mean θand a known
variance σ2= 1. suppose n= 30. find the confidence level 1 −αfor the confidence intervals
of the mean bθ:
(a)i= [bθ−2.14σ√
n,bθ +2.14σ√
n]
(b)i= [bθ−1.85σ√
n,bθ +1.85σ√
n]
607chapter 9. confidence and hypothesis
exercise 2.
suppose that we have conducted an experiment with n= 100 samples. a 95% confidence
interval of the mean was 0 .45≤µ≤0.82.
(a) would a 99% confidence interval calculated from the sample data be wider or narrower?
(b) is it correct to interpret the confidence interval as saying that there is a 95% chance
thatµis between 0.49 and 0.82? you may answer yes, no, or partially correct. explain.
(c) is it correct to say that if we conduct the experiment 1000 times, there will be 950
confidence intervals that will contain µ? you may answer yes, no, or partially correct.
explain.
exercise 3.
suppose that we have conducted an experiment. we know that σ= 25. we obtained n= 20
samples and found that the sample mean is bθ = 1014.
(a) construct a 95% two-sided confidence interval of bθ.
(b) construct a 95% one-sided confidence interval (the lower tail) of bθ.
exercise 4.
letx1, . . . , x nbe i.i.d. gaussian with xn∼gaussian(0 ,1). let yn=exn, and suppose
we have n= 100 samples. we want to compute a 95% confidence interval for skewness.
(a) randomly subsample the dataset with b= 30 samples. repeat the exercise 5 times.
plot the resulting histograms using matlab or python.
(b) repeat (a) for m= 500 times and compute the 95% bootstrapped confidence interval
of the skewness.
(c) try using a larger b= 70 and a smaller b= 10. report the 95% bootstrapped
confidence interval of the skewness.
exercise 5.
letx1, . . . , x nbe i.i.d. uniform with xn∼uniform(0 , θ). let bθ = max {x1, . . . , x n}.
generate a dataset of n= 50 with θ= 1.
(a) find the distribution of the estimator bθ.
(b) show that p[bθ =θ] = 1−(1−(1/n))n. thus, as n→ ∞ , we have p[bθ =θ] = 0.
(c) use python or matlab to generate the histogram of bθ from bootstrapping. how
does the bootstrapped histogram look as ngrows? why?
exercise 6.
letxbe a gaussian random variable with unknown mean and unknown variance. it was
found that with n= 15,
nx
n=1xn= 250 ,nx
n=1x2
n= 10000 .
6089.8. problems
find a 95% confidence interval of the mean of x.
exercise 7.
letbθ be the sample mean of a dataset containing nsamples. it is known that the samples
are drawn from gaussian( θ,32). find nsuch that
p[bθ−1≤θ≤bθ + 1] = 0 .95.
exercise 8.
which of the following statements are valid hypothesis testing problems?
(a)h0:µ= 25 and h1:µ̸= 25.
(b)h0:σ >10 and h1:σ= 10.
(c)h0:x= 50 and h1:x̸= 50.
(d)h0:p-value = 0.1, h1:p-value = 0.5.
exercise 9.
it is claimed that the mean is θ= 12 with a standard deviation 0.5. consider h0:θ= 12
andh1:θ <12. ten samples are obtained, and it is found that bθ = 13 .5. with a 95%
confidence level, should we accept or reject the null hypothesis?
exercise 10.
consider a hypothesis testing problem: h0:θ= 175 versus an alternative hypothesis h1:
θ >175. assume n= 10 and σ= 20.
(a) find the type 1 error if the critical region is bθ>185.
(b) find the type 2 error if the true mean is 195.
exercise 11.
consider h0:θ= 30000 versus an alternative hypothesis h1:θ >30000. suppose n= 16,
and let σ= 1500.
(a) if we want α= 0.01, what is zα?
(b) what is the type 2 error when θ= 31000?
exercise 12.
letwn∼gaussian(0 , σ2), and consider two hypotheses:
h0: xn=θ0+wn, n = 1, . . . , n,
h1: xn=θ1+wn, n = 1, . . . , n.
letx= (1/n)pn
n=1xn.
609chapter 9. confidence and hypothesis
(a) show that the likelihood of observing x1, . . . , x ngiven h0is
fx(x|h0) =1
(2πσ2)n/2exp(
−1
2σ2nx
n=1(xn−θ0)2)
.
(b) find the likelihood fx(x|h1) of observing x1, . . . , x ngiven h1.
(c) the likelihood ratio test states that
fx(x|h1)
fx(x|h0)≷h1
h0τ.
show that the likelihood ratio test is given by
x≷h1
h0θ0+θ1
2+σ2logτ
n(θ1−θ0).
610chapter 10
random processes
in modern data science, many problems involve time. the stock market changes every
minute; a speech signal changes every millisecond; a car changes its steering angle constantly;
the examples are endless. a common theme among all these examples is randomness. we
do not know whether a stock will go up or down tomorrow, although we may be able to
make some predictions based on previous observations. we do not know the next word of a
sentence, but we can guess based on the context. random processes are tools that can be
applied to these situations. we treat a random process as an infinitely long vector of random
variables where the correlations between the individual variables define the statistical prop-
erties of the process. if we can determine these correlations, we will be able to summarize
the past and predict the future.
the objective of this chapter is to introduce the basic concepts of random processes .
given the breadth of the subject, we can only cover the most elementary results, but they
are sufficient for many engineering and data science problems. however, there are complex
situations for which these elementary results will be insufficient. the references at the end
of this chapter contain more in-depth discussions of random processes.
plan of this chapter
we begin by outlining the definition of random processes and ways to characterize their
randomness in section 10.1. in section 10.2 we discuss the mean function, the autocorrelation
function, and the autocovariance function of a random process. in section 10.3 we look at
a special subclass of random processes known as the wide-sense stationary processes. wide-
sense stationary processes allow us to use tools in the fourier domain to make statistical
statements. based on wide-sense stationary processes, we discuss power spectral density in
section 10.4. with this concept, we can ask what will happen to the random process when we
pass it through a linear transformation. in section 10.5 we discuss such interactions between
the random process and a linear time-invariant system. finally, we discuss a practical usage
of random processes in the subject of optimal linear filters in section 10.6.
611chapter 10. random processes
10.1 basic concepts
10.1.1 everything you need to know about a random process
here is the single most important thing you need to remember about random processes:
what is a random process?
a random process is a function indexed by a random key .
that’s it. now you may be wondering what exactly a “function indexed by a random key ”
means. to help you see the picture, we consider two examples.
example 10.1 . we consider a set of straight lines. we define two random variables a
andbthat are uniformly distributed in a certain range. we then define a function:
f(t) =at+b, −2≤t≤2. (10.1)
clearly, f(t) is a function of time t. but since aandbare random, f(t) is also random.
the randomness is caused by aandb. to emphasize this dependency, we write f(t) as
f(t, ξ) =a(ξ)t+b(ξ),−2≤t≤2,
where ξ∈ω denotes the random index of the constants ( a, b) and ω is the sample
space of ξ. therefore, by picking a different pair of constants ( a(ξ), b(ξ)), we will have
a different function f(t, ξ), which in our case is a straight line of different slope and
y-intercept.
-2 -1 0 1 2
t-1-0.500.51f(t)
figure 10.1: the set of straight lines f(x) =ax+bwhere a, b∈r.
as a special case of the example, suppose that the sample space contains only
two pairs of constants: ( a, b) = (1 .2,0.6) and ( a, b) = (−0.75,1.8). the probability of
61210.1. basic concepts
getting either pair is1
2. then the function f(t, ξ) will take two forms:
f(t, ξ) =(
1.2t+ 0.6, with probability1
2,
−0.75t+ 1.8, with probability1
2.
every time you pick a sample you pick one of the two functions, either f(t, ξ1) or
f(t, ξ2). so we say that f(t, ξ) is a random process because it is a function f(t) indexed
by a random key ξ.
example 10.2 . this example studies the function
f(t) = cos( ω0t+ θ),−1≤t≤1,
where θ is a random phase distributed uniformly over the range [0 ,2π]. depending on
the randomness of θ, the function f(t) will take a different phase offset. to emphasize
this dependency, we write
f(t, ξ) = cos( ω0t+ θ(ξ)),−1≤t≤1. (10.2)
-1 -0.5 0 0.5 1
t-2-1012f(t)
figure 10.2: the set of phase-shifted cosines f(t) = cos( ω0t+θ)where θ∈[0,2π].
again, ξdenotes the index of the random variable θ. since θ is drawn uniformly
from the interval [0 ,2π], the following functions are two possible realizations:
f(t, ξ1) = cos
ω0t+3π
4
,−1≤t≤1,
f(t, ξ2) = cos
ω0t−7π
3
,−1≤t≤1.
just as with the previous example, f(t) is a function indexed by a random key ξ.
these two examples should give you a feeling for what to expect from a random process.
a random process is quite similar to a random variable because they are both contained
in a certain sample space. for (discrete) random variables, the sample space is a collection
of outcomes {ξ1, ξ2, . . . , ξ n}. the random variable x:f →ris a mapping that maps
ξntox(ξn), where x(ξn) is a number. for random processes, the sample space is also
613chapter 10. random processes
{ξ1, ξ2, . . . , ξ n}. however, the mapping xdoes not map ξnto anumber x(ξn) but to a
function x(t, ξn). a function has the time index t, which is absent in the number. therefore,
for the same ξn,x(t1, ξn) can take one value and x(t2, ξn) can take another value.
figure 10.3: the sample space of a random process x(t, ξ)contains many functions. therefore, each
random realization is afunction .
figure 10.3 shows the sample space of a random process. each outcome in the sample
space is a function. the probability of getting a function is specified by the probability
mass or the probability density of the associated random key ξ. if you put your hand into
the sample space, the sample you pick will be a function that will change with time and is
indexed by the random key. from our discussions of joint random variables in chapter 5,
you can think of the function as a vector. when you pull a sample from the sample space,
you pull the entire vector and not just an element.
10.1.2 statistical and temporal perspectives
since a random process is a function indexed by a random key, it is a two-dimensional object.
it is a function both of time tand of the random key ξ. that’s why we use the notation
x(t, ξ) to denote a random process. these two axes play different roles, as illustrated in
figure 10.4 .
temporal perspective : let us fix the random key at ξ=ξ0. this gives us a function
x(t, ξ0). since ξis already fixed at ξ0, we are looking at a particular realization drawn
from the sample space. this realization is expressed as a function x(t, ξ0), which is just
a deterministic function that evolves over time. there is no randomness associated with
it. this is analogous to a random variable. while xitself is a random variable, by fixing
the random key ξ=ξ0,x(ξ0) is just a real number. for random processes, x(t, ξ0) now
becomes a function.
since x(t, ξ0) is a function that evolves over time, we view it along the horizontal axis.
for example, we can study the sequence
x(t1, ξ0), x(t2, ξ0), . . . , x (tk, ξ0),
where t1, . . . , t kare the time indices of the function. this sequence is deterministic and is
just a sequence of numbers, although the numbers evolve as tchanges.
statistical perspective : the other perspective, which could be slightly more abstract,
is the statistical perspective. let us fix the time at t=t0. the random key ξcan take any
61410.1. basic concepts
(a) temporal perspective (b) statistical perspective
figure 10.4: temporal and statistical perspectives of a random process. for the temporal perspective
(which we call the horizontal perspective), we fix the random key ξand look at the function in time.
for the statistical perspective (which we call the vertical perspective), we fix the time and look at the
function at different random keys .
state defined in the sample space. so if the sample space contains {ξ1, . . . , ξ n}, the sequence
{x(t0, ξ1), . . . , x (t0, ξn)}is a sequence of random variables, because the ξ’s can go from
one state to another state.
a good way to visualize the statistical perspective is the vertical perspective in which
we write the sequence as a vertical column of random variables:
x(t0, ξ1)
x(t0, ξ2)
...
x(t0, ξn)
that is, if you fix the time at t=t0, you are getting a sequence of random variables. the
probability of getting a particular value x(t0) depends on which random state you land on.
why do we bother to differentiate the temporal perspective and the statistical per-
spective? the reason is that the operations associated with the two are different, even if
sometimes they give you the same result. for example, if we take the temporal average of
the random process, we get a number:
x(ξ) =1
tzt
0x(t, ξ)dt. (10.3)
we call this the “temporal average” because we have integrated the function over time. the
resulting value will not change with time. however, x(ξ) depends on the random key you
provide. if you pick a different random realization, x(ξ) will take a different value. so the
temporal average is a random variable .
on the other hand, if we take the statistical average of the random process, we get
e[x(t)] =z
ωx(t, ξ)p(ξ)dξ, (10.4)
615chapter 10. random processes
where p(ξ) is the pdf of the random key ξ. we call this the statistical average because we
have taken the expectation over all possible random keys. the resulting object e[x(t)] is
deterministic but a function of time.
no matter how you look at the temporal average or the statistical average, they are
different with the following exception: that x(ξ) = const and e[x(t)] = const, for example,
x(ξ) =e[x(t)] = 0. this happens only for some special (and useful) random processes
known as ergodic processes that allow us to approximate the statistical average using the
temporal average, with some guarantees derived from the law of large numbers. we will
return to this point later.
example 10.3 . let a∼uniform[0 ,1]. define x(t, ξ) =a(ξ) cos(2 πt).
in this example, the magnitude a(ξ) is a random variable depending on the
random key ξ. for example if we draw ξ1, perhaps we will get a value a(ξ1) = 0 .5.
then x(t, ξ1) = 0 .5 cos(2 πt). to take another example, if we draw ξ2, we may get
a(ξ2) = 1. then x(t, ξ2) = 1 cos(2 πt).figure 10.5 shows a few random realizations
of the cosines. we can look at x(t, ξ) from the statistical and the temporal views.
-2 -1 0 1 2-1-0.500.51
x1(t)
x2(t)
x3(t)
x4(t)
x5(t)
figure 10.5: five different realizations of the random process x(t) =acos(2 πt).
statistical view : fix t(for example t= 10). in this case, we have
x(t, ξ) =a(ξ) cos(2 π(10)) = a(ξ) cos(20 π),
which is a random variable because cos(20 π) is a constant. the randomness of
xcomes from the fact that a(ξ)∼uniform[0 ,1].
temporal view : fix ξ(for example a(ξ) = 0 .7). in this case, we have
x(t, ξ) = 0 .7 cos(2 πt),
which is a deterministic function of t.
example 10.4 . let abe a discrete random variable with a pmf
p(a= +1) =1
2andp(a=−1) =1
2.
61610.1. basic concepts
we define the function x[n, ξ] =a(ξ)(−1)n. in this example, acan only take two
states. if a= +1, then x[n, ξ] = (−1)n. ifa=−1, then x[n, ξ] = (−1)n+1.
-1.5-1-0.500.511.5
0 1 2 3 4 5x1(n)
-1.5-1-0.500.511.5
0 1 2 3 4 5x2(n)
figure 10.6: realizations of the random process x[n] =a(−1)n.
the graphical illustration of this example is shown in figure 10.6 . again, we can
look at x[n, ξ] from two views.
statistical view : fix n, say n= 10. then,
x(ξ) =(
(−1)10= 1, with prob 1 /2,
(−1)11=−1, with prob 1 /2,
which is a bernoulli random variable.
temporal view : fix ξ. then,
x[n] =(
(−1)n, ifa= +1 ,
(−1)n+1, ifa=−1,
which is a time series.
in this example, we see that the sample space of x(n, ξ) consists of only two functions
with probabilities
p(x[n] = (−1)n) =1
2,
p(x[n] = (−1)n+1) =1
2,
therefore, if there is a sequence outside the sample space, e.g.,
p 
x[n] =1 1 1 −1 1 −1···
= 0
then the probability of obtaining that sequence is 0.
what do we mean by statistical average and temporal average?
statistical average: take the expectation of x(t, ξ) over ξ. this is the vertical
617chapter 10. random processes
average.
temporal average: take the expectation of x(t, ξ) over t. this is the horizontal
average.
in general, statistical average ̸= temporal average.
10.2 mean and correlation functions
given a random variable, we often want to know the expectation and variance, and often
we also want to know the expectation and variance for the random processes. nevertheless,
we need to consider the time axis. in this section, we discuss the mean function and the
autocorrelation function .
10.2.1 mean function
definition 10.1. themean function µx(t)of a random process x(t)is
µx(t) =e[x(t)]. (10.5)
let’s consider the “expectation” of x(t). recall that a random process is actually x(t, ξ)
where ξis the random key. therefore, the expectation is taken with respect to ξ, or to state
it more explicitly,
µx(t) =e[x(t)] =z
ωx(t, ξ)p(ξ)dξ,
where p(ξ) is the pdf of the random key. this is an abstract definition, but it is not difficult
to understand if you follow the example below.
example 10.5 . let a∼uniform[0 ,1], and let x(t) =acos(2 πt). find µx(t).
solution . the solution to this problem is actually very simple:
µx(t) =e[x(t)] =e[acos(2 πt)]
= cos(2 πt)e[a] =1
2cos(2 πt).
so the answer is µx(t) =1
2cos(2 πt).
we can link the equations to the definition more explicitly. to do so, we rewrite
x(t) as
x(t, ξ) =a(ξ) cos(2 πt).
61810.2. mean and correlation functions
then we take the expectation over a:
µx(t) =z
ωx(t, a)pa(a)da=z1
0acos(2 πt)·1da
= cos(2 πt)a2
21
0=1
2cos(2 πt).
-2 -1.5 -1 -0.5 0 0.5 1 1.5 2-1-0.500.51
figure 10.7: the mean function of x(t) =acos(2 πt).
an illustration is provided in figure 10.7 , in which we observe many random
realizations of the random process x(t, ξ). on top of these, we also see the mean
function. the way to visualize the mean function is to use the statistical perspective .
that is, fix a time tand look at all the possible values that the function can take. for
example, if we fix t=t0, then we will have a set of realizations of one random variable:

0.71 cos(2 πt0),0.58 cos(2 πt0), . . . , 0.93 cos(2 πt0)
→take expectation
therefore, when we take the expectation, it is that of the underlying random variable.
if we move to another timestamp t=t1, we will have a different expectation because
cos(2 πt0) now becomes cos(2 πt1).
the matlab/python codes used to generate figure 10.7 are shown below. you can
also replace the line 0.5*cos(2*pi*t) by the mean function mean(x) (in matlab).
% matlab code for example 10.5
x = zeros(1000,20);
t = linspace(-2,2,1000);
for i=1:20
x(:,i) = rand(1)*cos(2*pi*t);
end
plot(t, x, ’linewidth’, 2, ’color’, [0.8 0.8 0.8]); hold on;
plot(t, 0.5*cos(2*pi*t), ’linewidth’, 4, ’color’, [0.6 0 0]);
# python code for example 10.5
x = np.zeros((1000,20))
619chapter 10. random processes
t = np.linspace(-2,2,1000)
for i in range(20):
x[:,i] = np.random.rand(1)*np.cos(2*np.pi*t)
plt.plot(t,x,color=’gray’)
plt.plot(t,0.5*np.cos(2*np.pi*t),color=’red’)
plt.show()
example 10.6 . let θ ∼uniform[ −π, π], and let x(t) = cos( ωt+ θ). find µx(t).
solution .
µx(t) =e[cos(ωt+ θ)] =zπ
−πcos(ωt+θ)·1
2πdθ= 0.
again, as in the previous example, we can try to map this simple calculation with the
definition. write x(t) as
x(t, ξ) = cos( ωt+ θ(ξ)).
then the expectation is
µx(t) =z
ωcos(ωt+θ)pθ(θ)dθ
=zπ
−πcos(ωt+θ)·1
2πdθ= 0.
-2 -1.5 -1 -0.5 0 0.5 1 1.5 2-1-0.500.51
figure 10.8: the mean function of x(t) = cos( ωt+ θ) .
figure 10.8 illustrates the random realizations for x(t) = cos( ωt+ θ) and the
mean function. the zero mean should not be a surprise because if we take the statistical
average (the vertical average) across all the possible values at any time instant, the
positive and negative values of the realizations will make the mean zero.
we should emphasize that the statistical average is not the same as the temporal
average, even if they give you the same value. why do we say that? if we calculate
thetemporal average of the function cos( ωt+θ0) for a specific value θ = θ0, then we
62010.2. mean and correlation functions
have
x=1
tzt
0cos(ωt+θ0)dt= 0,
assuming that tis a multiple of the cosine period. this implies that the temporal
average is zero, which is the same as the statistical average. this gives us an example
in which the statistical average and the temporal average have the same value, although
we know they are two completely different things.
the matlab/python codes used to generate figure 10.8 are shown below.
% matlab code for example 10.6
x = zeros(1000,20);
t = linspace(-2,2,1000);
for i=1:20
x(:,i) = cos(2*pi*t+2*pi*rand(1));
end
plot(t, x, ’linewidth’, 2, ’color’, [0.8 0.8 0.8]); hold on;
plot(t, 0*cos(2*pi*t), ’linewidth’, 4, ’color’, [0.6 0 0]);
# python code for example 10.6
x = np.zeros((1000,20))
t = np.linspace(-2,2,1000)
for i in range(20):
theta = 2*np.pi*(np.random.rand(1))
x[:,i] = np.cos(2*np.pi*t+theta)
plt.plot(t,x,color=’gray’)
plt.plot(t,np.zeros((1000,1)),color=’red’)
plt.show()
example 10.7 . let us consider a discrete-time random process. let x[n] =sn, where
s∼uniform[0 ,1]. find µx[n].
µx[n] =e[sn] =z1
0snds=1
n+ 1.
in this example the randomness goes with the constant s. thus, if we write x[n] as
x[n, ξ] = [s(ξ)]n,
the expectation is
e[x[n]] =z
ωsnps(s)ds=z1
0sn·1ds=1
n+ 1.
the graphical illustration is provided in figure 10.9 .
621chapter 10. random processes
-0.200.20.40.60.811.2
0 5 10 15 20
figure 10.9: the mean function of x[n] =sn, where s∼uniform [0,1].
the matlab code used to generate figure 10.9 is shown below. we skip the python
implementation because it is straightforward.
% matlab code for example 10.7
t = 0:20;
for i=1:20
x(:,i) = rand(1).^t;
end
stem(t, x, ’linewidth’, 2, ’color’, [0.8 0.8 0.8]); hold on;
stem(t, 1./(t+1), ’linewidth’, 2, ’markersize’, 8);
10.2.2 autocorrelation function
in random processes, the notions of “variance” and “covariance” are trickier than for random
variables. let us first define the concept of an autocorrelation function .
definition 10.2. theautocorrelation function of a random process x(t)is
rx(t1, t2) =e[x(t1)x(t2)]. (10.6)
rx(t1, t2) is not difficult to calculate — just integrate x(t1)x(t2) using the appropriate
pdfs.
example 10.8 . let a∼uniform[0 ,1],x(t) =acos(2 πt). find rx(t1, t2).
solution .
rx(t1, t2) =e[acos(2 πt1)acos(2 πt2)]
=e[a2] cos(2 πt1) cos(2 πt2) =1
3cos(2 πt1) cos(2 πt2).
62210.2. mean and correlation functions
example 10.9 . let θ ∼uniform[ −π, π],x(t) = cos( ωt+ θ). find rx(t1, t2).
solution .
rx(t1, t2) =e[cos(ωt1+ θ) cos( ωt2+ θ)]
=1
2πzπ
−πcos(ωt1+θ) cos( ωt2+θ)dθ
(a)=1
2πzπ
−π1
2
cos(ω(t1+t2) + 2θ) + cos( ω(t1−t2))
dθ
=1
2cos
ω(t1−t2)
,
where in (a) we applied the trigonometric formula:
cosacosb=1
2[cos(a+b) + cos( a−b)],
as you can see, the calculations are not difficult. the tricky thing is the interpretation
ofrx(t1, t2).
how do we understand the meaning of e[x(t1)x(t2)]?
e[x(t1)x(t2)] is analogous to the correlation e[xy] between two random variables
xandy.
the autocorrelation function e[x(t1)x(t2)] is analogous to the correlation e[xy] in rela-
tion to a pair of random variables. in our discussions of e[xy], we mentioned that e[xy]
could be regarded as the inner product of two vectors, and so it is a measure of the closeness
between xandy. now, if we substitute xandywith x(t1) and x(t2) respectively, then
we are effectively asking about the closeness between x(t1) and x(t2). so, in a nutshell, the
autocorrelation function tells us the correlation between the function at two different time
stamps.
what do we mean by the correlation between two timestamps? remember that x(t1)
andx(t2) are two random variables. consider the following example.
example 10.10 . letx(t) =acos(2 πt), where a∼uniform[0 ,1]. find e[x(0)x(0.5)].
solution . ifx(t) =acos(2 πt), then
x(0) = acos(0) = a,
x(0.5) = acos(π) =−a.
when you have two random variables, you consider their correlations. using this ex-
623chapter 10. random processes
ample, we have that
e[x(0)x(0.5)] =−e[a·a]
=−e[a2] =−1
3.
a picture will reveal what is happening. figure 10.10 presents the realizations of the
random process x(t) =acos(2 πt). if we consider x(0) and x(0.5), each of them is a
random variable, and thus we can ask about their pdfs. it is obvious from the illustration
that the random variable x(0) has a pdf that is a uniform distribution from 0 to 1,
whereas the random variable x(0.5) has a pdf that is a uniform distribution from −1 to 0.
mathematically, the pdfs are
fx(0)(x) =(
1,0≤x≤1,
0,otherwiseand fx(0.5)(x) =(
1,−1≤x≤0,
0,otherwise .
since x(0) and x(0.5) have their own pdfs, we can calculate their correlation. this will
give us e[x(0)x(0.5)] which after some calculations is e[x(0)x(0.5)] =−1
3.
-2 -1.5 -1 -0.5 0 0.5 1 1.5 2-1-0.500.51
figure 10.10: the autocorrelation between x(0)andx(0.5)should be regarded as the correlation
between two random variables. each random variable has its own pdf.
we can now consider the autocorrelation for any t1andt2. when you are evaluating
the autocorrelation function, you are not just evaluating at t= 0 and t= 0.5, you are
also evaluating the correlation for all pairs of t1andt2. now you want to know what the
correlation is between t= 0 and t= 0.5,t= 2 and t= 3.1, etc. of course, there are
infinitely many pairs of time instants. the point of the autocorrelation function is to tell
you the correlation of allthe pairs. in other words, if we tell you rx(t1, t2), you will be able
to plug in a value of t1and a value of t2and tell us the correlation at ( t1, t2). how is this
possible? to find out, let’s consider the following example.
example 10.11 . let a∼uniform[0 ,1],x(t) =acos(2 πt). find rx(0,0.5), and draw
rx(t1, t2).
62410.2. mean and correlation functions
solution . from the previous example, we know that
rx(t1, t2) =1
3cos(2 πt1) cos(2 πt2).
therefore, rx(0,0.5) =1
3cos(2 π0) cos(2 π0.5) =−1
3, which is the same as if we had
computed it from the first principle.
the autocorrelation function tells you how one point of a time series is correlated
with another point of the time series. if rx(t1, t2) gives a high value, then it means the
random variables at t1andt2have a strong correlation. to understand this, suppose
we let t1= 0, and let us vary t2. then
rx(0, t2) =1
3cos(2 π0) cos(2 πt2) =1
3cos(2 πt2).
this is a periodic function that cycles through itself whenever t2is an integer. as
we recall from figure 10.10 , ift2= 0.5, the random variable x(t2) will take only
the negative values, but otherwise it is correlated with x(0). on the other hand, if
t2= 0.25, then figure 10.10 says that the random variable x(t2) is a constant 0, and
so the correlation with x(0) is zero.
clearly, rx(t1, t2) is a 2-dimensional function of t1andt2. you need to tell rx
which of the two time instants you want to compare, and then rxwill tell you the
correlation. so no matter what happens, you must specify two time instants. because
rx(t1, t2) is a 2-dimensional function, we can visualize it by calculating all the possible
values it takes. for example, if rx(t1, t2) =1
3cos(2 πt1) cos(2 πt2), we can plot rxas
a function of t1andt2.figure 10.11 shows the plot.
-2 -1.5 -1 -0.5 0 0.5 1 1.5 2-1-0.500.51
-1 -0.75 -0.5 -0.25 0 0.25 0.5 0.75 1
t1-1
-0.75
-0.5
-0.25
0
0.25
0.5
0.75
1t2
figure 10.11: the autocorrelation function rx(t1, t2) =1
3cos(2 πt1) cos(2 πt2).
the matlab/python code for figure 10.11 is shown below.
% matlab code for example 10.11
t = linspace(-1,1,1000);
r = (1/3)*cos(2*pi*t(:)).*cos(2*pi*t);
imagesc(t,t,r);
# python code for example 10.11
import numpy as np
625chapter 10. random processes
import matplotlib.pyplot as plt
t = np.linspace(-1,1,1000)
r = (1/3)*np.outer(np.cos(2*np.pi*t), np.cos(2*np.pi*t))
plt.imshow(r, extent=[-1, 1, -1, 1])
plt.show()
to understand the 2d function shown on the right hand side of figure 10.11 , we can
take a closer look by drawing figure 10.12 . for any two time instants t1andt2, we have
two random variables x(t1) and x(t2). the joint expectation e[x(t1)x(t2)] will return us
some value, and this is a point in the 2d plot rx(t1, t2). the value tells us the correlation
between x(t1) and x(t2). in the example in which t1= 0 and t2= 0.5, the correlation is
−1
3. interestingly, if we pick another pair of time instants t1=−0.5 and t2= 0, the joint
expectation is e[x(−0.5)x(0)] = −1
3, which is the same value. however, this −1
3is located
at a different valley than e[x(0)x(0.5)] in the 2d plot.
figure 10.12: to understand the autocorrelation function, pick two time instants t1andt2, and then
evaluate the joint expectation e[x(t1)x(t2)].
the above example shows a periodic autocorrelation function. the fact that it is peri-
odic is coincidental because the random process x(t) is a periodic function. in general, an
arbitrary random process can have an arbitrary autocorrelation function that is not periodic.
there are, of course, various properties of the autocorrelation functions and special types
of autocorrelation functions. we will study one of them, called the wide-sense stationary
processes , later.
example 10.12 . let θ ∼uniform[ −π, π],x(t) = cos( ωt+ θ). draw the autocorrela-
tion function rx(t1, t2).
solution . from the previous example we know that
rx(t1, t2) =1
2cos
ω(t1−t2)
.
figure 10.13 shows the realizations, and the mean and autocorrelation functions.
62610.2. mean and correlation functions
note that the autocorrelation function has a structure: every row is a shifted
version of the previous row. we call this a toeplitz structure. an autocorrelation with
a toeplitz structure is specified once we know any of the rows. a toeplitz structure also
implies that the autocorrelation function does not depend on the pair ( t1, t2) but only
on the difference t1−t2. in other words, rx(0,1) is the same as rx(11.6,12.6), and so
knowing rx(0,1) is enough to know all rx(t0, t0+t). not all random processes have
a toeplitz autocorrelation function. random processes with a toeplitz autocorrelation
function are “nice” processes that we will study in detail later.
-2 -1.5 -1 -0.5 0 0.5 1 1.5 2-1-0.500.51
-1 -0.75 -0.5 -0.25 0 0.25 0.5 0.75 1
t1-1
-0.75
-0.5
-0.25
0
0.25
0.5
0.75
1t2
figure 10.13: the autocorrelation function rx(t1, t2) =1
2cos
ω(t1−t2)
.
the matlab code used to generate figure 10.13 is shown below.
% matlab code for example 10.12
t = linspace(-1,1,1000);
r = toeplitz(0.5*cos(2*pi*t(:)));
imagesc(t,t,r);
grid on;
xticks(-1:0.25:1);
yticks(-1:0.25:1);
practice exercise 10.1 . let θ ∼uniform[0 ,2π],x(t) = cos( ωt+ θ). find the pdf
ofx(0).
solution . let z=x(0) = cos θ. then the cdf of zis
fz(z) =p[z≤z]
=p[cos θ ≤z]
=p[cos−1z≤θ≤2π−cos−1z]
= 1−cos−1z
π.
627chapter 10. random processes
then by the fundamental theorem of calculus,
fz(z) =1
π√
1−z2.
a similar concept to the autocorrelation function is the autocovariance function. the
idea is to remove the mean before computing the correlation. this is analogous to the
covariance cov( x, y) =e[(x−µx)(y−µy)] as opposed to the correlation e[xy] in the
random variable case.
definition 10.3. theautocovariance function of a random process x(t)is
cx(t1, t2) =e[(x(t1)−µx(t1)) (x(t2)−µx(t2))]. (10.7)
as one might expect, the autocovariance function is closely related to the autocorrelation
function.
theorem 10.1.
cx(t1, t2) =rx(t1, t2)−µx(t1)µx(t2). (10.8)
proof . plugging in the definition, we have that
cx(t1, t2) =e[(x(t1)−µx(t1)) (x(t2)−µx(t2))]
=e[x(t1)x(t2)−x(t1)µx(t2)−x(t2)µx(t1) +µx(t1)µx(t2)]
=rx(t1, t2)−µx(t1)µx(t2)−µx(t1)µx(t2) +µx(t1)µx(t2)
=rx(t1, t2)−µx(t1)µx(t2).
□
practice exercise 10.2 . suppose x(t) =acos(2 πt) for a∼uniform[0 ,1]. find
cx(t1, t2).
solution .
cx(t1, t2) =rx(t1, t2)−µx(t1)µx(t2)
=1
3cos(2 πt1) cos(2 πt2)−1
2cos(2 πt1)·1
2cos(2 πt2)
=1
12cos(2 πt1) cos(2 πt2).
practice exercise 10.3 . suppose x(t) = cos( ωt+ θ) for θ ∼uniform[ −π, π]. find
cx(t1, t2).
62810.2. mean and correlation functions
solution .
cx(t1, t2) =rx(t1, t2)−µx(t1)µx(t2)
=1
2cos
ω(t1−t2)
−0·0
=1
2cos
ω(t1−t2)
.
in some problems we are interested in modeling the correlation between two random
processes x(t) and y(t). this gives us the cross-correlation and the cross-covariance func-
tions.
definition 10.4. thecross-correlation function ofx(t)andy(t)is
rx,y(t1, t2) =e[x(t1)y(t2)]. (10.9)
definition 10.5. thecross-covariance function ofx(t)andy(t)is
cx,y(t1, t2) =e[(x(t1)−µx(t1)) (y(t2)−µy(t2))]. (10.10)
remark . ifµx(t1) =µy(t2) = 0, then cx,y(t1, t2) =rx,y(t1, t2) =e[x(t1)y(t2)].
10.2.3 independent processes
how do we establish independence for two random processes? we know that for two random
variables to be independent, the joint pdf can be written as a product of two pdfs:
fx,y(x, y) =fx(x)fy(y). (10.11)
if we extrapolate this idea to random processes, a natural formulation would be
fx(t),y(t)(x, y) =fx(t)(x)fy(t)(y). (10.12)
but this definition has a problem because x(t) and y(t) are functions. it is not enough to
just look at one time index, say t=t0. the way to think about this situation is to consider
a pair of random vectors xandy. when you say xandyare independent, you require
fx,y(x,y) =fx(x)fy(y). the pdf fx(x) itself is a joint distribution, i.e., fx(x) =
fx1,...,x n(x1, . . . , x n). therefore, for random processes, we need something similar.
definition 10.6. two random processes x(t)andy(t)areindependent if for any
t1, . . . , t n,
fx(t1),...,x (tn),y(t1),...,y (tn)(x1, . . . , x n, y1, . . . , y n)
=fx(t1),...,x (tn)(x1, . . . , x n)×fy(t1),...,y (tn)(y1, . . . , y n).
629chapter 10. random processes
this definition is reminiscent of fx,y(x,y) =fx(x)fy(y). the requirement here is that
the factorization holds for anyn, including very small nand very large n, because x(t)
andy(t) are infinitely long.
independence means that the behavior of one process will not influence the behavior
of the other process. we define uncorrelated as follows.
definition 10.7. two random processes are x(t)andy(t)uncorrelated if
e[x(t1)y(t2)] =e[x(t1)]e[y(t2)], (10.13)
independence implies uncorrelation, as we can see from the following. if x(t) and y(t) are
independent, it follows that
e[x(t1)y(t2)] =z
x(t1, ξ)y(t2, ζ)fx,y(ξ, ζ)dξ dζ
=z
x(t1, ξ)y(t2, ζ)fx(ξ)fy(ζ)dξ dζ, independence
=z
x(t1, ξ)fx(ξ)dξz
y(t2, ζ)fy(ζ)dζ=e[x(t1)]e[y(t2)].
if two random processes are uncorrelated, they are not necessarily independent.
independent x and y⇒
⇍uncorrelated x and y
example 10.13 . let y(t) =x(t) +n(t), where x(t) and n(t) are independent.
then
rx,y(t1, t2) =e[x(t1)y(t2)] =e[x(t1) (x(t2) +n(t2))]
=rx(t1, t2) +µx(t1)µn(t2).
10.3 wide-sense stationary processes
as we have seen in the previous sections, some random processes have a “nice” autocor-
relation function, in the sense that the 2d function rx(t1, t2) has a toeplitz structure.
random processes with this property are known as wide-sense stationary (wss) processes.
wss processes belong to a very small subset in the entire universe of random processes,
but they are practically the most useful ones. before we discuss how to use them, we first
present a formal definition of a wss process.1
1many textbooks introduce strictly stationary processes before discussing a wide-sense stationary process.
we skip the former because, throughout our book, we only use wss processes. readers interested in strictly
stationary processes can consult the references listed at the end of this chapter.
63010.3. wide-sense stationary processes
10.3.1 definition of a wss process
definition 10.8. a random process x(t)iswide-sense stationary if:
1.µx(t) =constant ,for all t, and
2.rx(t1, t2) =rx(t1−t2)for all t1, t2.
there are two criteria that define a wss process. the first criterion is that the mean is a
constant. that is, the mean function does not change with time. the second criterion is that
the autocorrelation function only depends on the difference t1−t2and not on the absolute
starting point. for example, rx(0.1,1.1) needs to be the same as rx(6.3,7.3), because the
intervals are both 1.
how can these two criteria be mapped to the toeplitz structure we discussed in the
previous examples? figure 10.14 shows the autocorrelation function rx(t1, t2), which is a
2d function. we take three cross sections corresponding to t2=−0.13,t2= 0 and t2= 0.3.
as you can see from the figure, each rx(t1, t2) is a shifted version of another one. to obtain
any value rx(t1, t2) on the function, there is no need to probe to the 2d map; you only
need to probe to the red curve and locate the position marked as t1−t2, and you will be
able to obtain the value rx(t1, t2).
-1 -0.75 -0.5 -0.25 0 0.25 0.5 0.75 1
t1-1
-0.75
-0.5
-0.25
0
0.25
0.5
0.75
1t2
-1 -0.75 -0.5 -0.25 0 0.25 0.5 0.75 1
t1-1-0.500.51
t2 = -0.13
t2 = 0
t2 = 0.3
figure 10.14: cross sections of the autocorrelation function rx(t1, t2) =1
2cos
ω(t1−t2)
.
not all random processes have a toeplitz autocorrelation function. for example, the
random process x(t) =acos(2 πt) is not a wss process, because the autocorrelation func-
tion is
rx(t1, t2) =1
3cos(2 πt1) cos(2 πt2),
which cannot be written as the difference t1−t2.
remark 1 . wss processes can also be defined using the autocovariance function instead
of the autocorrelation function, because if a process is wss, then the mean function is a
constant. if the mean function is a constant, then cx(t1, t2) =rx(t1, t2)−µ2. so any
geometric structure that rxpossesses will be translated to cx, as the constant µ2will not
631chapter 10. random processes
influence the geometry. therefore, it is equally valid to say that a wss process has
cx(t1, t2) =cx(t1−t2).
remark 2 . because a wss is completely characterized by the difference t1−t2, there is
no need to keep track of the absolute indices t1andt2. we can rewrite the autocorrelation
function as
rx(τ) =e[x(t+τ)x(t)]. (10.14)
there is nothing new in this equation: it only says that instead of writing rx(t+τ, t), we
can write rx(τ) because the time index tplays no role in terms of rx. thus from now on,
for any wss processes we will write the autocorrelation function as rx(τ).
10.3.2 properties of rx(τ)
when x(t) is wss, rx(τ) has several important properties.
corollary 10.1. rx(0) = average power of x(t).
proof . since
rx(0) =e[x(t+ 0)x(t)] =e[x(t)2],
and since e[x(t)2] is the average power, rx(0) is the average power of x(t). □
corollary 10.2. rx(τ)is symmetric. that is, rx(τ) =rx(−τ).
proof . note that rx(τ) =e[x(t+τ)x(t)]. by switching the order of multiplication in the
expectation, we have
e[x(t+τ)x(t)] =e[x(t)x(t+τ)] =rx(−τ).
□
corollary 10.3.
p(|x(t+τ)−x(τ)|> ϵ)≤2(rx(0)−rx(τ))
ϵ2.
this result says that if rx(τ) is slowly decaying from rx(0), the probability of having a
large deviation |x(t+τ)−x(τ)|is small.
proof .
p(|x(t+τ)−x(τ)|> ϵ)≤e[(x(t+τ)−x(τ))2]/ϵ2
=
e[x(t+τ)2]−2e[x(t+τ)x(t)] +e[x(t)2]
/ϵ2
=
2e[x(t)2]−2e[x(t+τ)x(t)]
/ϵ2
= 2
rx(0)−rx(τ)
/ϵ2.
□
63210.3. wide-sense stationary processes
corollary 10.4. |rx(τ)| ≤rx(0), for all τ.
proof . by cauchy’s inequality e[xy]2≤e[x2]e[y2], we can show that
rx(τ)2=e[x(t)x(t+τ)]2
≤e[x(t)2]e[x(t+τ)2]
=e[x(t)2]2=rx(0)2.
□
10.3.3 physical interpretation of rx(τ)
how should we understand the autocorrelation function rx(τ) for wss processes? cer-
tainly, by definition, rx(τ) =e[x(t+τ)x(t)] means that we can analyze rx(τ) from the
statistical perspective. but in this section we want to take a slightly different approach by
answering the question from a computational perspective.
consider the following function:
brx(τ)def=1
2tzt
−tx(t+τ)x(t)dt. (10.15)
this function is the temporal average ofx(t+τ)x(t), as opposed to the statistical average.
why do we want to consider this temporal average? we first show the main result, that
e[brx(τ)] =rx(τ).
lemma 10.1. letbrx(τ)def=1
2trt
−tx(t+τ)x(t)dt. then
eh
brx(τ)i
=rx(τ). (10.16)
proof .
eh
brx(τ)i
=1
2tzt
−te[x(t+τ)x(t)]dt
=1
2tzt
−trx(τ)dt=rx(τ)1
2tzt
−tdt=rx(τ).
□
this lemma implies that if the signal x(t) is long enough, we can approximate rx(τ)
bybrx(τ). the approximation is asymptotically consistent, in the sense that e[brx(τ)] =
rx(τ). now, the more interesting question is the interpretation of brx(τ). what is it?
how should we understand brx(τ)?
brx(τ) is the “unflipped convolution”, or correlation , ofx(τ) and x(t+τ).
633chapter 10. random processes
correlation is analogous to convolution. for convolution , the definition is
y(τ) =zt
−tx(t−τ)x(t)dt, (10.17)
whereas for correlation , the definition is
y(τ) =zt
−tx(t+τ)x(t)dt. (10.18)
clearly, brx(τ) is the latter. a graphical illustration of the difference between convolution
and correlation is provided in figure 10.15 . the only difference between the two is that the
correlation does not flip the function, whereas the convolution does flip the function.
-0.100.10.20.30.40.50.6
-10 -5 0 5 10
-0.100.10.20.30.40.50.6
-10 -5 0 5 10
(a) convolution (b) correlation
figure 10.15: the difference between convolution and correlation. in convolution, the function x(t)is
flipped before we compute the result. for correlation, the function is not flipped.
the temporal correlation is easy to visualize. starting with the function x(t+τ), if you
make τlarger or smaller, then effectively you are shifting x(t) left or right. the integrationrt
−tx(t+τ)x(t)dtcalculates the energy accumulated. if the integral is large, there is a
strong correlation between x(t) and x(t+τ). otherwise the correlation is small. here is
an extreme example:
example 10.14 . consider a random process x(t) such that for every t,x(t) is an
i.i.d. gaussian random variable with zero mean and unit variance. then
rx(τ) =e[x(t+τ)x(t)] =(
e[x2(t)], τ = 0,
e[x(t+τ)]e[x(t)], τ ̸= 0.
using the fact that x(t) is i.i.d. gaussian for all t, we can show that e[x2(t)] = 1 for
anyt, ande[x(t+τ)]e[x(t)] = 0. therefore, we have
rx(τ) =(
1, τ = 0,
0. τ ̸= 0.
63410.3. wide-sense stationary processes
the equation says that since the random process is i.i.d. gaussian, shifting and in-
tegrating will give maximum correlation at the origin. as soon as the shift is not at
the origin, the correlation is zero. this makes sense because the samples are just i.i.d.
gaussian. one pixel offset is enough to destroy any correlation.
now let’s calculate the temporal correlation. we know that
brx(τ) =1
2tzt
−tx(t+τ)x(t)dτ.
this equation says that we shift x(t) to the left and right and then integrate. if τ
is not zero, the product x(t+τ)x(t) will sometimes be positive and sometimes be
negative. after integrating the entire period, we cancel out most of the terms. let’s
plot the functions and see if all these steps make sense. in figure 10.16 (a), we show
two random realizations of the random process x(t). they are just i.i.d. gaussian
samples.
infigure 10.16 (b) we plot the temporal autocorrelation function brx(τ). since
brx(τ) itself is a random process, it has different realizations. we plot two random
realizations, which are computed based on shifting and integrating x(t). in the same
plot, we also show the statistical expectation rx(τ). as we can see from the plot,
the temporal correlation and the statistical correlation match reasonably well except
for the fluctuation in brx(τ), which is expected because it is computed from a finite
number of samples.
0 200 400 600 800 1000-4-3-2-101234
0 500 1000 1500 2000-0.200.20.40.60.811.2
correlation of sample 1
correlation of sample 2
auto-correlation function
(a)x(t) (b) brx(τ)
figure 10.16: (a) a random process x(t)with two different realizations. (b) as we calculate the
temporal correlation of each of the two realizations, we obtain a noisy function that is nearly an
impulse. if we take the average of many of these realizations, we obtain a pure delta function.
on a computer, the commands to do the autocorrelation function are xcorr in mat-
lab and np.correlate in python. below are the codes used to generate figure 10.16 .
% matlab code to demonstrate autocorrelation
n = 1000; % number of sample paths
t = 1000; % number of time stamps
x = 1*randn(n,t);
xc = zeros(n,2*t-1);
for i=1:n
635chapter 10. random processes
xc(i,:) = xcorr(x(i,:))/t;
end
plot(xc(1,:),’b:’, ’linewidth’, 2); hold on;
plot(xc(2,:),’k:’, ’linewidth’, 2);
# python code to demonstrate autocorrelation
n = 1000
t = 1000
x = np.random.randn(n,t)
xc= np.zeros((n,2*t-1))
for i in range(n):
xc[i,:] = np.correlate(x[i,:],x[i,:],mode=’full’)/t
plt.plot(xc[0,:],’b:’)
plt.plot(xc[1,:],’k:’)
plt.show()
under what conditions will brx(τ)→rx(τ) ast→ ∞ ? the answer to this question
is provided by an important theorem called mean-square ergodic theorem , which can be
thought of as the random process version of the weak law of large numbers. we leave the
discussion of the mean ergodic theorem to the appendix.
everything you need to know about a wss process
the mean of a wss process is a constant (does not need to be zero)
the correlation function only depends on the difference, so rx(t1, t2) is toeplitz.
you can write rx(t1, t2) asrx(τ), where τ=t1−t2.
rx(τ) tells you how much correlation you have with someone located at a time
instant τfrom you.
10.4 power spectral density
beginning with this section we are going to focus on wss processes. by wss, we mean that
the autocorrelation function rx(t1, t2) has a toeplitz structure. putting it in other words,
we assume rx(t1, t2) can be simplified to rx(τ), where τ=t1−t2. we call this property
time invariance .
10.4.1 basic concepts
assuming that rx(τ) is square integrable, i.e.,r∞
−∞rx(τ)2dτ <∞, we can now define the
fourier transform of rx(τ) which is called the power spectral density .
63610.4. power spectral density
theorem 10.2 (einstein-wiener-khinchin theorem ).the power spectral density
sx(ω)of a wss process is
sx(ω) =z∞
−∞rx(τ)e−jωτdτ=f(rx(τ)),
assuming thatr∞
−∞rx(τ)2dτ <∞so that the fourier transform of rx(τ)exists.
practice exercise 10.4 . let rx(τ) =e−2α|τ|. find sx(ω).
solution . using the fourier transform table,
sx(ω) =f {rx(τ)}=4α
4α2+ω2.
figure 10.17 shows the autocorrelation function and the power spectral density.
-2 -1 0 1 200.20.40.60.81
rx()
-10 -5 0 5 1000.20.40.60.81
sx()
figure 10.17: example for rx(τ) =e−2α|τ|, with α= 1.
why is theorem 10.2 a theorem rather than a definition ? this is because power spectral
density has its definition. there is no way that you can get any “power” information merely
by looking at the fourier transform of rx(τ). we will discuss the origin of the power spectral
density later, but for now, we only need to know that sx(ω) is the fourier transform of
rx(τ).
remark . the power spectral density is defined for wss processes. if the process is not
wss, then rxwill be a 2d function instead of a 1d function of τ, so we cannot take the
fourier transform in τ. we will discuss this in detail shortly.
practice exercise 10.5 . let x(t) =acos(ω0t+θ),θ∼uniform[0 ,2π]. find sx(ω).
solution . we know that the autocorrelation function is
rx(τ) =a2
2cos(ω0τ)
=a2
2ejω0τ+e−jω0τ
2
.
637chapter 10. random processes
by taking the fourier transform of both sides, we have
sx(ω) =a2
22πδ(ω−ω0) + 2πδ(ω+ω0)
2
=πa2
2[δ(ω−ω0) +δ(ω+ω0)].
the result is shown in figure 10.18 .
-2 -1 0 1 2-0.500.5
rx()
00.511.52
-10 -5 0 5 10sx()
figure 10.18: example for rx(τ) =a2
2cos(ω0τ), with a= 1andω0= 2π.
practice exercise 10.6 . let sx(ω) =n0
2rect(ω
2w). find rx(τ).
solution . since sx(ω) =f(rx(τ)), the inverse holds:
rx(τ) =n0
2w
πsinc(wτ).
this example shows what we call the bandlimited white noise . the power spectral
density sx(ω) is uniform, meaning that it covers all frequencies (or wavelengths in
optics). it is called “white noise” because white light is essentially a mixture of all
wavelengths.
the bandwidth of the power spectral density wdefines the zero crossings of
rx(τ). it is easy to show that when w→ ∞ ,rx(τ) converges to a delta function.
this happens when x(t) is i.i.d. gaussian. therefore, the pure gaussian noise random
process is also known as the white noise process . reshaping the i.i.d. gaussian noise
to an arbitrary power spectral density can be done by passing it through a linear filter,
as we will explain later.
-2 -1 0 1 2-0.500.511.52
rx()
-10 -5 0 5 10-0.500.511.5
sx()
figure 10.19: example for sx(ω) =n0
2rect(ω
2w), with n0= 2andw= 5.
63810.4. power spectral density
finding sx(ω) from rx(τ) is straightforward, at least in principle. the more inter-
esting questions to ask are: (1) why do we need to learn about power spectral density? (2)
why do we need wss to define power spectral density?
how is power spectral density useful?
power spectral densities are useful when we pass a random process through some
linear operations, e.g., convolution, running average, or running difference.
power spectral densities are the fourier transforms of the autocorrelation func-
tions. fourier transforms are useful for speeding up computation and drawing
random samples from a given power spectral density.
a random process itself is not interesting until we process it; there are many ways to do
this. the most basic operation is to send the random process through a linear time-invariant
system, e.g., a convolution. convolution is equivalent to filtering the random process. for
example, if the input process contains noise, we can design a linear time-invariant filter to
denoise the random process. the power spectral density, which is the fourier transform
of the autocorrelation function, makes the filtering easier because everything can be done
in the spectral (fourier) domain. moreover, we can analyze the performance and quantify
the limit using standard results in fourier analysis. for some specialized problems such as
imaging through atmospheric turbulence, the distortions happen in the phase domain. this
can be simulated by drawing samples from the power spectral density, e.g., the kolmogorov
spectrum or the von k´ arm´ an spectrum. power spectral densities have many important
engineering applications.
why does the power spectral density require wide-sense stationarity?
if a process is wss, then rxwill have a toeplitz structure.
a toeplitz matrix is important. if you do eigendecomposition to a toeplitz ma-
trix, the eigenvectors are the fourier bases.
so if rxis toeplitz, then you can diagonalize it using the fourier transform.
therefore, the power spectral density can be defined.
why does power spectral density require wss? this has to do with the toeplitz
structure of the autocorrelation function. to make our discussion easier let us discretize
the autocorrelation function rx(t1, t2) by considering rx[m, n]. (you can do a mental
calculation by converting t1to integer indices m, and t2ton. see any textbook on signals
and systems if you need help. this is called the “discrete time signal”.) following the range
oft1andt2,rx[m, n] can be expressed as:
r=
rx[0] rx[1] ···rx[n−1]
rx[1] rx[0] ···rx[n−2]
............
rx[n−1]rx[n−1]··· rx[0]
,
where we used the fact that rx[m, n] =rx[m−n] for wss processes and rx[k] =rx[−k].
we call the resulting matrix rtheautocorrelation matrix , which is a discretized version
639chapter 10. random processes
of the autocorrelation function rx(t1, t2). looking at r, we again observe the toeplitz
structure. for example, figure 10.20 shows one toeplitz structure and one non-toeplitz
structure.
figure 10.20: we show two autocorrelation functions rx[m, n]on the left-hand side. the first autocor-
relation function comes from a wss process that has a toeplitz structure. the second autocorrelation
function does not have toeplitz structure. for the toeplitz matrix, we can diagonalize it using the
fourier transform. the eigenvalues are the power spectral density.
any toeplitz matrix rcan be diagonalized using the fourier transforms. that is, we
can write ras
r=fhλf,
where fis the (discrete) fourier transform matrix andλis a diagonal matrix. this can be
understood as the eigendecomposition of r. the important point here is that only toeplitz
matrices can be eigendecomposed using the fourier transforms; an arbitrary symmetric
matrix cannot. figure 10.20 illustrates this point. if your matrix is toeplitz, you can diago-
nalize it, and hence you can define the power spectral density, just as in the first example. if
your matrix is not toeplitz, then the power spectral density is undefined. to get the toeplitz
matrix, you must start with a wss process.
before moving on, we define cross power spectral densities , which will be useful in
some applications.
definition 10.9. thecross power spectral density between two random processes
x(t)andy(t)is
sx,y(ω) =f(rx,y(τ))where rx,y(τ) =e[x(t+τ)y(t)],
sy,x(ω) =f(ry,x(τ))where ry,x(τ) =e[y(t+τ)x(t)].(10.19)
remark . in general, sx,y(ω)̸=sy,x(ω). rather, since rx,y(τ) =ry,x(−τ), we have
sx,y(ω) =sy,x(ω).
10.4.2 origin of the power spectral density
to understand the power spectral density, it is crucial to understand where it comes from
and why it is the fourier transform of the autocorrelation function.
64010.4. power spectral density
we begin by assuming that x(t) is a wss random process with mean µxand auto-
correlation rx(τ). we now consider the notion of power . consider a random process x(t).
the power within a period [ −t, t] is
bpx=1
2tzt
−t|x(t)|2dt.
bpxdefines the power because the integration alone is the energy, and the normalization by
1/2tgives us the power. however, there are two problems. first, since x(t) is random, the
power bpxis also random. is there a way we can eliminate the randomness? second, tis
a finite period of time. it does not capture the entire process, and so we do not know the
power of the entire process.
a natural solution to these two problems is to consider
pxdef=e"
lim
t→∞1
2tzt
−t|x(t)|2dt#
. (10.20)
here, we take the limit of tto infinity so that we can compute the power of the entire
process. we also take the expectation to eliminate the randomness. therefore, pxcan be
regarded as the average power of the complete random process x(t).
next, we need one definition and one lemma. the definition defines sx(ω), and the
lemma will link sx(ω) with the power px.
definition 10.10. thepower spectral density (psd) of a wss process is defined as
sx(ω) = lim
t→∞eh
|ext(ω)|2i
2t, (10.21)
where
ext(ω) =zt
−tx(t)e−jωtdt (10.22)
is the fourier transform of x(t)limited to [−t, t].
this definition is abstract, but in a nutshell, it simply considers everything in the fourier
domain. the ratio |ext(ω)|2/2tis the power, but in the frequency domain. the reason is
that if x(t) is fourier transformable, then parseval’s theorem will hold. parseval’s theorem
states that energy in the original space is conserved in the fourier space. since the ratio
|ext(ω)|2/2tis the energy divided by time, it is the power. however, this is still not enough
to help us understand power spectral density: we need a lemma.
lemma 10.2. define
pxdef=e"
lim
t→∞1
2tzt
−t|x(t)|2dt#
.
641chapter 10. random processes
then
px=1
2πz∞
−∞sx(ω)dω. (10.23)
the lemma has to be read together with the previous definition. if we can prove the lemma,
we know that by integrating sx(ω) we will obtain the power. therefore, sx(ω) can be
viewed as a density function , specifically the density function of the power. sx(ω) is called
the power spectral density because everything is defined in the fourier domain. putting this
all together gives us “power spectral density”.
proof . first, we recall that pxis the expectation of the average power of x(t). let
xt(t) =x(t)−t≤t≤t,
0 otherwise .
it follows that integrating over −∞to∞is equivalent to
z∞
−∞|xt(t)|2dt=zt
−t|x(t)|2dt.
by parseval’s theorem, energy is conserved in both the time and the frequency domain:
z∞
−∞|xt(t)|2dt=1
2πz∞
−∞|ext(ω)|2dω.
therefore, pxsatisfies
px=e"
lim
t→∞1
2tzt
−t|x(t)|2dt#
=e
lim
t→∞1
2π1
2tz∞
−∞|ext(ω)|2dω
=1
2πz∞
−∞lim
t→∞1
2teh
|ext(ω)|2i
| {z }
def=sx(ω)dω.
□
the power spectral densities are functions whose integrations give us the power. if we
want to determine the power of a random process, the einstein-wiener-khinchin theorem
(theorem 10.2) says that sx(ω) is just the fourier transform of rx(τ):
sx(ω) =z∞
−∞rx(τ)e−jωτdτ=f(rx(τ)).
the proof of the einstein-wiener-khinchin theorem is quite intricate, so we defer
the proof to the appendix. the significance of the theorem is that it turns an abstract
quantity, the power spectral density, into a very easily computable quantity, namely the
fourier transform of the autocorrelation function. for now, we will happily use this theorem
because it saves us a great deal of trouble when we want to determine the power spectral
density from the first principles.
64210.5. wss process through lti systems
10.5 wss process through lti systems
random processes have limited usefulness until we can apply operations to them. in this
section we discuss how wss processes respond to a linear time-invariant (lti) system. this
technique is most useful in signal processing, communication, speech analysis, and imaging.
we will be brief here since you can find most of this information in any standard textbook
on signals and systems.
10.5.1 review of linear time-invariant systems
when we say a “system”, we mean that there exists an input-output relationship as shown
infigure 10.21 .
figure 10.21: a system can be viewed as a black box that takes an input x(t)and turns it into an
output y(t).
linear time-invariant (lti) systems are the simplest systems we use in engineering
problems. an lti system has two properties.
linearity . linearity means that when two input random processes are added and
scaled , the output random processes will also be added and scaled in exactly the
same way. mathematically, linearity says that if x1(t)→y1(t) and x2(t)→
y2(t), then
ax1(t) +bx2(t)→ay1(t) +by2(t).
time-invariant : time invariance means that if we shift the input random process
by a certain time period, the output will be shifted in the same way. mathemat-
ically, time invariance means that if x(t)→y(t), then
x(t+τ)→y(t+τ).
if a system is linear time-invariant, the input-to-output relation is given by convolution :
theconvolution between two functions x(t) and h(t) is defined as
y(t) =h(t)∗x(t) =z∞
−∞h(τ)x(t−τ)dτ,
643chapter 10. random processes
in which we call h(t) the system response or impulse response .
the function h(t) is called the impulse response because if x(t) =δ(t), then according to
the convolution equation we have
y(t) =z∞
−∞h(τ)δ(t−τ)dτ=h(t).
therefore, if we send an impulse to the system, the output will be h(t).
convolution is commutative, meaning that h(t)∗x(t) =x(t)∗h(t). written as inte-
grations, we have
z∞
−∞h(τ)x(t−τ)dτ=z∞
−∞h(t−τ)x(τ)dτ. (10.24)
for lti systems, y(t) can be determined through the fourier transforms.
thefourier transform of a (squared-integrable) function x(t) is
x(ω) =f{x(t)}=z∞
−∞x(τ)e−jωτdτ. (10.25)
a basic property of convolution is that convolution in the time domain is equivalent to
multiplication in the fourier domain . therefore
y(ω) =h(ω)x(ω), (10.26)
where h(ω) =f{h(t)}is the fourier transform of h(t), and y(ω) =f(y(t)) is the fourier
transform of y(t).
in the rest of this section we study the pair of input and output random processes that
are defined as follows
x(t) = input. it is a wss random process.
y(t) = output. it is constructed by sending x(t) through an lti system with
impulse response h(t). therefore, y(t) =h(t)∗x(t).
10.5.2 mean and autocorrelation through lti systems
since x(t) is wss, the mean function of x(t) stays constant, i.e., µx(t) =µx. the following
theorem gives the mean function of the output.
theorem 10.3. ifx(t)passes through an lti system to yield y(t), the mean function
ofy(t)is
e[y(t)] =µxz∞
−∞h(τ)dτ. (10.27)
64410.5. wss process through lti systems
proof . suppose that y(t) =h(t)∗x(t). then,
µy(t) =e[y(t)] =ez∞
−∞h(τ)x(t−τ)dτ
=z∞
−∞h(τ)e[x(t−τ)]dτ
=z∞
−∞h(τ)µxdτ=µxz∞
−∞h(τ)dτ,
where the second to last equality is valid because x(t) is wss, so that e[x(t−τ)] =µx.
□
the theorem suggests that if the input x(t) has a constant mean, the output y(t)
should also have a constant mean. this should not be a surprise because if the system is
linear, a constant input will give a constant output.
example 10.15 . consider a wss random process x(t) such that each sample is an
i.i.d. gaussian random variable with zero mean and unit variance. we send this process
through an lti system with impulse response h(t), where
h(t) =(
10(1− |t|),−1≤t≤1,
0, otherwise .
the mean function of x(t) isµx(t) = 0, and that of y(t) isµy(t) = 0. figure 10.22
illustrates a numerical example, in which we see that the random processes x(t) and
y(t) have different shapes but the mean functions remain constant.
-10 -5 0 5 10-4-2024
x(t)
x(t)
y(t)
y(t)
-2 -1 0 1 2-0.0500.050.10.150.2
rx(t)
ry(t)
(a)µx(t) and µy(t) (b) rx(t) and ry(t)
figure 10.22: when sending a wss random process through an lti system, the mean and the
autocorrelation functions are changed.
next, we derive the autocorrelation function of a random process when sent through
an lti system.
theorem 10.4. ifx(t)passes through an lti system to yield y(t), the autocorre-
645chapter 10. random processes
lation function ofy(t)is
ry(τ) =z∞
−∞z∞
−∞h(s)h(r)rx(τ+s−r)ds dr. (10.28)
proof . we start with the definition of y(t):
ry(τ) =e[y(t)y(t+τ)]
=ez∞
−∞h(s)x(t−s)dsz∞
−∞h(r)x(t+τ−r)dr
(a)=z∞
−∞z∞
−∞h(s)h(r)e[x(t−s)x(t+τ−r)ds dr ]
=z∞
−∞z∞
−∞h(s)h(r)rx(τ+s−r)ds dr,
where in (a) we assume that integration and expectation are interchangeable.
□
a shorthand notation of the above formula is ry(t) = [h⊛(h∗rx)](t), where ∗denotes
the convolution and ⊛denotes the correlation. figure 10.22 (b) shows the autocorrelation
functions rxandry. in this example rxis a delta function because for i.i.d. gaussian
noise the power spectral density is a constant. after convolving with the system response,
the autocorrelation ryhas a different shape.
10.5.3 power spectral density through lti systems
denoting the fourier transform of the impulse response by h(ω) =f(h(t)), we derive the
power spectral density of the output.
theorem 10.5. ifx(t)passes through an lti system to yield y(t), the power spec-
tral density ofy(t)is
sy(ω) =|h(ω)|2sx(ω). (10.29)
proof . by definition, the power spectral density sy(ω) is the fourier transform of the
autocorrelation function ry(ω). therefore,
sy(ω) =z∞
−∞ry(τ)e−jωτdτ
=z∞
−∞z∞
−∞z∞
−∞h(s)h(r)rx(τ+s−r)ds dre−jωτdτ.
letting u=τ+s−r, we have
sy(ω) =z∞
−∞z∞
−∞z∞
−∞h(s)h(r)rx(u)e−jω(u−s+r)ds dr du
=z∞
−∞h(s)ejωsdsz∞
−∞h(r)e−jωrdrz∞
−∞rx(u)e−jωudu
=h(ω)h(ω)sx(ω),
64610.5. wss process through lti systems
where h(ω) is the complex conjugate of h(ω).
□
it is tempting to think that since y(t) =h(t)∗x(t), the power spectral density should
also be sy(ω) =h(ω)x(ω), but this is not true. the above result shows that we need an
additional complex conjugate h(ω) because sy(ω) is the power , which means the square
of the signal. note that rxis “squared” because we have convolved it with itself, and ry
is also squared. therefore, to match rxandry, the impulse response halso needs to be
squared in the fourier domain.
example 10.16 . a wss process x(t) has a correlation function
rx(τ) = sinc( πτ).
suppose that x(t) passes through an lti system with input/output relationship
2d2
dt2y(t) + 2d
dty(t) + 4y(t) = 3d2
dt2x(t)−3d
dtx(t) + 6x(t).
find ry(τ).
solution : the sinc function has a fourier transform given by
sinc(wt)←→
fπ
wrectω
2w
.
therefore, the autocorrelation function is
rx(τ) = sinc( πτ)←→
fπ
πrectω
2π
.
by taking the fourier transform on both sides, we have
sx(ω) =(
1,−π≤ω≤π,
0, elsewhere .
the system response is found from the differential equation:
h(ω) =3(jω)2−3(jω) + 6
2(jω)2+ 2(jω) + 4
=3
(2−ω2)−jω
2 [(2−ω2) +jω].
taking the magnitude square yields
|h(ω)|2=3
(2−ω2)−jω
2 [(2−ω2) +jω]3
(2−ω2) +jω
2 [(2−ω2)−jω]
=9
4(2−ω2)2+ω2
(2−ω2)2+ω2=9
4.
647chapter 10. random processes
therefore, the output power spectral density is
sy(ω) =|h(ω)|2sx(ω) =9
4sx(ω).
taking the inverse fourier transform, we have
ry(τ) =9
4sinc(πτ).
example 10.17 . a random process x(t) has zero mean and rx(t, s) = min( t, s).
consider a new process y(t) =etx(e−2t).
1. is y(t) wss?
2. suppose y(t) passes through a lti system to yield an output z(t) according to
d
dtz(t) + 2z(t) =d
dty(t) +y(t).
find rz(τ).
solution :
1. in order to verify whether y(t) is wss, we need to check the mean function and
the autocorrelation function. the mean function is
e[y(t)] =e
etx(e−2t)
=ete
x(e−2t)
.
since x(t) has zero mean, e[x(t)] = 0 for all t. this implies that if u=e−2t,
thene[x(u)] = 0 because uis just another time instant. thus e[x(e−2t)] = 0,
and hence e[y(t)] = 0.
the autocorrelation is
e[y(t+τ)y(t)] =eh
et+τx(e−2(t+τ))etx(e−2t)i
=e2t+τeh
x(e−2(t+τ))x(e−2t)i
=e2t+τrx(e−2(t+τ), e−2t).
substituting rx(t, s) = min( t, s), we have that
e2t+τrx(e−2(t+τ), e−2t) =e2t+τmin(e−2(t+τ), e−2t)
=e2t+τ
e−2(t+τ), τ≥0
e−2t, τ < 0
=e−τ, τ≥0
eτ, τ < 0
=e−|τ|.
64810.5. wss process through lti systems
sory(τ) =e−|τ|. since ry(τ) is a function of τ,y(t) is wss.
2. the system response is given by
h(ω) =1 +jω
2 +jω.
the magnitude is therefore
|h(ω)|2=1 +ω2
4 +ω2.
hence, the output autocorrelation function is
ry(τ) =e−|τ|←→sy(ω) =2
1 +ω2,
and
sz(ω) =|h(ω)|2sy(ω)
=1 +ω2
4 +ω22
1 +ω2=2
4 +ω2.
therefore
rz(τ) =1
2e−2|τ|.
10.5.4 cross-correlation through lti systems
the above analyses are developed for the autocorrelation function. if we consider the cross-
correlation between two random processes, say x(t) and y(t), then the above results do not
hold. in this section, we discuss the cross-correlation through lti systems.
to begin with, we need to define wss for a pair of random processes.
definition 10.11. two random processes x(t)andy(t)arejointly wss if
1.x(t)is wss and y(t)is wss, and
2.rx,y(t1, t2) =e[x(t1)y(t2)]is a function of t1−t2.
ifx(t) and y(t) are jointly wss, we write
rx,y(t1, t2) =rx,y(τ)def=e[x(t+τ)y(τ)].
the definition of “jointly wss” is necessary here because rx,yis defined by xandy. just
knowing that x(t) and y(t) are wss does not allow one to say that rx,y(t1, t2) can be
written as the time difference.
if we flip the order of xandyto consider ry,x(τ) and not rx,y(τ), then we need
to flip the argument. the following lemma explains why.
649chapter 10. random processes
lemma 10.3. for any random processes x(t)andy(t), thecross-correlation rx,y(τ)
is related to ry,x(τ)as
rx,y(τ) =ry,x(−τ). (10.30)
proof . recall the definition of ry,x(−τ) =e[y(t−τ)x(t)]. this can be simplified as
follows:
ry,x(−τ) =e[y(t−τ)x(t)]
=e[x(t)y(t−τ)]
=e[x(t′+τ)y(t′)]
=rx,y(τ),
where we substituted t′=t−τ.
□
example 10.18 . let x(t) and n(t) be two independent wss random processes with
expectations e[x(t)] =µxande[n(t)] = 0, respectively. let y(t) =x(t) +n(t). we
want to show that x(t) and y(t) are jointly wss, and we want to find rx,y(τ).
solution . before we show the joint wss property of x(t) and y(t), we first show
thaty(t) is wss:
e[y(t)] =e[x(t) +n(t)] =µx.
ry(t1, t2) =e[(x(t1) +n(t1))(x(t2) +n(t2))]
=e[(x(t1)x(t2)] +e[(n(t1)n(t2)]
=rx(t1−t2) +rn(t1−t2).
thus, y(t) is wss.
to show that x(t) and y(t) are jointly wss, we need to check the cross-
correlation function:
rx,y(t1, t2) =e[x(t1)y(t2)]
=e[x(t1)(x(t2) +n(t2))]
=e[x(t1)(x(t2)] +e[x(t1)n(t2)]
=rx(t1, t2) +e[x(t1)]e[n(t2)]
=rx(t1, t2).
since rx,y(t1, t2) is a function of t1−t2, and since x(t) and y(t) are wss, x(t) and
y(t) must be jointly wss.
finally, to find rx,y(τ), we substitute τ=t1−t2and obtain rx,y(τ) =rx(τ).
knowing the definition of jointly wss, we consider the cross-correlation between x(t)
andy(t). note that here we are asking about the cross-correlation between the input and
the output of the same lti system, as illustrated in figure 10.23 . the pair x(t) and
y(t) =h(t)∗x(t) are special because y(t) is the convolved version of x(t).
65010.5. wss process through lti systems
figure 10.23: the source of the signals when defining rx(τ),rx,y(τ),ry,x(τ)andry(τ).
theorem 10.6. letx(t)andy(t)be jointly wss processes, and let y(t) =h(t)∗
x(t). then the cross-correlation ry,x(τ)is
ry,x(τ) =h(τ)∗rx(τ). (10.31)
proof . recalling the definition of cross-correlation, we have
ry,x(τ) =e[y(t+τ)x(t)]
=e
x(t)z∞
−∞x(t+τ−r)h(r)dr
=z∞
−∞e[x(t)x(t+τ−r)]h(r)dr=z∞
−∞rx(τ−r)h(r)dr,
which is the convolution ry,x(τ) =h(τ)∗rx(τ).
□
we next define the cross power spectral density of two jointly wss processes as the
fourier transform of the cross-correlation function.
definition 10.12. thecross power spectral density of two jointly wss processes
x(t)andy(t)is defined as
sx,y(ω) =f[rx,y(τ)],
sy,x(ω) =f[ry,x(τ)].
the relationship between sx,yandsy,xcan be seen from the following theorem.
theorem 10.7. for two jointly wss random processes x(t)andy(t), the cross
power spectral density satisfies the property that
sx,y(ω) =sy,x(ω), (10.32)
where (·)denotes the complex conjugate.
651chapter 10. random processes
proof . since sx,y(ω) =f[rx,y(τ)] by definition, it follows that
f[rx,y(τ)] =z∞
−∞rx,y(τ)e−jωτdτ
=z∞
−∞ry,x(−τ)e−jωτdτ=z∞
−∞rx,y(τ′)ejωτ′dτ′,
which is exactly the conjugate sy,x(ω).
□
when sending the random process through an lti system, the cross-correlation power
spectral density is given by the theorem below.
theorem 10.8. ifx(t)passes through an lti system to yield y(t), then the cross
power spectral density is
sy,x(ω) =h(ω)sx(ω),
sx,y(ω) =h(ω)sx(ω).
proof . by taking the fourier transform on ry,x(τ) we have that sy,x(ω) =h(ω)sx(ω).
since rx,y(τ) =ry,x(−τ), it holds that sx,y(ω) =h(ω)sx(ω).
□
example 10.19 . let x(t) be a wss random process with
rx(τ) =e−τ2/2, h (ω) =e−ω2/2.
find sx,y(ω),rx,y(τ),sy(ω) and ry(τ).
solution . first, by the fourier transform table we know that
sx(ω) =√
2πe−ω2/2.
since h(ω) =e−ω2/2, we have
sx,y(ω) =h(ω)sx(ω)
=√
2πe−ω2.
the cross-correlation function is
rx,y(ω) =f−1h√
2πe−ω2i
=1√
2e−τ2
4.
65210.6. optimal linear filter
the power spectral density of y(t) is
sy(ω) =|h(ω)|2sx(ω)
=√
2πe−3ω2
2.
therefore, the autocorrelation function of y(t) is
ry(τ) =f−1h√
2πe−3ω2
2i
=1√
3e−τ2/6.
10.6 optimal linear filter
in the previous sections, we have built many tools to analyze random processes. our next
goal is to apply these techniques. to that end, we will discuss optimal linear filter design ,
which is a set of estimation techniques for predicting and recovering information from a time
series.
10.6.1 discrete-time random processes
we begin by introducing some notations. in the previous sections, we have been using
continuous-time random processes to study statistics. in this section, we mainly focus on
discrete-time random processes. the shift from continuous-time to discrete-time is straight-
forward as far as the theories are concerned — we switch the continuous-time index tto
a discrete-time index n. however, shifting to discrete-time random processes can simplify
many difficult problems because many discrete-time problems can be solved by matrices and
vectors. this will make the computations and implementations much easier. to make this
transition easier, we provide a few definitions and results without proof.
notations for discrete-time random processes
we denote the discrete-time indices by mandn, corresponding to the continuous-
time indices t1andt2, respectively.
a discrete-time random process is denoted by x[n].
its mean function and the autocorrelation function are
µx[n] =e[x[n]],
rx[m, n] =e[x[m]x[n]].
we say that x[n] is wss if µx[n] = constant, and rx[m, n] is a function of
m−n.
653chapter 10. random processes
ifx[n] is wss, we write rx[m, n] as
rx[m, n] =rx[m−n] =rx[k],
where k=m−nis the interval.
ifx[n] is wss, we define the power spectral density as
sx(ejω) =f{rx[k]},
where sx(ejω) denotes the discrete-time fourier transform.
when a random process x[n] is sent through an lti system with an impulse response
h[n], the output is
y[n] =h[n]∗x[n] =∞x
k=−∞h[k]x[n−k]. (10.33)
when a wss process x[n] passes through an lti system h[n] to yield an output y[n],
the auto- and cross-correlation function and power spectral densities are
ry[k] =e[y[n+k]y[n]],sy(ejω) =f{ry[k]}=|h(ejω)|2sx(ejω).
rxy[k] =e[x[n+k]y[n]],sxy(ejω) =f{rxy[k]}=h(ejω)sx(ejω).
ry x[k] =e[y[n+k]x[n]],sy x(ejω) =f{ry x[k]}=h(ejω)sx(ejω).
10.6.2 problem formulation
the problem we study here is known as the optimal linear filter design . suppose that there
is a wss process x[n] that we want to process. for example, if x[n] is a corrupted version
of some clean time-series, we may want to remove the noise by filtering (also known as
averaging) x[n]. conceptualizing the denoising process as a linear time-invariant system
with an impulse response h[n], our goal is to determine the optimal h[n] such that the
estimated time series by[n] is as close to the true time series y[n] as possible.
referring to figure 10.24 , we refer to x[n] as the input function and to y[n] as the
target function .x[n] and y[n] are related according to the equation
y[n] =k−1x
k=0h[k]x[n−k]
| {z }
by[n]+e[n], (10.34)
where e[n] is a noise random process to model the error. the linear part of the equation
is known as the prediction and is constructed by sending x[n] through the system. for
simplicity we assume that x[n] is wss. thus, it follows that y[n] is also wss. we may
also assume that we can estimate rx[k],ry x[k],rxy[k] and ry[k].
65410.6. optimal linear filter
figure 10.24: a schematic diagram illustrating the optimal linear filter problem: given an input function
x[n], we want to design a filter h[n]such that the prediction by[n]is close to the target function y[n].
example 10.20 . if we let k= 3, equation (10.34) gives us
y[n] =h[0]x[n] +h[1]x[n−1] +h[2]x[n−2] +e[n].
that is, the current sample y[n] is a linear combination of the previous samples x[n],
x[n−1] and x[n−2].
given x[n] and y[n], what would be the best guess of the impulse response h[n] so
that the prediction is as close to the true values as possible? from our discussions of linear
regression, we know that this is equivalent to solving the optimization problem
minimize
{h[k]}k−1
k=0 
y[n]−k−1x
k=0h[k]x[n−k]!2
. (10.35)
the choice of the squared error is more or less arbitrary, depending on how we want to
model e[n]. by using the square norm, we implicitly assume that the error is gaussian.
this may not be true, but it is commonly used because the squared norm is differentiable .
we will follow this tradition.
the challenge associated with the minimization is that in most of the practical set-
tings the random processes x[n] and y[n] are changing rapidly because they are random
processes. therefore, even if we solve the optimization problem, the estimates h[k] will be
random variables since we are solving a random equation. to eliminate this randomness, we
take the expectation over all the possible choices of x[n] and y[n], yielding
minimize
{h[k]}k−1
k=0 
y[n]−k−1x
k=0h[k]x[n−k]!2
,
⇓
minimize
{h[k]}k−1
k=0ex,y
 
y[n]−k−1x
k=0h[k]x[n−k]!2
.
the resulting impulse responses h[k], derived by solving the above minimization, is
known as the optimal linear filter . it is the best linear model for describing the input-
output relationships between x[n] and y[n].
655chapter 10. random processes
what is the optimal linear filter?
the optimal linear filter is the solution to the optimization problem
minimize
{h[k]}k−1
k=0ex,y
 
y[n]−k−1x
k=0h[k]x[n−k]!2
. (10.36)
10.6.3 yule-walker equation
to solve the optimal linear filter problem, we first perform some (slightly tedious) algebra
to obtain the following results:
lemma 10.4. letby[n] =pk−1
k=0h[k]x[n−k]be the prediction of y[n]. the squared-
norm error can be written as
ex,y
y[n]−by[n]2
=ry[0]−2k−1x
k=0h[k]ry x[k] +k−1x
k=0k−1x
j=0h[k]h[j]rx[j−k]. (10.37)
thus we can express the error in terms of ry x[k],rx[k]andry[k].
proof . we expand the error as follows:
ex,y
y[n]−by[n]2
=ey
(y[n])2
−2ex,yh
y[n]by[n]i
+exh
(by[n])2i
.
the first term is the autocorrelation of y[n]:
ey
(y[n])2
=e[y[n+ 0]y[n]] =ry[0]. (10.38)
the second term is
ex,yh
y[n]by[n]i
=ex,y"
y[n]k−1x
k=0h[k]x[n−k]#
=k−1x
k=0h[k]ex,y[y[n]x[n−k]]
=k−1x
k=0h[k]ry x[k]. (10.39)
65610.6. optimal linear filter
the third term is
exh
(by[n])2i
=ex
 k−1x
k=0h[k]x[n−k]!
k−1x
j=0h[j]x[n−j]


=ex
k−1x
k=0k−1x
j=0h[k]h[j]x[n−k]x[n−j]

=k−1x
k=0k−1x
j=0h[k]h[j]ex[x[n−k]x[n−j]]
=k−1x
k=0k−1x
j=0h[k]h[j]rx[j−k]. (10.40)
this completes the proof.
□
the significance of this theorem is that it allows us to write the error in terms of ry x[k],
rx[k] and ry[k]. as we have mentioned, while we can solve the randomized optimization
equation (10.35), the resulting solution will be a random vector depending on the particular
realizations x[n] and y[n]. switching from equation (10.35) to equation (10.36) eliminates
the randomness because we have taken the expectation. the resulting optimization according
to the theorem is also convenient. instead of seeking individual realizations, we only need
to know the overall statistical description of the data through ry x[k],rx[k] and ry[k].
these can be estimated through modeling or pseudorandom signals.
the solution to the optimal linear filter problem is summarized by the yule-walker
equation :
theorem 10.9. the solution {h[0], . . . , h [k−1]}to the optimal linear filter problem
minimize
{h[k]}k−1
k=0ex,y
 
y[n]−k−1x
k=0h[k]x[n−k]!2
 (10.41)
is given by the following matrix equation:

ry x[0]
ry x[1]
...
ry x[k−1]
=
rx[0] rx[1] ··· rx[k−1]
rx[1] rx[0] ···...
............
rx[k−1]rx[k−2]··· rx[0]

h[0]
h[1]
...
h[k−1]
,(10.42)
which is known as the yule-walker equation.
therefore, by solving the simple linear problem given by the yule-walker equation, we will
find the optimal linear filter solution.
proof . since the error is a squared norm, the optimal solution is obtained by taking the
657chapter 10. random processes
derivative:
d
dh[i]ex,y
y[n]−by[n]2
=d
dh[i]

ry[0]−2k−1x
k=0h[k]ry x[k] +k−1x
k=0k−1x
j=0h[k]h[j]rx[j−k]


= 0−2ry x[i] + 2k−1x
k=0h[k]rx[i−k],
in which the derivative of the last term is computed by noting that
d
dh[i]k−1x
k=0k−1x
j=0h[k]h[j]rx[j−k]
=d
dh[i]k−1x
j=0h[j]2rx[0] +d
dh[i]k−1x
k=0x
j̸=kh[k]h[j]rx[j−k]
= 2k−1x
k=0h[k]rx[i−k].
equating the derivative to zero yields
ry x[i] =k−1x
k=0h[k]rx[i−k], i = 0, . . . , k −1,
and putting the above equations into the matrix-vector form we complete the proof.
□
the matrix in the yule-walker equation is a toeplitz matrix, in which each row is
a shifted version of the preceding row. this matrix structure is a consequence of a wss
process so that the autocorrelation function is determined by the time difference kand not
by the starting and end times.
remark . if we take the derivative of the loss w.r.t. h[i], we have that
0 =d
dh[i]ex,y
y[n]−by[n]2
=−2eh
y[n]−by[n]
x[n−i]i
.
this condition is known as the orthogonality condition , as it says that the error y[n]−by[n]
is orthogonal to the signal x[n−i].
10.6.4 linear prediction
we now demonstrate how to use the yule-walker equation in modeling an autoregressive
process . the procedure in this simple example can be used in speech processing and time-
series forecasting.
suppose that we have a wss random process y[n]. we would like to predict the future
samples by using the most recent ksamples through an autoregressive model. since the
65810.6. optimal linear filter
model is linear, we can write
by[n] =kx
k=1h[k]y[n−k] +e[n]. (10.43)
in this model, we say that the predicted value by[n] is a linear combination of the past k
samples, albeit to approximation error e[n].
the problem we need to solve is
minimize
h[k]e
y[n]−by[n]2
.
sinceby[n] is written in terms of the past samples of y[n] in this problem, in the yule-walker
equation we can replace xwith y. consequently, we can write the matrix equation from

ry x[0]
ry x[1]
...
ry x[k−1]
=
rx[0] rx[1] ··· rx[k−1]
rx[1] rx[0] ··· rx[k−2]
............
rx[k−1]rx[k−2]··· rx[0]

h[0]
h[1]
...
h[k−1]
,
to
ry[1]
ry[2]
...
ry[k]

|{z}
r=
ry[0] ry[1] ··· ry[k−1]
ry[1] ry[0] ··· ry[k−2]
............
ry[k−1]ry[k−2]··· ry[0]

| {z }
r
h[0]
h[1]
...
h[k−1]
. (10.44)
on a computer, solving the yule-walker equation requires a few steps. first, we need
to estimate the correlation
ry[k] =e[y[n+k]y[n]]≈1
nnx
n=1y[n+k]y[n].
the averaging on the right-hand side is often done using xcorr in matlab or np.correlate
in python. a graphical illustration of the input and the autocorrelation function is shown
infigure 10.25 .
after we have found ry[n], we need to construct the yule-walker equation. for this
linear prediction problem, the left-hand side of the yule-walker equation is the vector r,
defined according to equation (10.44). the yule-walker equation also requires the matrix r.
thisrcan be constructed via the toeplitz matrix as
r= toeplitz
ry[0], ry[1], . . . , r y[k−1]
.
in matlab, we can call toeplitz to construct the matrix. in python, the command is
lin.toeplitz .
to solve the yule-walker equation, we need to invert the matrix r. there are built-in
commands for such an operation. in matlab, the command is \(the backslash), whereas
in python the command is np.linalg.lstsq .
659chapter 10. random processes
0 50 100 150 200 250 300-0.2-0.100.10.2
y[n]
-300 -200 -100 0 100 200 300-0.2-0.100.10.20.30.4
ry[k]
(a)y[n] (b) ry[k]
figure 10.25: an example time-series and its autocorrelation function.
% matlab code to solve the yule walker equation
y = load(’data_ch10.txt’);
k = 10;
n = 320;
y_corr = xcorr(y);
r = toeplitz(y_corr(n+[0:k-1]));
lhs = y_corr(n+[1:k]);
h = r\lhs;
# python code to solve the yule walker equation
y = np.loadtxt(’./data_ch10.txt’)
k = 10
n = 320
y_corr = np.correlate(y,y,mode=’full’)
r = lin.toeplitz(y_corr[n-1:n+k-1]) #call scipy.linalg
lhs = y_corr[n:n+k]
h = np.linalg.lstsq(r,lhs,rcond = none)[0]
note that in both the matlab and python codes the toeplitz matrix rstarts with
the index n. this is because, as you can see from figure 10.25 , the origin of the autocor-
relation function is the middle index of the computed autocorrelation function. for r, the
starting index is n+ 1 because the vector starts with ry[1].
to predict the future samples, we recall the autoregressive model for this problem:
by[n] =k−1x
k=0h[k]y[n−k].
therefore, given y[n−1], y[n−2], . . . , y [n−k], we can predict by[n]. then we insert this
predicted by[n] into the sequence and increment the estimation problem to the next time
index. by repeating the process, we will be able to predict the future samples of y[n].
66010.6. optimal linear filter
figure 10.26 illustrates the prediction results of the yule-walker equation. as you can
see, the predictions are reasonably meaningful since the patterns follow the trend.
0 50 100 150 200 250 300 350-0.3-0.2-0.100.10.2
prediction
input
figure 10.26: an example of the predictions made by the autoregressive model.
the matlab and python codes are shown below.
% matlab code to predict the samples
z = y(311:320);
yhat = zeros(340,1);
yhat(1:320) = y;
for t = 1:20
predict = z’*h;
z = [z(2:10); predict];
yhat(320+t) = predict;
end
plot(yhat, ’r’, ’linewidth’, 3); hold on;
plot(y, ’k’, ’linewidth’, 4);
# python code to predict the samples
z = y[310:320]
yhat = np.zeros((340,1))
yhat[0:320,0] = y
for t in range(20):
predict = np.inner(np.reshape(z,(1,10)),h)
z = np.concatenate((z[1:10], predict))
yhat[320+t,0] = predict
plt.plot(yhat,’r’)
plt.plot(y,’k’)
plt.show()
661chapter 10. random processes
10.6.5 wiener filter
in the previous formulation, we notice that the impulse response has a finite length. there
are, however, problems in which the impulse response is infinite. for example, a recur-
sive filter h[n] will be infinitely long. the extension from finite length to infinite length is
straightforward. we can model the problem as
y[n] =∞x
k=−∞h[k]x[n−k] +e[n].
however, when h[n] is infinitely long the yule-walker equation does not hold because the
matrix rwill be infinitely large. nevertheless, the building block equation for yule-walker
is still valid:
ry x[i] =∞x
k=−∞h[k]rx[i−k]. (10.45)
to maintain the spirit of the yule-walker equation while enabling computation, we
recognize that the infinite sum on the right-hand side is, in fact, a convolution . thus we
can take the (discrete-time) fourier transform of both sides to obtain
sy x(ejω) =h(ejω)sx(ejω). (10.46)
therefore, the corresponding optimal linear filter (in the fourier domain) is
h(ejω) =sy x(ejω)
sx(ejω), (10.47)
and
h[n] =f−1sy x(e−jω)
sx(e−jω)
.
the filter obtained in this way is known as the wiener filter .
example 10.21 . (denoising ) suppose x[n] =y[n] +w[n], where w[n] is the noise
term that is independent of y[n], as shown in figure 10.27 .
figure 10.27: design of a wiener filter that takes an input function x[n]and outputs an estimate
by[n]that is close to the true function y[n].
now, given the input function x[n], can we construct the wiener filter h[n] such
that the predicted function by[n] is as close to y[n] as possible? the wiener filter for
this problem is also the optimal denoising filter.
66210.6. optimal linear filter
solution . the following correlation functions can easily be seen:
rx[k] =e[x[n+k]x[n]]
=e[(y[n+k] +w[n+k])(y[n] +w[n])]
=e[y[n+k]y[n]] +e[y[n+k]w[n]]
+e[w[n+k]y[n]] +e[w[n+k]w[n]]
=e[y[n+k]y[n]] + 0 + 0 + e[w[n+k]w[n]]
=ry[k] +rw[k].
similarly, we have
ry x[k] =e[y[n+k]x[n]]
=e[y[n](y[n+k] +w[n+k])] = ry[k].
consequently, the optimal linear filter is
h(ejω) =sy x(ejω)
sx(ejω)
=f{ry x[k]}
f{rx[k]}
=sy(ejω)
sy(ejω) +sw(ejω).
what is the wiener filter for a denoising problem?
suppose the corrupted function x[n] is related to the clean function y[n] through
x[n] =y[n] +w[n], for some noise function w[n].
the wiener filter is
h(ejω) =sy(ejω)
sy(ejω) +sw(ejω). (10.48)
to perform the filtering, the denoised function by[n] is
by[n] =f−1
h(ejω)x(ejω)	
.
figure 10.28 shows an example of applying the wiener filter to a noise removal prob-
lem. in this example we let w[n] be an i.i.d. gaussian process with standard deviation
σ= 0.05 and mean µ= 0. the noisy samples of random process x[n] are defined as
x[n] =y[n]+w[n], where y[n] is the clean function. as you can see from figure 10.28 (a),
the wiener filter is able to denoise the function reasonably well.
the optimal linear filter used for this denoising task is infinitely long. this can be seen
infigure 10.28 (b), where the filter length is the same as the length of the observed time
series x[n]. ifx[n] is longer, the filter h[n] will also become longer. therefore, finite-length
approaches such as the yule-walker equation do not apply here.
663chapter 10. random processes
0 50 100 150 200 250 300-0.2-0.100.10.2
noisy input x[n]
wiener filtered yhat[n]
ground truth y[n]
-300 -200 -100 0 100 200 300-0.0500.050.10.150.20.25 h[n]
(a) noise removal by wiener filtering (b) wiener filter
figure 10.28: (a) applying a wiener filter to denoise a function. (b) the wiener filter used for the
denoising task.
the matlab / python codes used to generate figure 10.28 (a) are shown below.
the main commands here are scipy.fft andscipy.ifft , which are available in the scipy
library. the commands yhat = h.*fft(x, 639) in matlab execute the wiener filtering
step. here, we resample the function xto 639 samples so that it matches with the wiener
filter h. similar commands in python are h * fft(x, 639) .
% matlab code for wiener filtering
w = 0.05*randn(320,1);
x = y + w;
ry = xcorr(y);
rw = xcorr(w);
sy = fft(ry);
sw = fft(rw);
h = sy./(sy + sw);
yhat = h.*fft(x, 639);
yhat = real(ifft(yhat));
plot(x, ’linewidth’, 4, ’color’, [0.7, 0.7, 0.7]); hold on;
plot(yhat(1:320), ’r’, ’linewidth’, 2);
plot(y, ’k:’, ’linewidth’, 2);
# python code for wiener filtering
from scipy.fft import fft, ifft
w = 0.05*np.random.randn(320)
x = y + w
ry = np.correlate(y,y,mode=’full’)
rw = np.correlate(w,w,mode=’full’)
sy = fft(ry)
sw = fft(rw)
h = sy / (sy+sw)
yhat = h * fft(x, 639)
66410.6. optimal linear filter
yhat = np.real(ifft(yhat))
plt.plot(x,color=’gray’)
plt.plot(yhat[0:320],’r’)
plt.plot(y,’k:’)
example 10.22 . (deconvolution ) suppose that the corrupted function is generated
according to a linear process given by
x[n] =∞x
ℓ=−∞g[ℓ]y[n−ℓ] +w[n],
where g[n] is the impulse response of some kind of degradation process and w[n] is
the gaussian noise term, as shown in figure 10.29 . find the optimal linear filter (i.e.,
the wiener filter) to estimate by[n].
figure 10.29: design of a wiener filter that takes an input function x[n]and outputs an estimate
by[n]that is close to the true function y[n].
solution . to construct the wiener filter, we first determine the cross-correlation func-
tion:
ry x[k] =e[y[n+k]x[n]] =e"
y[n+k]∞x
ℓ=−∞g[ℓ]y[n−ℓ] +w[n]#
.
using algebra, it follows that
e"
y[n+k]∞x
ℓ=−∞g[ℓ]y[n−ℓ] +w[n]#
=∞x
ℓ=−∞g[ℓ]e[y[n+k]y[n−ℓ]] +e[y[n+k]w[n]]
=∞x
ℓ=−∞g[ℓ]ry[k+ℓ] + 0 = ( g⊛ry)[k],
which is the correlation between gandry. therefore, the cross power spectral density
sy x(ejω) is
sy x(ejω) =g(ejω)sy(ejω).
665chapter 10. random processes
the autocorrelation of this problem is
rx[k] =e[x[n+k]x[n]]
=e[((g∗y)[n+k] +w[n+k])((g∗y)[n] +w[n])]
=e[(g∗y)[n+k](g∗y)[n]] +e[w[n+k]w[n]]
= (g⊛(g∗ry))[k] +rw[k],
where, according to the previous section, the first part is the correlation ⊛followed by
a convolution ∗. therefore, the power spectral density of xis
sx(ejω) =|g(ejω)|2sy(ejω) +sw(ejω).
combining the results, the wiener filter is
h(ejω) =sy x(ejω)
sx(ejω)=g(ejω)sy(ejω)
|g(ejω)|2sy(ejω) +sw(ejω).
what is the wiener filter for a deconvolution problem?
suppose that the corrupted function x[n] is related to the clean function y[n]
through x[n] = (g∗y)[n] +w[n], for some degradation g[n] and noise w[n].
the wiener filter is
h(ejω) =g(ejω)sy(ejω)
|g(ejω)|2sy(ejω) +sw(ejω). (10.49)
to perform the filtering, the estimated function by[n] is
by[n] =f−1
h(ejω)x(ejω)	
.
as an example of the deconvolution problem, we show a wss function y[n] infig-
ure 10.30 . this clean function y[n] is constructed by passing an i.i.d. noise process through
an arbitrary lti system so that the wss property is guaranteed. given this y[n], we con-
struct a degradation process in which the impulse response is given by g[n]. in this example,
we assume that g[n] is a uniform function. we then add noise w[n] to the time series to
obtain the corrupted observation x[n]. the reconstruction by the wiener filter is shown in
figure 10.30 .
the matlab and python codes used to generate figure 10.30 are shown below.
% matlab code to solve the wiener deconvolution problem
load(’ch10_wiener_deblur_data’);
g = ones(32,1)/32;
w = 0.02*randn(320,1);
x = conv(y,g,’same’) + w;
ry = xcorr(y);
66610.6. optimal linear filter
50 100 150 200 250 300-0.8-0.6-0.4-0.200.20.40.6
noisy input x[n]
wiener filtered yhat[n]
ground truth y[n]
figure 10.30: reconstructing time series from degraded observations using a wiener filter.
rw = xcorr(w);
sy = fft(ry);
sw = fft(rw);
g = fft(g,639);
h = (conj(g).*sy)./(abs(g).^2.*sy + sw);
yhat = h.*fft(x, 639);
yhat = real(ifft(yhat));
figure;
plot(x, ’linewidth’, 4, ’color’, [0.5, 0.5, 0.5]); hold on;
plot(16:320+15, yhat(1:320), ’r’, ’linewidth’, 2);
plot(1:320, y, ’k:’, ’linewidth’, 2);
# python code to solve the wiener deconvolution problem
y = np.loadtxt(’./ch10_wiener_deblur_data.txt’)
g = np.ones(64)/64
w = 0.02*np.random.randn(320)
x = np.convolve(y,g,mode=’same’) + w
ry = np.correlate(y,y,mode=’full’)
rw = np.correlate(w,w,mode=’full’)
sy = fft(ry)
sw = fft(rw)
g = fft(g,639)
h = (np.conj(g)*sy)/( np.power(np.abs(g),2)*sy + sw )
yhat = h * fft(x, 639)
yhat = np.real(ifft(yhat))
plt.plot(x,color=’gray’)
667chapter 10. random processes
plt.plot(np.arange(32,320+32),yhat[0:320],’r’)
plt.plot(y,’k:’)
caveat to wiener filtering . in practice, the above wiener filter needs to be modified
because sy(ejω) and sw(ejω) cannot be estimated from the data via the temporal corre-
lation (as we did in the matlab/python programs). the reason is that we never have
access to y[n] and w[n]. in this case, one has to guess the power spectral densities sy(ejω)
andsw(ejω). the noise power sw(ejω) is usually not difficult to estimate. for example,
in the program we showed above, the noise power spectral density is sw = 0.02^2*320
(matlab), which is the noise standard deviation times the number of samples.
the signal sy(ejω) is often the hard part. in the absence of any knowledge about the
ground truth’s power spectral density, the wiener filter does not work. however, for certain
problems in which sy(ejω) can be predetermined by prior knowledge, the wiener filter is
guaranteed to be optimal — optimal in the mean-squared-error sense over the entire time
axis.
wiener filter versus ridge regression . the wiener filter equation can be interpreted
as a ridge regression. denoting the forward observation model by
x=gy+w,
the corresponding ridge regression minimization is
by= argmin
y∥x−gy∥2+λ∥y∥2
= (gtg+λi)−1gtx.
ifgis a convolutional matrix, the above solution can be written in the fourier domain (by
using the fourier transform as the eigenvectors):
by(ejω) ="
g(ejω)
|g(ejω)|2+λ#
| {z }
h(ejω)x(ejω).
comparing this “optimal linear filter” with the wiener filter, we observe that the wiener
filter has slightly more generality:
by(ejω) ="
g(ejω)sy(ejω)
|g(ejω)|2sy(ejω) +sw(ejω)#
x(ejω).
therefore, in the absence of sy(ejω) and assuming that sw(ejω) is a constant (e.g., for
gaussian noise), the wiener filter is exactly a ridge regression.
66810.7. summary
10.7 summary
random processes are very useful tools for analyzing random variables over time. in this
chapter, we have introduced some of the most basic mechanisms:
statistical versus temporal analysis : the statistical analysis of a random process
looks at the random process vertically . it treats x(t) as a random variable and studies
the randomness across different realizations. the temporal analysis is the horizontal
perspective. it treats x(t) as a function in time with a fixed random index. in general,
statistical average ̸= temporal average.
mean function µx(t): the mean function is the expectation of the random process.
at every time t, we take the expectation to obtain the expected value e[x(t)].
autocorrelation function rx(t1, t2). this is the joint expectation of the random pro-
cess at two different time instants t1andt2. the corresponding values x(t1) and x(t2)
are two random variables, and so the joint expectation measures how correlated these
two variables are.
wide-sense stationary (wss) : this is a special class of random processes in which
µx(t) is a constant and rx(t1, t2) is a function of t1−t2. when this happens, the auto-
correlation function (which is originally a 2d function) will have a toeplitz structure.
we write rx(t1, t2) asrx(τ), where τ=t1−t2.
power spectral density (psd) : this is the fourier transform of the autocorrelation
function rx(τ), according to the einstein-wiener-khinchin theorem. it is called the
power spectral density because we can integrate it in the fourier space to retrieve the
power. this provides us with some convenient computational tools for analyzing data.
random process through a linear time-invariant (lti) system : this tells us how a
random process behaves after going through an lti system. the analysis can be done
at the realization level, where we look at each random process, or at the statistical
level, where we look at the autocorrelation function and the psd.
optimal linear filter : a set of techniques that can be used to retrieve signals by using
the statistical information of the data and the system. we introduced two specific
approaches: the yule-walker equation for a finite-length filter and the wiener filter
for an infinite-length filter. we demonstrated how these techniques could be applied
to forecast a time series and recover a time series from corrupted measurements.
while we have covered some of the most basic ideas in random processes, there are
also several topics we have not discussed. these include, but are not limited to: strictly
stationary process, a more restrictive class of random process than wss; poisson process,
a useful model for arrival analysis; markov chain, a discrete-time random process where
the current state only depends on the previous state. readers interested in these materials
should consult the references listed at the end of this chapter.
669chapter 10. random processes
10.8 appendix
the einstein-wiener-khinchin theorem
the einstein-wiener-khinchin theorem is a fundamental result. it states that for any wide-
sense stationary process, the power spectral density sx(ω) is the fourier transform of the
autocorrelation function.
theorem 10.10 (the einstein-wiener-khinchin theorem ).for a wss random pro-
cessx(t),
sx(ω) =f {rx(τ)}, (10.50)
whenever the fourier transform of rx(τ)exists.
proof . first, let’s recall the definition of sx(ω):
sx(ω)def= lim
t→∞1
2teh
|ext(ω)|2i
. (10.51)
by expanding the expectation, we have
e[|ext(ω)|2] =e" zt
−tx(t)e−jωtdt! zt
−tx(θ)e−jωθdθ!∗#
=zt
−tzt
−te[x(t)x(θ)]e−jω(t−θ)dt dθ =zt
−tzt
−trx(t−θ)e−jω(t−θ)dt dθ.
(10.52)
our next step is to analyze rx(t−θ). define
qx(v) =f {rx(τ)}. (10.53)
then, by inverse fourier transform
rx(τ) =1
2πz∞
−∞qx(v)ejvτdv,
and therefore
rx(t−θ) =1
2πz∞
−∞qx(v)ejv(t−θ)dv.
substituting this into equation (10.52) yields
e[|ext(ω)|2=zt
−tzt
−t1
2πz∞
−∞qx(v)ejv(t−θ)dv
e−jω(t−θ)dt dθ
=1
2πz∞
−∞qx(v) zt
−tejt(v−ω)dt! zt
−tejθ(ω−v)dθ!
dv.
67010.8. appendix
we now need to simplify the two inner integrals. recall by fourier pair that
rectt
t
f
←→tsincωt
2
.
this implies that
zt
−tejt(v−ω)dt=zt
−te−j(ω−v)tdt
=z∞
−∞rect(t
2t)e−j(ω−v)tdt= 2tsinc(( ω−v)t) = 2 tsin((ω−v)t)
(ω−v)t.
hence, we have
eh
|ext(ω)|2i
=1
2πz∞
−∞qx(v)
2tsin((ω−v)t)
(ω−v)t2
dv. (10.54)
and so
1
2te[|ext(ω)|2=2t
2πz∞
−∞qx(v)sin((ω−v)t)
(ω−v)t2
dv. (10.55)
ast→ ∞ (see lemma 10.5 below), we have
2tsin((ω−v)t)
(ω−v)t2
−→ 2πδ(ω−v).
therefore,
lim
t→∞1
2teh
|ext(ω)|2i
=1
2πz∞
−∞qx(v)"
lim
t→∞2tsin((ω−v)t)
(ω−v)t2#
dv
=z∞
−∞qx(v)δ(ω−v)dv=qx(ω).
since qx(ω) =f[rx(τ)], we conclude that
sx(ω) = lim
t→∞1
2te[|ext(ω)|2] =qx(ω) =f[rx(τ)].
lemma 10.5.
lim
t→∞1
2πz∞
−∞qx(v)2tsin((ω−v)t)
(ω−v)t2
dv=qx(ω). (10.56)
to prove this lemma, we first define δt(ω) = 2 t(sin(ωt)
ωt)2. it is sufficient to show that
lim
t→∞1
2πz∞
−∞qx(v)2tsin((ω−v)t)
(ω−v)t2
dv−qx(ω)→0 as t→ ∞ .(10.57)
we will proceed by demonstrating the following three facts about δt(ω):
671chapter 10. random processes
1.
1
2πz∞
−∞δt(ω)dω= 1
.
2. for any △>0, z
{ω:|ω|>△}δt(ω)dω→0 as t→ ∞
.
3. for any |ω| ≥ △ >0, we have |δt(ω)| ≤2
t△2.
proof of fact 1 .
1
2πz∞
−∞δt(ω)dω=1
2πz∞
−∞2tsin(ωt)
ωt2
|{z}
sinc2(ωt)dω.
note that
λt
4t
←→2tsinc2(ωt).
therefore,
1
2πz∞
−∞2tsinc2(ωt)dω=1
2πz∞
−∞2tsinc2(ωt)ejω0dω
= λ0
4t
= 1.
proof of fact 2 .δt(ω) is symmetric, so, it is sufficient to check only one side:
z∞
△δt(ω)dω=z∞
△2tsin(ωt)
ωt2
dω
=2t
t2z∞
△sin2(ωt)
ω2dω
≤2
tz∞
△1
ω2dω |sin(.)|2≤1
=2
t
−1
ω∞
△=2
t△→0 as t→ ∞ .
proof of fact 3 .
|δt(ω)|= 2tsin(ωt)
ωt2
≤2t1
(ωt)2
=2
ω2t≤2
t△2.
proof of lemma . consider qx(ω). by property 1,
qx(ω) =qx(ω).1
2πz∞
−∞δt(ω−v)dv=1
2πz∞
−∞qx(ω)δt(ω−v)dv.
67210.8. appendix
therefore,
1
2πz∞
−∞qx(v)δt(ω−v)dv−qx(ω)
=1
2πz∞
−∞qx(v)δt(ω−v)dv−1
2πz∞
−∞qx(ω)δt(ω−v)dv
=1
2πz∞
−∞(qx(v)−qx(ω))δt(ω−v)dv≤1
2πz∞
−∞qx(v)−qx(ω)δt(ω−v)dv.
for any ϵ >0, let△be a constant such that
|ω−v|<△ whenever |qx(v)−qx(ω)|< ϵ.
then we can partition the above integral into
1
2πz∞
−∞qx(ω)−qx(v)δt(ω−v)dv=1
2πzω+△
ω−△qx(ω)−qx(v)δt(ω−v)dv(1)
+1
2πz∞
ω+△qx(ω)−qx(v)δt(ω−v)dv (2)
+1
2πzω+△
−∞qx(ω)−qx(v)δt(ω−v)dv. (3)
partition (1) above can be evaluated as follows:
1
2πzω+△
ω−△qx(ω)−qx(v)δt(ω−v)dv
≤1
2πzω+△
ω−△ϵδt(ω−v)dv
=ϵ
2πzω+△
ω−△δt(ω−v)dv
≤ϵ
2πz∞
−∞δt(ω−v)dv=ϵ,
where the last inequality holds because δt(ω−v)≥0. since ϵcan be arbitrarily small, the
only possibility for
1
2πzω+△
ω−△qx(ω)−qx(v)δt(ω−v)dv
for all ϵis that the integral is 0.
partition (2) above can be evaluated as follows:
1
2πz∞
ω+△qx(ω)−qx(v)δt(ω−v)dv
≤1
2πz∞
ω+△ qx(ω)+qx(v)
δt(ω−v)dv
=qx(ω)1
2πz∞
ω+△δt(ω−v)dv+1
2πz∞
ω+△qx(v)δt(ω−v)dv.
673chapter 10. random processes
by property 2,1
2πr∞
ω+△δt(ω−v)dv→0 ast→ ∞ . by property 3,
1
2πz∞
ω+△qx(v)δt(ω−v)dv≤1
2π2
t△2z∞
ω+△qx(v)dv
| {z }
<∞because qx(v)=f[rx(τ)]→0.
therefore, we conclude that
1
2πz∞
ω+△qx(v)δt(ω−v)dv→0 as t→ ∞ .
and hence (1), (2) and (3) all →0 ast→ ∞ . so we have
lim
t→∞1
2πz∞
−∞qx(v)2tsin((ω−v)t)
(ω−v)t2
dv−qx(ω)→0 as t→ ∞ ,
which completes the proof.
10.8.1 the mean-square ergodic theorem
the mean-square ergodic theorem states that for any wss random process, the statistical
average is the same as the temporal average . this provides an important tool in practice
because finding the statistical average is typically very difficult. with the mean ergodic
theorem, one can easily estimate the statistical average using the temporal average.
theorem 10.11 (mean-square ergodic theorem ).lety(t)be a wss process,
with mean e[y(t)] =mand autocorrelation function ry(τ). assume that the fourier
transform of ry(τ)exists. define
mtdef=1
2tzt
−ty(t)dt. (10.58)
thenehmt−m2i
→0ast→ ∞ .
proof of mean ergodic theorem . let x(t) =y(t)−m. it follows that
mt−m=1
2tzt
−ty(t)dt−m=1
2tzt
−tx(t)dt.
we define the finite-window approximation of x(t):
xt(t) =x(t),−t≤t≤t,
0, elsewhere .
then the difference mt−mcan be computed as
mt−m=1
2tzt
−tx(t)dt=1
2tz∞
−∞x(t)e−j0tdt=1
2text(ω)
ω=0=ext(0)
2t.
67410.9. references
taking the expectation of the squares yields
e
|mt−m|2
=ehext(0)2i
4t2.
recall from the einstein-wiener-khinchin theorem,
1
2tehext(ω)2i
=1
2πz∞
−∞sx(v)2tsin((ω−v)t)
(ω−v)t2
dv.
putting the limit t→ ∞ , if we have that
lim
t→∞1
2πz∞
−∞sx(v)2tsin((ω−v)t)
(ω−v)t2
dv=sx(ω),
then we will have
1
2tehext(ω)2i
→sx(ω) and1
2tehext(0)2i
→sx(0).
hence,
lim
t→∞ehmt−m2i
= lim
t→∞1
2tehext(0)2i
= lim
t→∞1
2tsx(0) = 0 .
this completes the proof.
10.9 references
basic texts
the following textbooks are basic texts about random processes. they offer many comple-
mentary materials to our book. for example, we omitted the topics of straightly stationary
processes and memoryless properties. we have also omitted a few classical examples, such
as the random telegraph signal, the incremental independence of poisson processes, and
markov chains. these materials can be found in the texts below.
10-1 john a. gubner, probability and random processes for electrical and computer en-
gineers , cambridge university press, illustrated edition, 2006.
10-2 alberto leon-garcia, probability, statistics, and random processes for electrical en-
gineering , pearson, 3rd edition, 2007.
10-3 athanasios papoulis, s. unnikrishna pillai, probability, random variables and stochas-
tic processes , mcgraw-hill, 4th edition, 2012.
10-4 henry stark and john woods, probability and random processes with applications
to signal processing , prentice hall, 3rd edition, 2001.
675chapter 10. random processes
10-5 eugene wong and bruce hajek, stochastic processes in engineering systems , springer-
verlag, 1985.
10-6 bruce hajek, random processes for engineers , cambridge university press, 2015.
10-7 dimitri p. bertsekas and john n. tsitsiklis, introduction to probability , athena sci-
entific, 2nd edition, 2008.
10-8 robert g. gallager, stochastic processes: theory for applications , cambridge uni-
versity press, 1st edition, 2014.
signal and systems / fourier transforms
the following references are classic references on signal and systems.
10-9 alan oppenheim and ronald schafer, discrete-time signal processing , 2nd edition,
prentice hall 1999.
10-10 alan oppenheim and alan willsky, signals and systems , pearson, 2nd edition, 1996.
10-11 martin vetterli, jelena kovacevic, and vivek k. goyal, foundations of signal pro-
cessing , cambridge university press, 3rd edition, 2014.
10-12 todd k. moon and wynn c. stirling, mathematical methods and algorithms for signal
processing , prentice-hall, 2000.
engineering applications
10-13 john g. proakis and masoud salehi, communication systems engineering , pearson,
2nd edition, 2001.
10-14 rodger e. ziemer, william h. tranter, principles of communications , wiley, 7th
edition, 2014.
10-15 joseph w. goodman, statistical optics , wiley, 2015.
10.10 problems
exercise 1. (video solution)
consider the random process
x(t) = 2 acos(t) + (b−1) sin( t),
where aandbare two independent random variables with e[a] =e[b] = 0, and e[a2] =
e[b2] = 1.
(a) find µx(t).
(b) find rx(t1, t2).
67610.10. problems
(c) find cx(t1, t2).
exercise 2. (video solution)
letx[n] be a discrete-time random process with mean function mx[n] =e{x[n]}and
correlation function rx[n, m] =e{x[n]x[m]}. suppose that
y[n] =∞x
i=−∞h[n−i]x[i]. (10.59)
(a) find µy[n].
(b) find rxy[n, m].
exercise 3. (video solution)
lety(t) =x(t)−x(t−d).
(a) find rx,y(τ) and sx,y(ω).
(b) find ry(τ).
(c) find sy(ω).
exercise 4. (video solution)
letx(t) be a zero-mean wss process with autocorrelation function rx(τ). let y(t) =
x(t) cos( ωt+ θ), where θ ∼uniform( −π, π) and θ is independent of the process x(t).
(a) find the autocorrelation function ry(τ).
(b) find the cross-correlation function of x(t) and y(t).
(c) is y(t) wss? why or why not?
exercise 5. (video solution)
a wss process x(t) with autocorrelation function
rx(τ) = 1 /(1 +τ2)
is passed through an lti system with impulse response
h(t) = 3 sin( πt)/(πt).
lety(t) be the system output. find sy(ω) and sketch sy(ω).
exercise 6. (video solution)
a white noise x(t) with power spectral density sx(ω) =n0/2 is applied to a lowpass filter
h(t) with impulse response
h(t) =1
rce−t/rc, t > 0. (10.60)
find the followings.
677chapter 10. random processes
(a)sxy(ω).
(b)rxy(τ).
(c)sy(ω).
(d)ry(τ).
exercise 7. (video solution)
consider a wss process x(t) with autocorrelation function
rx(τ) = sinc( πτ).
the process is sent to an lti system with input-output relationship
2d2
dt2y(t) + 2d
dty(t) + 4y(t) = 3d2
dt2x(t)−3d
dtx(t) + 6x(t).
find the autocorrelation function ry(τ).
exercise 8. (video solution)
given the functions a(t),b(t) and c(t), let
g(t,1) = a(t),
g(t,2) = b(t),
g(t,3) = c(t).
letx(t) = g(t, z), where zis a discrete random variable with pmf p[z= 1] = p1,
p[z= 2] = p2andp[z= 3] = p3. find, in terms of the p1,p2,p3,a(t),b(t) and c(t),
(a)µx(t).
(b)rx(t1, t2).
exercise 9.
in the previous problem, let a(t) =e−λ|t|,b(t) = sin( πt) and c(t) =−1.
(a) choose p1,p2,p3so that x(t) is wss.
(b) choose p1,p2,p3so that x(t) is not wss.
exercise 10. (video solution)
find the autocorrelation function rx(τ) corresponding to each of the following power spec-
tral densities:
(a)δ(ω−ω0) +δ(ω+ω0).
(b)e−ω2/2.
(c)e−|ω|.
67810.10. problems
exercise 11. (video solution)
a wss process x(t) with autocorrelation function rx(τ) =e−τ2/(2σ2
t)is passed through
an lti system with transfer function h(ω) =e−ω2/(2σ2
h). denote the system output by
y(t). find the followings.
(a)sxy(ω).
(b)rxy(τ).
(c)sy(ω).
(d)ry(τ).
exercise 12. (video solution)
a white noise x(t) with power spectral density sx(ω) =n0/2 is applied to a lowpass filter
h(t) with
h(ω) =(
1−ω2,if|ω| ≤π,
0, otherwise .
finde[|y(t)|2], where y(t) is the output of the filter.
exercise 13. (video solution)
letx(t) be a wss process with correlation function
rx(τ) =(
1− |τ|,if−1≤τ≤1,
0, otherwise .(10.61)
it is known that when x(t) is input to a system with transfer function h(ω), the system
output y(t) has a correlation function
ry(τ) =sinπτ
πτ. (10.62)
find the transfer function h(ω).
exercise 14.
consider the system
y(t) =e−tzt
−∞eτx(τ)dτ.
assume that x(t) is zero-mean white noise with power spectral density sx(ω) =n0/2.
find the followings:
(a)sxy(ω).
(b)rxy(τ).
(c)sy(ω).
(d)ry(τ).
679chapter 10. random processes
680chapter a
appendix
useful identities
1.∞p
k=0rk= 1 + r+r2+···=1
1−r
2.np
k=1k= 1 + 2 + 3 + ···+n=n(n+1)
2
3.ex=∞p
k=0xk
k!= 1 +x
1!+x2
2!+···
4.∞p
k=1krk−1= 1 + 2 r+ 3r2+···=1
(1−r)2
5.np
k=1k2= 12+ 22+ 33+···+n2=n3
3+n2
2+n
6
6. (a+b)n=np
k=0 n
k
akbn−k
common distributions
distribution pmf / pdf e[x] var[ x] mx(s)
bernoulli px(1) = pandpx(0) = 1 −p p p (1−p) 1 −p+pes
binomial px(k) = n
k
pk(1−p)n−knp np (1−p) (1 −p+pes)n
geometric px(k) =p(1−p)k−11
p1−p
p2pes
1−(1−p)es
poisson px(k) =λke−λ
k!λ λ eλ(es−1)
gaussian fx(x) =1√
2πσ2exp
−(x−µ)2
2σ2
µ σ2exp
µs+σ2s2
2
exponential fx(x) =λexp{−λx}1
λ1
λ2λ
λ−s
uniform fx(x) =1
b−aa+b
2(b−a)2
12esb−esa
s(b−a)
681chapter a. appendix
sum of two random variables
x1 x2 sum x1+x2
bernoulli( p) bernoulli( p) binomial(2 , p)
binomial( n, p) binomial( m, p) binomial( m+n, p)
poisson( λ1) poisson( λ2) poisson( λ1+λ2)
exponential( λ) exponential( λ) erlang(2 , λ)
gaussian( µ1, σ2
1) gaussian( µ2, σ2
2) gaussian( µ1+µ2, σ2
1+σ2
2)
fourier transform table
f(ω) =z∞
−∞f(t)e−jωtdt.
f(t)←→f(ω) f(t)←→f(ω)
1. e−atu(t)←→1
a+jω,a >0 10. sinc2wt
2
←→2π
w∆ω
2w
2. eatu(−t)←→1
a−jω,a >0 11. e−atsin(ω0t)u(t)←→ω0
(a+jω)2+ω2
0,a >0
3. e−a|t|←→2a
a2+ω2,a >0 12. e−atcos(ω0t)u(t)←→a+jω
(a+jω)2+ω2
0,a >0
4.a2
a2+t2←→πae−a|ω|,a >0 13. expn
−t2
2σ2o
←→√
2πσexpn
−σ2ω2
2o
5. te−atu(t)←→1
(a+jω)2,a >0 14. δ(t)←→1
6.tne−atu(t)←→n!
(a+jω)n+1,a >0 15. 1 ←→2πδ(ω)
7. rectt
τ
←→τsincωτ
2
16. δ(t−t0)←→e−jwt0
8. sinc( wt)←→π
wrectω
2w
17. ejω0t←→2πδ(ω−ω0)
9. ∆t
τ
←→τ
2sinc2ωτ
4
18. f(t)ejω0t←→f(ω−ω0)
some definitions:
sinc(t) =sin(t)
t
rect(t) =(
1,−0.5≤t≤0.5,
0, otherwise .
∆(t) =(
1−2|t|,−0.5≤t≤0.5,
0, otherwise .
682basic trigonometric identities
ejθ= cos θ+jsinθ
sin 2θ= 2 sin θcosθ
cos 2θ= 2 cos2θ−1
cosacosb=1
2(cos(a+b) + cos( a−b))
sinasinb=−1
2(cos(a+b)−cos(a−b))
sinacosb=1
2(sin(a+b) + sin( a−b))
cosasinb=1
2(sin(a+b)−sin(a−b))
cos(a+b) = cos acosb−sinasinb
cos(a−b) = cos acosb+ sin asinb
sin(a+b) = sin acosb+ cos asinb
sin(a−b) = sin acosb−cosasinb
683index
absolutely integrable, 183
almost sure convergence, 362
autocorrelation function
2d visualization, 622
interpretation, 623, 633
lti system, 644
properties, 632
temporal average, 635
definition, 618
matlab and python, 625
autocovariance function
definition, 618
relation to autocorrelation function, 628
autoregressive model, 406, 658
linear prediction, 658
matlab and python, 407, 659
prediction, 660
toeplitz, 659
yule-walker equation, 658
basel problem, 5
basis functions, 405
bayes’ theorem, 89
conditional probability, 81
law of total probability, 90
bayesian, 43
bernoulli random variable
definition, 137
matlab and python, 137
maximum variance, 140
properties, 138
bias-variance
average predictor, 433
matlab and python, 434
noise-free case, 430
noisy case, 433
trade off, 429
binomial random variable
alternative definition, 148definition, 143
matlab and python, 144
properties, 146
binomial series, 6
binomial theorem, 6
proof, 9
birthday paradox, 31, 321
bootstrapping, 559
bootstrapped distribution, 562
confidence interval, 559
definition, 559
distribution of samples, 560
interpretation, 564
matlab and python, 565
procedure, 562
standard error, 565
when to use, 560
cauchy distribution, 331, 360
cauchy-schwarz inequality, 261, 335
central limit theorem, 323, 366, 372, 381
berry-esseen theorem, 375
examples, 376
interpretation, 375
limitations, 378
proof, 374
characteristic function, 329
alternative definition, 329
fourier transform, 330
chebyshev’s inequality, 341
proof, 342
chernoff’s bound, 343
compare with chebyshev, 344
chernoff, herman, 343
combination, 34
concave function, 336
conditional distribution
conditional expectation, 275
conditional pdf, 271
684index
conditional pmf, 267
conditional probability, 81
bayes’ theorem, 89
definition, 81
independence, 85
properties, 84
ratio, 81
confidence interval, 541
bootstrapping, 559
critical value, 552
definition, 546
distribution of estimator, 544
estimator, 543
examples, 547
how to construct, 548
interpretation, 545
margin of error, 552
matlab and python, 550
number of samples, 553
properties, 551
standard error, 551
student’s t-distribution, 554
conjugate prior, 513
convergence in distribution, 367
convergence in probability, 356
convex function, 336
convex optimization
cvxpy, 451
convolution, 220, 639
correlation, 639
filtering, 639
correlation, 633
autocorrelation function, 618
autocovariance function, 618
cross-correlation function, 649
convolution, 639
correlation coefficient
matlab and python, 265
properties, 263
definition, 263
cosine angle, 26
covariance, 261
covariance matrix, 289
independent, 289
cross power spectral density, 651
cross-correlation function
cross-covariance function, 629
definition, 629examples, 650
through lti systems, 649
cross-covariance function, 629
cross-correlation function, 629
cumulative distribution function
continuous, 186
discrete, 121
left- and right-continuous, 190
matlab and python, 186
properties, 188
delta function, 178
discrete cosine transform (dct), 23
eigenvalues and eigenvectors, 295
gaussian, 296
matlab and python, 296
erd˝ os-r´ enyi graph, 140
matlab and python, 480
even functions, 15
event, 61
event space, 61
expectation, 104
continuous, 180
properties, 130, 182
transformation, 182
center of mass, 127
discrete, 125
existence, 130, 183
exponential random variables
definition, 205
matlab and python, 205
origin, 207, 209
properties, 206
exponential series, 12
field, 64
σ-field, 65
borel σ-field, 65
fourier transform, 644
table, 330
characteristic function, 330
frequentist, 43
fundamental theorem of calculus, 17
chain rule, 19
proof, 18
gaussian random variables
cdf, 214
685index
definition, 211
matlab and python, 212
origin, 220
properties, 212
standard gaussian, 213
geometric random variable
definition, 149
matlab and python, 150
properties, 151
geometric sequence
finite, 4
infinite, 4
geometric series, 3
finite, 4
infinite, 4
harmonic series, 5
histogram, 2, 113
hoeffding’s inequality, 348
hoeffding lemma, 348
proof, 348
hypothesis testing
p-value test, 567, 571
t-test, 574
z-test, 574
alternative hypothesis, 566
critical level, 569
critical-value test, 567
definition, 566
matlab and python, 568
null hypothesis, 566
impulse response, 643
independence, 85
conditional probability, 88
versus disjoint, 86
independent
random variables, 251
independent and identically distributed (i.i.d.),
253
indicator function, 182
inner product, 24
matlab and python, 24
jensen’s inequality, 336
proof, 338
joint distribution
definition, 241
joint cdf, 255joint pdf, 247
joint pmf, 245
joint expectation, 257
cosine angle, 258
kurtosis, 216
matlab and python, 217
laplace transform, 324
law of large numbers, 323, 351, 381
strong law of large numbers, 360
weak law of large numbers, 354
learning curve, 427
matlab and python, 427
legendre polynomial, 403
matlab and python, 404
likelihood, 466, 468, 503
log-likelihood, 470
linear algebra
basis vector, 23
representation, 23
span, 22
standard basis vector, 22
linear combination, 21
linear model, 21
linear prediction, 658
linear programming, 414
linear regression
matlab and python, 30
linear time-invariant (lti)
convolution, 639
definition, 643
system, 643
marginal distribution, 250
markov’s inequality, 339
proof, 339
tight, 341
matrix calculus, 28
maximum-a-posteriori (map), 502
choosing prior, 505
conjugate prior, 513
map versus lasso, 519
map versus ml, 504
map versus regression, 517
map versus ridge, 518
posterior, 503, 511
prior, 503
solution, 506
686index
maximum-likelihood
1d gaussian, 484
consistent estimator, 494
estimation, 468
estimator, 491
high-dimensional gaussian, 486
image reconstruction, 481
independent observations, 469
invariance principle, 500
matlab and python, 472
number of training samples, 475
poisson, 485
regression versus ml, 487
social networks, 478
unbiased estimator, 492
visualization, 471
mean, 199
mean function
lti system, 644
definition, 618
matlab and python, 621
mean squared error (mse), 520, 522
measure, 68
almost surely, 73
finite sets, 68
intervals, 68
lebesgue integration, 71
measure zero sets, 71
definition, 72
examples, 72
regions, 68
size, 69
median, 196
minimum mean-square estimation (mmse),
520
conditional expectation, 523
gaussian, 529
minimum-norm least squares, 411
mode, 198
model selection, 165
moment, 133
continuous case, 184
moment-generating function, 322, 324
common distributions, 326
derivative, 325
existence, 331
sum of random variables, 327
multidimensional gaussian, 290matlab and python, 291
covariance, 293
transformation, 293
whitening, 299
neyman-pearson test, 577
decision rule, 582
likelihood ratio, 584
rejection zone, 578
likelihood ratio test, 578
norm, 24, 26
ℓ1, 27
ℓ∞, 27
matlab and python, 26
weighted, 27
normalization property, 112
odd functions, 15
open and closed intervals, 45
optimal linear filter, 653
deconvolution, 665
denoising, 662
orthogonality condition, 658
wiener filter, 661
yule-walker equation, 656
input function, 654
prediction, 654
target function, 654
orthogonality condition, 658
overdetermined system, 409
overfitting, 418
factors, 420
lasso, 454
linear analysis, 425
source, 429
parameter estimation, 165, 465
pascal triangle, 8
pascal’s identity, 7
performance guarantee
average case, 321
worst case, 321
permutation, 33
poisson random variable
applications, 154
definition, 152
origin, 157
photon arrivals, 161
poisson approximation of binomial, 159
687index
properties, 155
matlab and python, 152
positive semi-definite, 297
posterior, 466, 503
power spectral density, 636
einstein-wiener-khinchin theorem, 636
through lti systems, 646
cross power spectral density, 640, 651
eigendecomposition, 639
fourier transform, 640
origin, 640
wide-sense stationary, 639
pr (precision-recall) curve
definition, 601
matlab and python, 603
precision, 601
recall, 601
principal-component analysis, 303
limitations, 311
main idea, 303
matlab and python, 306
prior, 466, 503
probability, 43, 45
measure of a set, 43
probability axioms, 74
additivity, 75
corollaries, 77
countable additivity, 75
measure, 76
non-negativity, 75
normalization, 75
probability density function, 172
definition, 175
discrete cases, 178
properties, 174
intuition, 172
per unit length, 173
probability inequality, 323, 333
probability law, 66
definition, 66
examples, 66
measure, 67
probability mass function, 104, 110
probability space
(ω,f,p), 58
rademacher random variable, 140
random number generator, 229random process
discrete time, 653
definition, 612
example
random amplitude, 612
random phase, 613
function, 612
independent, 629
index, 612
sample space, 614
statistical average, 614
temporal average, 614
uncorrelated, 630
random variable, 104, 105
function of, 223
transformation of, 223
random vector, 286
expectation, 288
independent, 286
regression, 391, 394
loss, 394
matlab and python, 400
outliers, 412
prediction model, 394
solution, 397
linear model, 395
outliers, 417
squared error, 396
regularization, 440
lasso, 449
matlab and python, 442
parameter, 445
ridge, 440
sparse solution, 449
robust linear regression, 412
matlab and python, 416
linear programming, 414
roc
comparing performance, 597
computation, 592
definition, 589
matlab and python, 593
properties, 591
receiver operating characteristic, 589
sample average, 320, 351
sample space, 59
continuous outcomes, 59
688index
counterexamples, 61
discrete outcomes, 59
examples, 59
exclusive, 61
exhaustive, 61
functions, 59
set, 45
associative, 56
commutative, 56
complement, 52
countable, 45
de morgan’s law, 57
difference, 53
disjoint, 54
distributive, 56
empty set, 48
finite, 45
improper subset, 47
infinite, 45
intersection, 50
finite, 50
infinite, 51
of functions, 46
partition, 55
proper subset, 47
subset, 47
uncountable, 45
union, 48
finite, 48
infinite, 49
universal set, 48
simplex method, 414
skewness, 216
matlab and python, 217
statistic, 320
student’s t-distribution
definition, 554
degrees of freedom, 555
matlab and python, 556
relation to gaussian, 555
sum of random variables, 280
bernoulli, 327
binomial, 328
gaussian, 283, 329
poisson, 328
common distributions, 282
convolution, 281
symmetric matrices, 296taylor approximation, 11
first-order, 11
second-order, 11
exponential, 12
logarithmic, 13
testing error, 420
analysis, 424
testing set, 420
three prisoners problem, 92
toeplitz, 407, 630
training error, 420
analysis, 421
training set, 420
type 1 error
definition, 579
false alarm, 580
false positive, 579
power of test, 581
type 2 error
definition, 579
false negative, 579
miss, 580
underdetermined system, 409
uniform random variables, 202
matlab and python, 203
union bound, 333
validation, 165
variance, 134
properties, 135
continuous case, 184
white noise, 638
wide-sense stationary, 630
jointly, 649
wiener filter, 661
deconvolution, 665
definition, 661
denoising, 662
matlab and python, 661
power spectral density, 662
recursive filter, 661
yule-walker equation, 656
matlab and python, 659
689