{"Mathematical induction": "/wiki/Mathematical_induction", "Recursive acronym": "/wiki/Recursive_acronym#Computer-related_examples", "Recursion": "/wiki/Recursion", "Enlarge": "/wiki/File:RecursiveTree.JPG", "Logo (programming language)": "/wiki/Logo_(programming_language)", "Programming paradigm": "/wiki/Programming_paradigm", "Action language": "/wiki/Action_language", "Array programming": "/wiki/Array_programming", "Automata-based programming": "/wiki/Automata-based_programming", "Concurrent computing": "/wiki/Concurrent_computing", "Actor model": "/wiki/Actor_model", "Choreographic programming": "/wiki/Choreographic_programming", "Multitier programming": "/wiki/Multitier_programming", "Relativistic programming": "/wiki/Relativistic_programming", "Structured concurrency": "/wiki/Structured_concurrency", "Data-driven programming": "/wiki/Data-driven_programming", "Declarative programming": "/wiki/Declarative_programming", "Imperative programming": "/wiki/Imperative_programming", "Functional programming": "/wiki/Functional_programming", "Functional logic programming": "/wiki/Functional_logic_programming", "Purely functional programming": "/wiki/Purely_functional_programming", "Logic programming": "/wiki/Logic_programming", "Abductive logic programming": "/wiki/Abductive_logic_programming", "Answer set programming": "/wiki/Answer_set_programming", "Concurrent logic programming": "/wiki/Concurrent_logic_programming", "Inductive logic programming": "/wiki/Inductive_logic_programming", "Constraint programming": "/wiki/Constraint_programming", "Constraint logic programming": "/wiki/Constraint_logic_programming", "Concurrent constraint logic programming": "/wiki/Concurrent_constraint_logic_programming", "Dataflow programming": "/wiki/Dataflow_programming", "Flow-based programming": "/wiki/Flow-based_programming", "Reactive programming": "/wiki/Reactive_programming", "Functional reactive programming": "/wiki/Functional_reactive_programming", "Ontology language": "/wiki/Ontology_language", "Query language": "/wiki/Query_language", "Differentiable programming": "/wiki/Differentiable_programming", "Dynamic programming language": "/wiki/Dynamic_programming_language", "Event-driven programming": "/wiki/Event-driven_programming", "Function-level programming": "/wiki/Function-level_programming", "Value-level programming": "/wiki/Value-level_programming", "Tacit programming": "/wiki/Tacit_programming", "Concatenative programming language": "/wiki/Concatenative_programming_language", "Generic programming": "/wiki/Generic_programming", "Procedural programming": "/wiki/Procedural_programming", "Object-oriented programming": "/wiki/Object-oriented_programming", "Intentional programming": "/wiki/Intentional_programming", "Language-oriented programming": "/wiki/Language-oriented_programming", "Domain-specific language": "/wiki/Domain-specific_language", "Literate programming": "/wiki/Literate_programming", "Macroprogramming": "/wiki/Macroprogramming", "Metaprogramming": "/wiki/Metaprogramming", "Automatic programming": "/wiki/Automatic_programming", "Inductive programming": "/wiki/Inductive_programming", "Reflective programming": "/wiki/Reflective_programming", "Attribute-oriented programming": "/wiki/Attribute-oriented_programming", "Macro (computer science)": "/wiki/Macro_(computer_science)", "Template metaprogramming": "/wiki/Template_metaprogramming", "Natural-language programming": "/wiki/Natural-language_programming", "Non-structured programming": "/wiki/Non-structured_programming", "Structured programming": "/wiki/Structured_programming", "Nondeterministic programming": "/wiki/Nondeterministic_programming", "Parallel computing": "/wiki/Parallel_computing", "Process-oriented programming": "/wiki/Process-oriented_programming", "Probabilistic programming": "/wiki/Probabilistic_programming", "Quantum programming": "/wiki/Quantum_programming", "Set theoretic programming": "/wiki/Set_theoretic_programming", "Stack-oriented programming": "/wiki/Stack-oriented_programming", "Block (programming)": "/wiki/Block_(programming)", "Agent-oriented programming": "/wiki/Agent-oriented_programming", "Class-based programming": "/wiki/Class-based_programming", "Concurrent object-oriented programming": "/wiki/Concurrent_object-oriented_programming", "Prototype-based programming": "/wiki/Prototype-based_programming", "Separation of concerns": "/wiki/Separation_of_concerns", "Aspect-oriented programming": "/wiki/Aspect-oriented_programming", "Role-oriented programming": "/wiki/Role-oriented_programming", "Subject-oriented programming": "/wiki/Subject-oriented_programming", "Symbolic programming": "/wiki/Symbolic_programming", "Template:Programming paradigms": "/wiki/Template:Programming_paradigms", "Template talk:Programming paradigms": "/wiki/Template_talk:Programming_paradigms", "Computer science": "/wiki/Computer_science", "Computational problem": "/wiki/Computational_problem", "Function (computer science)": "/wiki/Function_(computer_science)", "Niklaus Wirth": "/wiki/Niklaus_Wirth", "Programming language": "/wiki/Programming_language", "Clojure": "/wiki/Clojure", "Computability theory": "/wiki/Computability_theory", "Turing completeness": "/wiki/Turing_completeness", "Imperative language": "/wiki/Imperative_language", "Call stack": "/wiki/Call_stack", "Algorithmic efficiency": "/wiki/Algorithmic_efficiency", "Tail call": "/wiki/Tail_call", "Wikipedia:Citation needed": "/wiki/Wikipedia:Citation_needed", "Edit section: Recursive functions and algorithms": "/w/index.php?title=Recursion_(computer_science)&action=edit&section=1", "Algorithm": "/wiki/Algorithm#Design", "Divide-and-conquer method": "/wiki/Divide-and-conquer_method", "Lookup table": "/wiki/Lookup_table", "Dynamic programming": "/wiki/Dynamic_programming", "Memoization": "/wiki/Memoization", "Edit section: Base case": "/w/index.php?title=Recursion_(computer_science)&action=edit&section=2", "Trivial (mathematics)": "/wiki/Trivial_(mathematics)", "Factorial": "/wiki/Factorial", "Daemon (computer software)": "/wiki/Daemon_(computer_software)", "Infinite loop": "/wiki/Infinite_loop", "Series (mathematics)": "/wiki/Series_(mathematics)", "E (mathematical constant)": "/wiki/E_(mathematical_constant)", "Parameter": "/wiki/Parameter", "Corecursion": "/wiki/Corecursion", "Wikipedia:Please clarify": "/wiki/Wikipedia:Please_clarify", "Edit section: Recursive data types": "/w/index.php?title=Recursion_(computer_science)&action=edit&section=3", "Computer program": "/wiki/Computer_program", "Data": "/wiki/Data", "Programmer": "/wiki/Programmer", "Self reference": "/wiki/Self_reference", "Coinduction": "/wiki/Coinduction", "Algebraic data type": "/wiki/Algebraic_data_type", "Edit section: Inductively defined data": "/w/index.php?title=Recursion_(computer_science)&action=edit&section=4", "Recursive data type": "/wiki/Recursive_data_type", "Linked list": "/wiki/Linked_list", "Haskell (programming language)": "/wiki/Haskell_(programming_language)", "Definition": "/wiki/Definition", "Natural numbers": "/wiki/Natural_numbers", "Integers": "/wiki/Integers", "Expression (programming)": "/wiki/Expression_(programming)", "Statement (programming)": "/wiki/Statement_(programming)", "Backus\u2013Naur form": "/wiki/Backus%E2%80%93Naur_form", "Edit section: Coinductively defined data and corecursion": "/w/index.php?title=Recursion_(computer_science)&action=edit&section=5", "Stream (computer science)": "/wiki/Stream_(computer_science)", "Accessor": "/wiki/Accessor", "Lazy evaluation": "/wiki/Lazy_evaluation", "Prime numbers": "/wiki/Prime_numbers", "Fold (higher-order function)": "/wiki/Fold_(higher-order_function)#Examples", "Edit section: Types of recursion": "/w/index.php?title=Recursion_(computer_science)&action=edit&section=6", "Edit section: Single recursion and multiple recursion": "/w/index.php?title=Recursion_(computer_science)&action=edit&section=7", "Tree traversal": "/wiki/Tree_traversal", "Threaded binary tree": "/wiki/Threaded_binary_tree", "Edit section: Indirect recursion": "/w/index.php?title=Recursion_(computer_science)&action=edit&section=8", "Mutual recursion": "/wiki/Mutual_recursion", "Edit section: Anonymous recursion": "/w/index.php?title=Recursion_(computer_science)&action=edit&section=9", "Anonymous recursion": "/wiki/Anonymous_recursion", "Anonymous function": "/wiki/Anonymous_function", "Edit section: Structural versus generative recursion": "/w/index.php?title=Recursion_(computer_science)&action=edit&section=10", "Structural recursion": "/wiki/Structural_recursion", "How to Design Programs": "/wiki/How_to_Design_Programs", "Euclidean algorithm": "/wiki/Euclidean_algorithm", "Quicksort": "/wiki/Quicksort", "Binary search": "/wiki/Binary_search", "Mergesort": "/wiki/Mergesort", "Newton's method": "/wiki/Newton%27s_method", "Fractal": "/wiki/Fractal", "Adaptive quadrature": "/wiki/Adaptive_quadrature", "Termination analysis": "/wiki/Termination_analysis#Termination_proof", "Structural induction": "/wiki/Structural_induction", "Infinite loops": "/wiki/Infinite_loops", "Loop variant": "/wiki/Loop_variant", "Edit section: Implementation issues": "/w/index.php?title=Recursion_(computer_science)&action=edit&section=11", "Edit section: Wrapper function": "/w/index.php?title=Recursion_(computer_science)&action=edit&section=12", "Wrapper function": "/wiki/Wrapper_function", "Nested function": "/wiki/Nested_function", "Pass-by-reference": "/wiki/Pass-by-reference", "Edit section: Short-circuiting the base case": "/w/index.php?title=Recursion_(computer_science)&action=edit&section=13", "C (programming language)": "/wiki/C_(programming_language)", "Edit section: Depth-first search": "/w/index.php?title=Recursion_(computer_science)&action=edit&section=14", "Depth-first search": "/wiki/Depth-first_search", "Perfect binary tree": "/wiki/Perfect_binary_tree", "Short-circuit evaluation": "/wiki/Short-circuit_evaluation", "Control flow": "/wiki/Control_flow", "Edit section: Hybrid algorithm": "/w/index.php?title=Recursion_(computer_science)&action=edit&section=15", "Merge sort": "/wiki/Merge_sort", "Insertion sort": "/wiki/Insertion_sort", "Tiled merge sort": "/wiki/Tiled_merge_sort", "Timsort": "/wiki/Timsort", "Edit section: Recursion versus iteration": "/w/index.php?title=Recursion_(computer_science)&action=edit&section=16", "Iteration": "/wiki/Iteration", "Edit section: Expressive power": "/w/index.php?title=Recursion_(computer_science)&action=edit&section=17", "Runtime environment": "/wiki/Runtime_environment", "Instance (computer science)": "/wiki/Instance_(computer_science)", "Stack (data structure)": "/wiki/Stack_(data_structure)", "While loop": "/wiki/While_loop", "For loop": "/wiki/For_loop", "Functional language": "/wiki/Functional_language", "Tail call elimination": "/wiki/Tail_call_elimination", "Java (programming language)": "/wiki/Java_(programming_language)", "Python (programming language)": "/wiki/Python_(programming_language)", "Stack overflow": "/wiki/Stack_overflow", "Edit section: Performance issues": "/w/index.php?title=Recursion_(computer_science)&action=edit&section=18", "Functional languages": "/wiki/Functional_languages", "Compiler": "/wiki/Compiler", "Order of magnitude": "/wiki/Order_of_magnitude", "Edit section: Stack space": "/w/index.php?title=Recursion_(computer_science)&action=edit&section=19", "Heap (programming)": "/wiki/Heap_(programming)", "Stack buffer overflow": "/wiki/Stack_buffer_overflow", "Tail recursion": "/wiki/Tail_recursion", "Edit section: Vulnerability": "/w/index.php?title=Recursion_(computer_science)&action=edit&section=20", "Pathological (mathematics)": "/wiki/Pathological_(mathematics)", "Malware": "/wiki/Malware", "Exception handling": "/wiki/Exception_handling", "Logic": "/wiki/Logic", "Process (computing)": "/wiki/Process_(computing)", "Process state": "/wiki/Process_state#Terminated", "Edit section: Multiply recursive problems": "/w/index.php?title=Recursion_(computer_science)&action=edit&section=21", "Divide-and-conquer algorithm": "/wiki/Divide-and-conquer_algorithm", "Ackermann function": "/wiki/Ackermann_function", "Edit section: Refactoring recursion": "/w/index.php?title=Recursion_(computer_science)&action=edit&section=22", "Memory management": "/wiki/Memory_management", "Stack-based memory allocation": "/wiki/Stack-based_memory_allocation", "Matching wildcards": "/wiki/Matching_wildcards", "Rich Salz": "/wiki/Rich_Salz", "Wildmat": "/wiki/Wildmat", "Krauss matching wildcards algorithm": "/wiki/Krauss_matching_wildcards_algorithm", "Software testing": "/wiki/Software_testing", "Profiling (computer programming)": "/wiki/Profiling_(computer_programming)", "Edit section: Tail-recursive functions": "/w/index.php?title=Recursion_(computer_science)&action=edit&section=23", "Interpreter (computing)": "/wiki/Interpreter_(computing)", "Goto": "/wiki/Goto", "Edit section: Order of execution": "/w/index.php?title=Recursion_(computer_science)&action=edit&section=24", "Edit section: Function 1": "/w/index.php?title=Recursion_(computer_science)&action=edit&section=25", "Edit section: Function 2": "/w/index.php?title=Recursion_(computer_science)&action=edit&section=26", "Edit section: Recursive procedures": "/w/index.php?title=Recursion_(computer_science)&action=edit&section=27", "Edit section: Factorial": "/w/index.php?title=Recursion_(computer_science)&action=edit&section=28", "Natural number": "/wiki/Natural_number", "Pseudocode": "/wiki/Pseudocode", "Recurrence relation": "/wiki/Recurrence_relation", "Functional programming language": "/wiki/Functional_programming_language", "Scheme (programming language)": "/wiki/Scheme_(programming_language)", "Edit section: Greatest common divisor": "/w/index.php?title=Recursion_(computer_science)&action=edit&section=29", "Greatest common divisor": "/wiki/Greatest_common_divisor", "Remainder": "/wiki/Remainder", "Tail-recursive": "/wiki/Tail-recursive", "Edit section: Towers of Hanoi": "/w/index.php?title=Recursion_(computer_science)&action=edit&section=30", "Towers of Hanoi": "/wiki/Towers_of_Hanoi", "Edit section: Binary search": "/w/index.php?title=Recursion_(computer_science)&action=edit&section=31", "Sorted array": "/wiki/Sorted_array", "Edit section: Recursive data structures (structural recursion)": "/w/index.php?title=Recursion_(computer_science)&action=edit&section=32", "List (abstract data type)": "/wiki/List_(abstract_data_type)", "Tree (data structure)": "/wiki/Tree_(data_structure)", "Edit section: Linked lists": "/w/index.php?title=Recursion_(computer_science)&action=edit&section=33", "Edit section: Binary trees": "/w/index.php?title=Recursion_(computer_science)&action=edit&section=34", "Binary tree": "/wiki/Binary_tree", "Binary search tree": "/wiki/Binary_search_tree", "Edit section: Filesystem traversal": "/w/index.php?title=Recursion_(computer_science)&action=edit&section=35", "Filesystem": "/wiki/Filesystem", "Preorder traversal": "/wiki/Preorder_traversal", "Edit section: Time-efficiency of recursive algorithms": "/w/index.php?title=Recursion_(computer_science)&action=edit&section=36", "Time complexity": "/wiki/Time_complexity", "Big O notation": "/wiki/Big_O_notation", "Edit section: Shortcut rule (master theorem)": "/w/index.php?title=Recursion_(computer_science)&action=edit&section=37", "Master theorem (analysis of algorithms)": "/wiki/Master_theorem_(analysis_of_algorithms)", "Edit section: See also": "/w/index.php?title=Recursion_(computer_science)&action=edit&section=38", "Hierarchical and recursive queries in SQL": "/wiki/Hierarchical_and_recursive_queries_in_SQL", "Kleene\u2013Rosser paradox": "/wiki/Kleene%E2%80%93Rosser_paradox", "Open recursion": "/wiki/Open_recursion", "Sierpi\u0144ski curve": "/wiki/Sierpi%C5%84ski_curve", "McCarthy 91 function": "/wiki/McCarthy_91_function", "\u039c-recursive function": "/wiki/%CE%9C-recursive_function", "Primitive recursive function": "/wiki/Primitive_recursive_function", "Tak (function)": "/wiki/Tak_(function)", "Edit section: Notes": "/w/index.php?title=Recursion_(computer_science)&action=edit&section=39", "ISBN (identifier)": "/wiki/ISBN_(identifier)", "Special:BookSources/0-201-55802-5": "/wiki/Special:BookSources/0-201-55802-5", "Special:BookSources/978-0-53494446-9": "/wiki/Special:BookSources/978-0-53494446-9", "Prentice-Hall": "/wiki/Prentice-Hall", "Special:BookSources/978-0-13022418-7": "/wiki/Special:BookSources/978-0-13022418-7", "Special:BookSources/9783540448334": "/wiki/Special:BookSources/9783540448334", "Wiley (publisher)": "/wiki/Wiley_(publisher)", "Special:BookSources/978-1-118-26136-1": "/wiki/Special:BookSources/978-1-118-26136-1", "Special:BookSources/9781430232384": "/wiki/Special:BookSources/9781430232384", "Special:BookSources/9781285415017": "/wiki/Special:BookSources/9781285415017", "Dr. Dobb's Journal": "/wiki/Dr._Dobb%27s_Journal", "Microsoft Developer Network": "/wiki/Microsoft_Developer_Network", "ThoughtWorks": "/wiki/ThoughtWorks", "GitHub": "/wiki/GitHub", "Edit section: References": "/w/index.php?title=Recursion_(computer_science)&action=edit&section=40", "David W. Barron": "/wiki/David_W._Barron", "Stanley Gill": "/wiki/Stanley_Gill", "Macdonald & Co. (Publishers) Ltd.": "/wiki/Macdonald_%26_Co._(Publishers)_Ltd.", "SBN (identifier)": "/wiki/SBN_(identifier)", "Special:BookSources/0-356-02201-3": "/wiki/Special:BookSources/0-356-02201-3", "MIT Press": "/wiki/MIT_Press", "Special:BookSources/0262062186": "/wiki/Special:BookSources/0262062186", "CRC Press": "/wiki/CRC_Press", "Special:BookSources/978-1-351-64717-5": "/wiki/Special:BookSources/978-1-351-64717-5", "Special:BookSources/978-1-5327-1227-2": "/wiki/Special:BookSources/978-1-5327-1227-2", "Special:BookSources/978-0-47170146-0": "/wiki/Special:BookSources/978-0-47170146-0", "Cambridge University Press": "/wiki/Cambridge_University_Press", "Special:BookSources/978-0-521-26934-6": "/wiki/Special:BookSources/978-0-521-26934-6", "Walls and Mirrors": "/wiki/Walls_and_Mirrors", "Harold Abelson": "/wiki/Harold_Abelson", "Gerald Jay Sussman": "/wiki/Gerald_Jay_Sussman", "Structure and Interpretation of Computer Programs": "/wiki/Structure_and_Interpretation_of_Computer_Programs", "Special:BookSources/0-262-51087-1": "/wiki/Special:BookSources/0-262-51087-1", "Edsger W. Dijkstra": "/wiki/Edsger_W._Dijkstra", "Doi (identifier)": "/wiki/Doi_(identifier)", "S2CID (identifier)": "/wiki/S2CID_(identifier)", "Template:Algorithmic paradigms": "/wiki/Template:Algorithmic_paradigms", "Template talk:Algorithmic paradigms": "/wiki/Template_talk:Algorithmic_paradigms", "Algorithms": "/wiki/Algorithms", "Category:Algorithms": "/wiki/Category:Algorithms", "Minimax": "/wiki/Minimax", "Sorting algorithm": "/wiki/Sorting_algorithm", "Search algorithm": "/wiki/Search_algorithm", "Streaming algorithm": "/wiki/Streaming_algorithm", "Algorithmic paradigm": "/wiki/Algorithmic_paradigm", "Backtracking": "/wiki/Backtracking", "Brute-force search": "/wiki/Brute-force_search", "Greedy algorithm": "/wiki/Greedy_algorithm", "Sweep line algorithm": "/wiki/Sweep_line_algorithm", "Breadth-first search": "/wiki/Breadth-first_search", "Topological sorting": "/wiki/Topological_sorting", "List of algorithms": "/wiki/List_of_algorithms"}