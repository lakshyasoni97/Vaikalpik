{"Type system": "/wiki/Type_system", "Type safety": "/wiki/Type_safety", "Strong and weak typing": "/wiki/Strong_and_weak_typing", "Manifest typing": "/wiki/Manifest_typing", "Type inference": "/wiki/Type_inference", "Nominal type system": "/wiki/Nominal_type_system", "Structural type system": "/wiki/Structural_type_system", "Duck typing": "/wiki/Duck_typing", "Abstract type": "/wiki/Abstract_type", "Flow-sensitive typing": "/wiki/Flow-sensitive_typing", "Gradual typing": "/wiki/Gradual_typing", "Intersection type": "/wiki/Intersection_type", "Latent typing": "/wiki/Latent_typing", "Refinement type": "/wiki/Refinement_type", "Substructural type system": "/wiki/Substructural_type_system", "Uniqueness type": "/wiki/Uniqueness_type", "Session type": "/wiki/Session_type", "Template:Type systems": "/wiki/Template:Type_systems", "Template talk:Type systems": "/wiki/Template_talk:Type_systems", "Computer science": "/wiki/Computer_science", "Logic": "/wiki/Logic", "Type theory": "/wiki/Type_theory", "Intuitionistic type theory": "/wiki/Intuitionistic_type_theory", "Generalized quantifier": "/wiki/Generalized_quantifier", "Functional programming languages": "/wiki/Functional_programming_languages", "Agda (theorem prover)": "/wiki/Agda_(theorem_prover)", "ATS (programming language)": "/wiki/ATS_(programming_language)", "Coq": "/wiki/Coq", "F* (programming language)": "/wiki/F*_(programming_language)", "Epigram (programming language)": "/wiki/Epigram_(programming_language)", "Idris (programming language)": "/wiki/Idris_(programming_language)", "Polymorphism (computer science)": "/wiki/Polymorphism_(computer_science)", "Generic programming": "/wiki/Generic_programming", "Decidable problem": "/wiki/Decidable_problem", "Type checking": "/wiki/Type_checking", "Intensional type theory": "/wiki/Intensional_type_theory", "Extensional type theory": "/wiki/Extensional_type_theory", "Edit section: History": "/w/index.php?title=Dependent_type&action=edit&section=1", "Haskell Curry": "/wiki/Haskell_Curry", "Typed lambda calculus": "/wiki/Typed_lambda_calculus", "Combinatory logic": "/wiki/Combinatory_logic", "Propositional calculus": "/wiki/Propositional_calculus", "Simply typed lambda calculus": "/wiki/Simply_typed_lambda_calculus", "Intuitionistic logic": "/wiki/Intuitionistic_logic", "Predicate logic": "/wiki/Predicate_logic", "William Alvin Howard": "/wiki/William_Alvin_Howard", "Nicolaas Govert de Bruijn": "/wiki/Nicolaas_Govert_de_Bruijn", "Curry\u2013Howard correspondence": "/wiki/Curry%E2%80%93Howard_correspondence", "Edit section: Formal definition": "/w/index.php?title=Dependent_type&action=edit&section=2", "Edit section: \u03a0 type": "/w/index.php?title=Dependent_type&action=edit&section=3", "Codomain": "/wiki/Codomain", "Function type": "/wiki/Function_type", "Cartesian product": "/wiki/Cartesian_product", "Model theory": "/wiki/Model_theory", "Universal quantification": "/wiki/Universal_quantification#As_adjoint", "Real numbers": "/wiki/Real_numbers", "Natural number": "/wiki/Natural_number", "Edit section: \u03a3 type": "/w/index.php?title=Dependent_type&action=edit&section=4", "Dual (category theory)": "/wiki/Dual_(category_theory)", "Product type": "/wiki/Product_type", "Wikipedia:Citing sources": "/wiki/Wikipedia:Citing_sources#What_information_to_include", "Edit section: Example as existential quantification": "/w/index.php?title=Dependent_type&action=edit&section=5", "Predicate (mathematical logic)": "/wiki/Predicate_(mathematical_logic)", "If and only if": "/wiki/If_and_only_if", "Edit section: Systems of the lambda cube": "/w/index.php?title=Dependent_type&action=edit&section=6", "Henk Barendregt": "/wiki/Henk_Barendregt", "Lambda cube": "/wiki/Lambda_cube", "Calculus of constructions": "/wiki/Calculus_of_constructions", "Kind (type theory)": "/wiki/Kind_(type_theory)", "Pure type system": "/wiki/Pure_type_system", "Edit section: First order dependent type theory": "/w/index.php?title=Dependent_type&action=edit&section=7", "LF (logical framework)": "/wiki/LF_(logical_framework)", "Edit section: Second order dependent type theory": "/w/index.php?title=Dependent_type&action=edit&section=8", "System F": "/wiki/System_F", "Edit section: Higher order dependently typed polymorphic lambda calculus": "/w/index.php?title=Dependent_type&action=edit&section=9", "Calculus of inductive constructions": "/wiki/Calculus_of_inductive_constructions", "Edit section: Simultaneous programming language and logic": "/w/index.php?title=Dependent_type&action=edit&section=10", "Constructive proof": "/wiki/Constructive_proof", "Proof assistant": "/wiki/Proof_assistant", "Program verification": "/wiki/Program_verification", "Proof-carrying code": "/wiki/Proof-carrying_code", "Edit section: Comparison of languages with dependent types": "/w/index.php?title=Dependent_type&action=edit&section=11", "Tactic (computer science) (page does not exist)": "/w/index.php?title=Tactic_(computer_science)&action=edit&redlink=1", "Proof term (page does not exist)": "/w/index.php?title=Proof_term&action=edit&redlink=1", "Termination checking": "/wiki/Termination_checking", "Universe (mathematics)": "/wiki/Universe_(mathematics)", "Proof irrelevance (page does not exist)": "/w/index.php?title=Proof_irrelevance&action=edit&redlink=1", "Program extraction (page does not exist)": "/w/index.php?title=Program_extraction&action=edit&redlink=1", "Ada (programming language)": "/wiki/Ada_(programming_language)", "Purely functional programming": "/wiki/Purely_functional_programming", "Haskell (programming language)": "/wiki/Haskell_(programming_language)", "Cayenne (programming language)": "/wiki/Cayenne_(programming_language)", "Scheme (programming language)": "/wiki/Scheme_(programming_language)", "OCaml": "/wiki/OCaml", "Dependent ML": "/wiki/Dependent_ML", "F Sharp (programming language)": "/wiki/F_Sharp_(programming_language)", "C (programming language)": "/wiki/C_(programming_language)", "Lean (proof assistant)": "/wiki/Lean_(proof_assistant)", "Matita": "/wiki/Matita", "NuPRL": "/wiki/NuPRL", "Prototype Verification System": "/wiki/Prototype_Verification_System", "Twelf": "/wiki/Twelf", "Logic programming": "/wiki/Logic_programming", "Subroutine": "/wiki/Subroutine", "Edit section: See also": "/w/index.php?title=Dependent_type&action=edit&section=12", "Edit section: References": "/w/index.php?title=Dependent_type&action=edit&section=13", "CiteSeerX (identifier)": "/wiki/CiteSeerX_(identifier)", "ArXiv (identifier)": "/wiki/ArXiv_(identifier)", "GitHub": "/wiki/GitHub", "Edit section: Further reading": "/w/index.php?title=Dependent_type&action=edit&section=14", "Per Martin-L\u00f6f": "/wiki/Per_Martin-L%C3%B6f", "Bengt Nordstr\u00f6m (page does not exist)": "/w/index.php?title=Bengt_Nordstr%C3%B6m&action=edit&redlink=1", "ISBN (identifier)": "/wiki/ISBN_(identifier)", "Special:BookSources/9780198538141": "/wiki/Special:BookSources/9780198538141", "Oxford University Press": "/wiki/Oxford_University_Press", "Conor McBride": "/wiki/Conor_McBride", "James McKinna (page does not exist)": "/w/index.php?title=James_McKinna&action=edit&redlink=1", "Journal of Functional Programming": "/wiki/Journal_of_Functional_Programming", "Doi (identifier)": "/wiki/Doi_(identifier)", "S2CID (identifier)": "/wiki/S2CID_(identifier)", "Thorsten Altenkirch": "/wiki/Thorsten_Altenkirch", "Special:BookSources/1-59593-027-2": "/wiki/Special:BookSources/1-59593-027-2", "Special:BookSources/978-91-7291-996-9": "/wiki/Special:BookSources/978-91-7291-996-9", "Special:BookSources/9781595939197": "/wiki/Special:BookSources/9781595939197", "Special:BookSources/978-3-642-04651-3": "/wiki/Special:BookSources/978-3-642-04651-3", "Special:BookSources/978-1723139413": "/wiki/Special:BookSources/978-1723139413", "Special:BookSources/9789811242380": "/wiki/Special:BookSources/9789811242380", "Edit section: External links": "/w/index.php?title=Dependent_type&action=edit&section=15", "NLab": "/wiki/NLab", "Template:Foundations-footer": "/wiki/Template:Foundations-footer", "Template talk:Foundations-footer": "/wiki/Template_talk:Foundations-footer", "Foundations of mathematics": "/wiki/Foundations_of_mathematics", "Mathematical logic": "/wiki/Mathematical_logic", "Peano axioms": "/wiki/Peano_axioms", "Mathematical induction": "/wiki/Mathematical_induction", "Formal system": "/wiki/Formal_system", "Axiomatic system": "/wiki/Axiomatic_system", "Hilbert system": "/wiki/Hilbert_system", "Natural deduction": "/wiki/Natural_deduction", "Mathematical proof": "/wiki/Mathematical_proof", "Mathematical constructivism": "/wiki/Mathematical_constructivism", "Modal logic": "/wiki/Modal_logic", "List of mathematical logic topics": "/wiki/List_of_mathematical_logic_topics", "Set theory": "/wiki/Set_theory", "Set (mathematics)": "/wiki/Set_(mathematics)", "Naive set theory": "/wiki/Naive_set_theory", "Zermelo set theory": "/wiki/Zermelo_set_theory", "Zermelo\u2013Fraenkel set theory": "/wiki/Zermelo%E2%80%93Fraenkel_set_theory", "Constructive set theory": "/wiki/Constructive_set_theory", "Descriptive set theory": "/wiki/Descriptive_set_theory", "Determinacy": "/wiki/Determinacy", "Russell's paradox": "/wiki/Russell%27s_paradox", "List of set theory topics": "/wiki/List_of_set_theory_topics", "Axiom of reducibility": "/wiki/Axiom_of_reducibility", "History of type theory": "/wiki/History_of_type_theory#Theory_of_simple_types", "Homotopy type theory": "/wiki/Homotopy_type_theory", "Univalent foundations": "/wiki/Univalent_foundations", "Girard's paradox": "/wiki/Girard%27s_paradox", "Category theory": "/wiki/Category_theory", "Category (mathematics)": "/wiki/Category_(mathematics)", "Topos": "/wiki/Topos", "Category of sets": "/wiki/Category_of_sets", "Higher category theory": "/wiki/Higher_category_theory", "\u221e-groupoid": "/wiki/%E2%88%9E-groupoid", "\u221e-topos": "/wiki/%E2%88%9E-topos", "Structuralism (philosophy of mathematics)": "/wiki/Structuralism_(philosophy_of_mathematics)", "Glossary of category theory": "/wiki/Glossary_of_category_theory", "List of category theory topics": "/wiki/List_of_category_theory_topics"}